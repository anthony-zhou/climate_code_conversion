<html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             

             
             #config {
                 float: left;
                 width: 400px;
                 height: 600px;
             }
             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
        
            <div id="config"></div>
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#97c2fc", "id": "this % InitAllocate", "label": "this % InitAllocate", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Init", "label": "Init", "shape": "dot", "size": 10, "source": "SUBROUTINE Init(this, bounds)\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  CALL this % InitAllocate(bounds)\n  CALL this % InitHistory(bounds)\n  CALL this % InitCold(bounds)\nEND SUBROUTINE Init"}, {"color": "#97c2fc", "id": "this % InitHistory", "label": "this % InitHistory", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "this % InitCold", "label": "this % InitCold", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "params_inst % cleanParams", "label": "params_inst % cleanParams", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Clean", "label": "Clean", "shape": "dot", "size": 10, "source": "SUBROUTINE Clean(this)\n  CLASS(photosyns_type) :: this\n  CALL params_inst % cleanParams\n  DEALLOCATE(this % c3flag_patch)\n  DEALLOCATE(this % ac_phs_patch)\n  DEALLOCATE(this % aj_phs_patch)\n  DEALLOCATE(this % ap_phs_patch)\n  DEALLOCATE(this % ag_phs_patch)\n  DEALLOCATE(this % an_sun_patch)\n  DEALLOCATE(this % an_sha_patch)\n  DEALLOCATE(this % vcmax_z_phs_patch)\n  DEALLOCATE(this % tpu_z_phs_patch)\n  DEALLOCATE(this % kp_z_phs_patch)\n  DEALLOCATE(this % gs_mol_sun_patch)\n  DEALLOCATE(this % gs_mol_sha_patch)\n  DEALLOCATE(this % gs_mol_sun_ln_patch)\n  DEALLOCATE(this % gs_mol_sha_ln_patch)\n  DEALLOCATE(this % ac_patch)\n  DEALLOCATE(this % aj_patch)\n  DEALLOCATE(this % ap_patch)\n  DEALLOCATE(this % ag_patch)\n  DEALLOCATE(this % an_patch)\n  DEALLOCATE(this % vcmax_z_patch)\n  DEALLOCATE(this % tpu_z_patch)\n  DEALLOCATE(this % kp_z_patch)\n  DEALLOCATE(this % gs_mol_patch)\n  DEALLOCATE(this % cp_patch)\n  DEALLOCATE(this % kc_patch)\n  DEALLOCATE(this % ko_patch)\n  DEALLOCATE(this % qe_patch)\n  DEALLOCATE(this % bbb_patch)\n  DEALLOCATE(this % mbb_patch)\n  DEALLOCATE(this % gb_mol_patch)\n  DEALLOCATE(this % rh_leaf_patch)\n  DEALLOCATE(this % vpd_can_patch)\n  DEALLOCATE(this % psnsun_patch)\n  DEALLOCATE(this % psnsha_patch)\n  DEALLOCATE(this % c13_psnsun_patch)\n  DEALLOCATE(this % c13_psnsha_patch)\n  DEALLOCATE(this % c14_psnsun_patch)\n  DEALLOCATE(this % c14_psnsha_patch)\n  DEALLOCATE(this % psnsun_z_patch)\n  DEALLOCATE(this % psnsha_z_patch)\n  DEALLOCATE(this % psnsun_wc_patch)\n  DEALLOCATE(this % psnsha_wc_patch)\n  DEALLOCATE(this % psnsun_wj_patch)\n  DEALLOCATE(this % psnsha_wj_patch)\n  DEALLOCATE(this % psnsun_wp_patch)\n  DEALLOCATE(this % psnsha_wp_patch)\n  DEALLOCATE(this % fpsn_patch)\n  DEALLOCATE(this % fpsn_wc_patch)\n  DEALLOCATE(this % fpsn_wj_patch)\n  DEALLOCATE(this % fpsn_wp_patch)\n  DEALLOCATE(this % lnca_patch)\n  DEALLOCATE(this % lmrsun_z_patch)\n  DEALLOCATE(this % lmrsha_z_patch)\n  DEALLOCATE(this % lmrsun_patch)\n  DEALLOCATE(this % lmrsha_patch)\n  DEALLOCATE(this % alphapsnsun_patch)\n  DEALLOCATE(this % alphapsnsha_patch)\n  DEALLOCATE(this % rc13_canair_patch)\n  DEALLOCATE(this % rc13_psnsun_patch)\n  DEALLOCATE(this % rc13_psnsha_patch)\n  DEALLOCATE(this % cisun_z_patch)\n  DEALLOCATE(this % cisha_z_patch)\n  DEALLOCATE(this % rssun_z_patch)\n  DEALLOCATE(this % rssha_z_patch)\n  DEALLOCATE(this % rssun_patch)\n  DEALLOCATE(this % rssha_patch)\n  DEALLOCATE(this % luvcmax25top_patch)\n  DEALLOCATE(this % lujmax25top_patch)\n  DEALLOCATE(this % lutpu25top_patch)\n  IF (use_luna) THEN\n    DEALLOCATE(this % vcmx25_z_patch)\n    DEALLOCATE(this % jmx25_z_patch)\n    DEALLOCATE(this % vcmx25_z_last_valid_patch)\n    DEALLOCATE(this % jmx25_z_last_valid_patch)\n    DEALLOCATE(this % pnlc_z_patch)\n    DEALLOCATE(this % fpsn24_patch)\n    DEALLOCATE(this % enzs_z_patch)\n  END IF\nEND SUBROUTINE Clean"}, {"color": "#97c2fc", "id": "hist_addfld1d", "label": "hist_addfld1d", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "InitHistory", "label": "InitHistory", "shape": "dot", "size": 10, "source": "SUBROUTINE InitHistory(this, bounds)\n  USE histFileMod, ONLY: hist_addfld1d, hist_addfld2d\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  REAL(KIND = r8), POINTER :: ptr_1d(:)\n  INTEGER :: begp, endp\n  begp = bounds % begp\n  endp = bounds % endp\n  this % rh_leaf_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027RH_LEAF\u0027, units = \u0027fraction\u0027, avgflag = \u0027A\u0027, long_name = \u0027fractional humidity at leaf surface\u0027, ptr_patch = this % rh_leaf_patch, set_spec = spval, default = \u0027inactive\u0027)\n  this % vpd_can_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027VPD_CAN\u0027, units = \u0027kPa\u0027, avgflag = \u0027A\u0027, long_name = \u0027canopy vapor pressure deficit\u0027, ptr_patch = this % vpd_can_patch, set_spec = spval, default = \u0027active\u0027)\n  this % lnca_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027LNC\u0027, units = \u0027gN leaf/m^2\u0027, avgflag = \u0027A\u0027, long_name = \u0027leaf N concentration\u0027, ptr_patch = this % lnca_patch, set_spec = spval)\n  IF (.NOT. use_fates) THEN\n    this % fpsn_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027A\u0027, long_name = \u0027photosynthesis\u0027, ptr_patch = this % fpsn_patch, set_lake = 0._r8, set_urb = 0._r8)\n    this % fpsn_wc_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN_WC\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027I\u0027, long_name = \u0027Rubisco-limited photosynthesis\u0027, ptr_patch = this % fpsn_wc_patch, set_lake = 0._r8, set_urb = 0._r8, default = \u0027inactive\u0027)\n    this % fpsn_wj_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN_WJ\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027I\u0027, long_name = \u0027RuBP-limited photosynthesis\u0027, ptr_patch = this % fpsn_wj_patch, set_lake = 0._r8, set_urb = 0._r8, default = \u0027inactive\u0027)\n    this % fpsn_wp_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN_WP\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027I\u0027, long_name = \u0027Product-limited photosynthesis\u0027, ptr_patch = this % fpsn_wp_patch, set_lake = 0._r8, set_urb = 0._r8, default = \u0027inactive\u0027)\n  END IF\n  IF (use_cn) THEN\n    this % psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027PSNSUN\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf photosynthesis\u0027, ptr_patch = this % psnsun_patch)\n    this % psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027PSNSHA\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf photosynthesis\u0027, ptr_patch = this % psnsha_patch)\n  END IF\n  IF (use_c13) THEN\n    this % c13_psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C13_PSNSUN\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13 sunlit leaf photosynthesis\u0027, ptr_patch = this % c13_psnsun_patch, default = \u0027inactive\u0027)\n    this % c13_psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C13_PSNSHA\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13 shaded leaf photosynthesis\u0027, ptr_patch = this % c13_psnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  IF (use_c14) THEN\n    this % c14_psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C14_PSNSUN\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C14 sunlit leaf photosynthesis\u0027, ptr_patch = this % c14_psnsun_patch, default = \u0027inactive\u0027)\n    this % c14_psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C14_PSNSHA\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C14 shaded leaf photosynthesis\u0027, ptr_patch = this % c14_psnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  IF (use_c13) THEN\n    this % rc13_canair_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027RC13_CANAIR\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13/C(12+13) for canopy air\u0027, ptr_patch = this % rc13_canair_patch, default = \u0027inactive\u0027)\n    this % rc13_psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027RC13_PSNSUN\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13/C(12+13) for sunlit photosynthesis\u0027, ptr_patch = this % rc13_psnsun_patch, default = \u0027inactive\u0027)\n    this % rc13_psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027RC13_PSNSHA\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13/C(12+13) for shaded photosynthesis\u0027, ptr_patch = this % rc13_psnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  IF (use_c13) THEN\n    this % alphapsnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027ALPHAPSNSUN\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit c13 fractionation\u0027, ptr_patch = this % alphapsnsun_patch, default = \u0027inactive\u0027)\n    this % alphapsnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027ALPHAPSNSHA\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded c13 fractionation\u0027, ptr_patch = this % alphapsnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  this % rssun_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027RSSUN\u0027, units = \u0027s/m\u0027, avgflag = \u0027M\u0027, long_name = \u0027sunlit leaf stomatal resistance\u0027, ptr_patch = this % rssun_patch, l2g_scale_type = \u0027veg\u0027)\n  this % rssha_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027RSSHA\u0027, units = \u0027s/m\u0027, avgflag = \u0027M\u0027, long_name = \u0027shaded leaf stomatal resistance\u0027, ptr_patch = this % rssha_patch, l2g_scale_type = \u0027veg\u0027)\n  this % gs_mol_sun_patch(begp : endp, :) = spval\n  this % gs_mol_sha_patch(begp : endp, :) = spval\n  IF (nlevcan \u003e 1) THEN\n    CALL hist_addfld2d(fname = \u0027GSSUN\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance\u0027, ptr_patch = this % gs_mol_sun_patch, set_lake = spval, set_urb = spval)\n    CALL hist_addfld2d(fname = \u0027GSSHA\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance\u0027, ptr_patch = this % gs_mol_sha_patch, set_lake = spval, set_urb = spval)\n  ELSE\n    ptr_1d =\u003e this % gs_mol_sun_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSUN\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance\u0027, ptr_patch = ptr_1d)\n    ptr_1d =\u003e this % gs_mol_sha_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSHA\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance\u0027, ptr_patch = ptr_1d)\n  END IF\n  this % gs_mol_sun_ln_patch(begp : endp, :) = spval\n  this % gs_mol_sha_ln_patch(begp : endp, :) = spval\n  IF (nlevcan \u003e 1) THEN\n    CALL hist_addfld2d(fname = \u0027GSSUNLN\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, ptr_patch = this % gs_mol_sun_ln_patch, set_lake = spval, set_urb = spval)\n    CALL hist_addfld2d(fname = \u0027GSSHALN\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, ptr_patch = this % gs_mol_sha_ln_patch, set_lake = spval, set_urb = spval)\n  ELSE\n    ptr_1d =\u003e this % gs_mol_sun_ln_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSUNLN\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance at local noon\u0027, ptr_patch = ptr_1d)\n    ptr_1d =\u003e this % gs_mol_sha_ln_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSHALN\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance at local noon\u0027, ptr_patch = ptr_1d)\n  END IF\n  IF (use_luna) THEN\n    IF (nlevcan \u003e 1) THEN\n      CALL hist_addfld2d(fname = \u0027Vcmx25Z\u0027, units = \u0027umol/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027canopy profile of vcmax25 predicted by LUNA model\u0027, ptr_patch = this % vcmx25_z_patch)\n      CALL hist_addfld2d(fname = \u0027Jmx25Z\u0027, units = \u0027umol electrons/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027maximum rate of electron transport at 25 Celcius for canopy layers\u0027, ptr_patch = this % jmx25_z_patch)\n      CALL hist_addfld2d(fname = \u0027PNLCZ\u0027, units = \u0027unitless\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027Proportion of nitrogen allocated for light capture\u0027, ptr_patch = this % pnlc_z_patch, default = \u0027inactive\u0027)\n    ELSE\n      ptr_1d =\u003e this % vcmx25_z_patch(:, 1)\n      CALL hist_addfld1d(fname = \u0027Vcmx25Z\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027canopy profile of vcmax25 predicted by LUNA model\u0027, ptr_patch = ptr_1d)\n      ptr_1d =\u003e this % jmx25_z_patch(:, 1)\n      CALL hist_addfld1d(fname = \u0027Jmx25Z\u0027, units = \u0027umol electrons/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027maximum rate of electron transport at 25 Celcius for canopy layers\u0027, ptr_patch = ptr_1d)\n      ptr_1d =\u003e this % pnlc_z_patch(:, 1)\n      CALL hist_addfld1d(fname = \u0027PNLCZ\u0027, units = \u0027unitless\u0027, avgflag = \u0027A\u0027, long_name = \u0027Proportion of nitrogen allocated for light capture\u0027, ptr_patch = ptr_1d, default = \u0027inactive\u0027)\n      this % luvcmax25top_patch(begp : endp) = spval\n      CALL hist_addfld1d(fname = \u0027VCMX25T\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027M\u0027, long_name = \u0027canopy profile of vcmax25\u0027, ptr_patch = this % luvcmax25top_patch, set_lake = spval, set_urb = spval)\n      this % lujmax25top_patch(begp : endp) = spval\n      CALL hist_addfld1d(fname = \u0027JMX25T\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027M\u0027, long_name = \u0027canopy profile of jmax\u0027, ptr_patch = this % lujmax25top_patch, set_lake = spval, set_urb = spval)\n      this % lutpu25top_patch(begp : endp) = spval\n      CALL hist_addfld1d(fname = \u0027TPU25T\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027M\u0027, long_name = \u0027canopy profile of tpu\u0027, ptr_patch = this % lutpu25top_patch, set_lake = spval, set_urb = spval)\n    END IF\n    this % fpsn24_patch = spval\n    CALL hist_addfld1d(fname = \u0027FPSN24\u0027, units = \u0027umol CO2/m^2 ground/day\u0027, avgflag = \u0027A\u0027, long_name = \u002724 hour accumulative patch photosynthesis starting from mid-night\u0027, ptr_patch = this % fpsn24_patch, default = \u0027inactive\u0027)\n  END IF\nEND SUBROUTINE InitHistory"}, {"color": "#97c2fc", "id": "hist_addfld2d", "label": "hist_addfld2d", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "endrun", "label": "endrun", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "allocParams", "label": "allocParams", "shape": "dot", "size": 10, "source": "SUBROUTINE allocParams(this)\n  IMPLICIT NONE\n  CLASS(photo_params_type) :: this\n  CHARACTER(LEN = 32) :: subname = \u0027allocParams\u0027\n  ALLOCATE(this % krmax(0 : mxpft))\n  this % krmax(:) = nan\n  ALLOCATE(this % theta_cj(0 : mxpft))\n  this % theta_cj(:) = nan\n  ALLOCATE(this % kmax(0 : mxpft, nvegwcs))\n  this % kmax(:, :) = nan\n  ALLOCATE(this % psi50(0 : mxpft, nvegwcs))\n  this % psi50(:, :) = nan\n  ALLOCATE(this % ck(0 : mxpft, nvegwcs))\n  this % ck(:, :) = nan\n  IF (use_hydrstress .AND. nvegwcs /= 4) THEN\n    CALL endrun(msg = \u0027Error:: the Plant Hydraulics Stress methodology is for the spacA function is hardcoded for nvegwcs==4\u0027 // errMsg(\"./examples/photosynthesis/PhotosynthesisMod.f90\", 769))\n  END IF\nEND SUBROUTINE allocParams"}, {"color": "#97c2fc", "id": "readParams", "label": "readParams", "shape": "dot", "size": 10, "source": "SUBROUTINE readParams(this, ncid)\n  USE ncdio_pio, ONLY: file_desc_t, ncd_io\n  USE paramUtilMod, ONLY: readNcdioScalar\n  IMPLICIT NONE\n  CLASS(photosyns_type) :: this\n  TYPE(file_desc_t), INTENT(INOUT) :: ncid\n  CHARACTER(LEN = 32) :: subname = \u0027readParams\u0027\n  CHARACTER(LEN = 100) :: errCode = \u0027-Error reading in parameters file:\u0027\n  LOGICAL :: readv\n  REAL(KIND = r8) :: temp1d(0 : mxpft)\n  REAL(KIND = r8) :: temp2d(0 : mxpft, nvegwcs)\n  CHARACTER(LEN = 100) :: tString\n  CALL params_inst % allocParams\n  tString = \"krmax\"\n  CALL ncd_io(varname = TRIM(tString), data = temp1d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 825))\n  params_inst % krmax = temp1d\n  tString = \"lmr_intercept_atkin\"\n  CALL ncd_io(varname = TRIM(tString), data = temp1d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 829))\n  params_inst % lmr_intercept_atkin = temp1d\n  tString = \"theta_cj\"\n  CALL ncd_io(varname = TRIM(tString), data = temp1d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 833))\n  params_inst % theta_cj = temp1d\n  tString = \"kmax\"\n  CALL ncd_io(varname = TRIM(tString), data = temp2d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 837))\n  params_inst % kmax = temp2d\n  tString = \"psi50\"\n  CALL ncd_io(varname = TRIM(tString), data = temp2d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 841))\n  params_inst % psi50 = temp2d\n  tString = \"ck\"\n  CALL ncd_io(varname = TRIM(tString), data = temp2d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 845))\n  params_inst % ck = temp2d\n  CALL readNcdioScalar(ncid, \u0027ko25_coef\u0027, subname, params_inst % ko25_coef)\n  CALL readNcdioScalar(ncid, \u0027kc25_coef\u0027, subname, params_inst % kc25_coef)\n  CALL readNcdioScalar(ncid, \u0027cp25_yr2000\u0027, subname, params_inst % cp25_yr2000)\n  CALL readNcdioScalar(ncid, \u0027act25\u0027, subname, params_inst % act25)\n  CALL readNcdioScalar(ncid, \u0027fnr\u0027, subname, params_inst % fnr)\n  CALL readNcdioScalar(ncid, \u0027fnps\u0027, subname, params_inst % fnps)\n  CALL readNcdioScalar(ncid, \u0027theta_psii\u0027, subname, params_inst % theta_psii)\n  CALL readNcdioScalar(ncid, \u0027theta_ip\u0027, subname, params_inst % theta_ip)\n  CALL readNcdioScalar(ncid, \u0027vcmaxha\u0027, subname, params_inst % vcmaxha)\n  CALL readNcdioScalar(ncid, \u0027jmaxha\u0027, subname, params_inst % jmaxha)\n  CALL readNcdioScalar(ncid, \u0027tpuha\u0027, subname, params_inst % tpuha)\n  CALL readNcdioScalar(ncid, \u0027lmrha\u0027, subname, params_inst % lmrha)\n  CALL readNcdioScalar(ncid, \u0027kcha\u0027, subname, params_inst % kcha)\n  CALL readNcdioScalar(ncid, \u0027koha\u0027, subname, params_inst % koha)\n  CALL readNcdioScalar(ncid, \u0027cpha\u0027, subname, params_inst % cpha)\n  CALL readNcdioScalar(ncid, \u0027vcmaxhd\u0027, subname, params_inst % vcmaxhd)\n  CALL readNcdioScalar(ncid, \u0027jmaxhd\u0027, subname, params_inst % jmaxhd)\n  CALL readNcdioScalar(ncid, \u0027tpuhd\u0027, subname, params_inst % tpuhd)\n  CALL readNcdioScalar(ncid, \u0027lmrhd\u0027, subname, params_inst % lmrhd)\n  CALL readNcdioScalar(ncid, \u0027lmrse\u0027, subname, params_inst % lmrse)\n  CALL readNcdioScalar(ncid, \u0027tpu25ratio\u0027, subname, params_inst % tpu25ratio)\n  CALL readNcdioScalar(ncid, \u0027kp25ratio\u0027, subname, params_inst % kp25ratio)\n  CALL readNcdioScalar(ncid, \u0027vcmaxse_sf\u0027, subname, params_inst % vcmaxse_sf)\n  CALL readNcdioScalar(ncid, \u0027jmaxse_sf\u0027, subname, params_inst % jmaxse_sf)\n  CALL readNcdioScalar(ncid, \u0027tpuse_sf\u0027, subname, params_inst % tpuse_sf)\n  CALL readNcdioScalar(ncid, \u0027jmax25top_sf\u0027, subname, params_inst % jmax25top_sf)\nEND SUBROUTINE readParams"}, {"color": "#97c2fc", "id": "ReadNML", "label": "ReadNML", "shape": "dot", "size": 10, "source": "SUBROUTINE ReadNML(this, NLFilename)\n  USE fileutils, ONLY: getavu, relavu, opnfil\n  USE shr_nl_mod, ONLY: shr_nl_find_group_name\n  USE spmdMod, ONLY: masterproc, mpicom\n  USE shr_mpi_mod, ONLY: shr_mpi_bcast\n  USE clm_varctl, ONLY: iulog\n  CLASS(photosyns_type) :: this\n  CHARACTER(LEN = *), INTENT(IN) :: NLFilename\n  INTEGER :: ierr\n  INTEGER :: unitn\n  CHARACTER(LEN = *), PARAMETER :: subname = \u0027Photosyn::ReadNML\u0027\n  CHARACTER(LEN = *), PARAMETER :: nmlname = \u0027photosyns_inparm\u0027\n  LOGICAL :: rootstem_acc = .FALSE.\n  LOGICAL :: light_inhibit = .FALSE.\n  INTEGER :: leafresp_method = leafresp_mtd_ryan1991\n  LOGICAL :: modifyphoto_and_lmr_forcrop = .FALSE.\n  CHARACTER(LEN = 50) :: stomatalcond_method = \u0027Ball-Berry1987\u0027\n  NAMELIST /photosyns_inparm/ leafresp_method, light_inhibit, rootstem_acc, stomatalcond_method, modifyphoto_and_lmr_forcrop\n  IF (masterproc) THEN\n    unitn = getavu()\n    WRITE(iulog, *) \u0027Read in \u0027 // nmlname // \u0027  namelist\u0027\n    CALL opnfil(NLFilename, unitn, \u0027F\u0027)\n    CALL shr_nl_find_group_name(unitn, nmlname, status = ierr)\n    IF (ierr == 0) THEN\n      READ(unitn, NML = photosyns_inparm, IOSTAT = ierr)\n      IF (ierr /= 0) THEN\n        CALL endrun(msg = \"ERROR reading \" // nmlname // \"namelist\" // errmsg(sourcefile, 971))\n      END IF\n    ELSE\n      CALL endrun(msg = \"ERROR could NOT find \" // nmlname // \"namelist\" // errmsg(sourcefile, 974))\n    END IF\n    CALL relavu(unitn)\n    this % rootstem_acc = rootstem_acc\n    this % leafresp_method = leafresp_method\n    this % light_inhibit = light_inhibit\n    this % modifyphoto_and_lmr_forcrop = modifyphoto_and_lmr_forcrop\n    IF (TRIM(stomatalcond_method) == \u0027Ball-Berry1987\u0027) THEN\n      this % stomatalcond_mtd = stomatalcond_mtd_bb1987\n    ELSE IF (TRIM(stomatalcond_method) == \u0027Medlyn2011\u0027) THEN\n      this % stomatalcond_mtd = stomatalcond_mtd_medlyn2011\n    ELSE\n      CALL endrun(msg = \"ERROR bad value for stomtalcond_method in \" // nmlname // \"namelist\" // errmsg(sourcefile, 986))\n    END IF\n  END IF\n  CALL shr_mpi_bcast(this % rootstem_acc, mpicom)\n  CALL shr_mpi_bcast(this % leafresp_method, mpicom)\n  CALL shr_mpi_bcast(this % light_inhibit, mpicom)\n  CALL shr_mpi_bcast(this % stomatalcond_mtd, mpicom)\n  CALL shr_mpi_bcast(this % modifyphoto_and_lmr_forcrop, mpicom)\n  IF (masterproc) THEN\n    WRITE(iulog, *) \u0027 \u0027\n    WRITE(iulog, *) nmlname // \u0027 settings:\u0027\n    WRITE(iulog, NML = photosyns_inparm)\n    WRITE(iulog, *) \u0027 \u0027\n  END IF\nEND SUBROUTINE ReadNML"}, {"color": "#97c2fc", "id": "Photosynthesis", "label": "Photosynthesis", "shape": "dot", "size": 10, "source": "SUBROUTINE Photosynthesis(bounds, fn, filterp, esat_tv, eair, oair, cair, rb, btran, dayl_factor, leafn, atm2lnd_inst, temperature_inst, surfalb_inst, solarabs_inst, canopystate_inst, ozone_inst, photosyns_inst, phase)\n  USE clm_varcon, ONLY: rgas, tfrz, spval\n  USE GridcellType, ONLY: grc\n  USE clm_time_manager, ONLY: get_step_size_real, is_near_local_noon\n  USE clm_varctl, ONLY: cnallocate_carbon_only\n  USE clm_varctl, ONLY: lnc_opt, reduce_dayl_factor, vcmax_opt\n  USE pftconMod, ONLY: nbrdlf_dcd_tmp_shrub, npcropmin\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER, INTENT(IN) :: fn\n  INTEGER, INTENT(IN) :: filterp(fn)\n  REAL(KIND = r8), INTENT(IN) :: esat_tv(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: eair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: oair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: cair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: rb(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: btran(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: dayl_factor(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: leafn(bounds % begp :)\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  TYPE(surfalb_type), INTENT(IN) :: surfalb_inst\n  TYPE(solarabs_type), INTENT(IN) :: solarabs_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  CLASS(ozone_base_type), INTENT(IN) :: ozone_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  CHARACTER(LEN = *), INTENT(IN) :: phase\n  REAL(KIND = r8) :: jmax_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: bbbopt(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: kn(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: vcmax25top\n  REAL(KIND = r8) :: jmax25top\n  REAL(KIND = r8) :: tpu25top\n  REAL(KIND = r8) :: lmr25top\n  REAL(KIND = r8) :: kp25top\n  REAL(KIND = r8) :: vcmax25\n  REAL(KIND = r8) :: jmax25\n  REAL(KIND = r8) :: tpu25\n  REAL(KIND = r8) :: lmr25\n  REAL(KIND = r8) :: kp25\n  REAL(KIND = r8) :: kc25\n  REAL(KIND = r8) :: ko25\n  REAL(KIND = r8) :: cp25\n  REAL(KIND = r8) :: vcmaxse\n  REAL(KIND = r8) :: jmaxse\n  REAL(KIND = r8) :: tpuse\n  REAL(KIND = r8) :: vcmaxc\n  REAL(KIND = r8) :: jmaxc\n  REAL(KIND = r8) :: tpuc\n  REAL(KIND = r8) :: lmrc\n  INTEGER :: f, p, c, iv\n  REAL(KIND = r8) :: cf\n  REAL(KIND = r8) :: rsmax0\n  REAL(KIND = r8) :: gb\n  REAL(KIND = r8) :: cs\n  REAL(KIND = r8) :: gs\n  REAL(KIND = r8) :: hs\n  REAL(KIND = r8) :: sco\n  REAL(KIND = r8) :: ft\n  REAL(KIND = r8) :: fth\n  REAL(KIND = r8) :: fth25\n  REAL(KIND = r8) :: tl\n  REAL(KIND = r8) :: ha\n  REAL(KIND = r8) :: hd\n  REAL(KIND = r8) :: se\n  REAL(KIND = r8) :: scaleFactor\n  REAL(KIND = r8) :: ciold\n  REAL(KIND = r8) :: gs_mol_err\n  REAL(KIND = r8) :: je\n  REAL(KIND = r8) :: qabs\n  REAL(KIND = r8) :: aquad, bquad, cquad\n  REAL(KIND = r8) :: r1, r2\n  REAL(KIND = r8) :: ceair\n  INTEGER :: niter\n  REAL(KIND = r8) :: nscaler\n  REAL(KIND = r8) :: ai\n  REAL(KIND = r8) :: psn_wc_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wj_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wp_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psncan\n  REAL(KIND = r8) :: psncan_wc\n  REAL(KIND = r8) :: psncan_wj\n  REAL(KIND = r8) :: psncan_wp\n  REAL(KIND = r8) :: lmrcan\n  REAL(KIND = r8) :: gscan\n  REAL(KIND = r8) :: laican\n  REAL(KIND = r8) :: rh_can\n  REAL(KIND = r8), POINTER :: lai_z(:, :)\n  REAL(KIND = r8), POINTER :: par_z(:, :)\n  REAL(KIND = r8), POINTER :: vcmaxcint(:)\n  REAL(KIND = r8), POINTER :: alphapsn(:)\n  REAL(KIND = r8), POINTER :: psn(:)\n  REAL(KIND = r8), POINTER :: psn_wc(:)\n  REAL(KIND = r8), POINTER :: psn_wj(:)\n  REAL(KIND = r8), POINTER :: psn_wp(:)\n  REAL(KIND = r8), POINTER :: psn_z(:, :)\n  REAL(KIND = r8), POINTER :: lmr(:)\n  REAL(KIND = r8), POINTER :: lmr_z(:, :)\n  REAL(KIND = r8), POINTER :: rs(:)\n  REAL(KIND = r8), POINTER :: rs_z(:, :)\n  REAL(KIND = r8), POINTER :: ci_z(:, :)\n  REAL(KIND = r8), POINTER :: o3coefv(:)\n  REAL(KIND = r8), POINTER :: o3coefg(:)\n  REAL(KIND = r8), POINTER :: alphapsnsun(:)\n  REAL(KIND = r8), POINTER :: alphapsnsha(:)\n  REAL(KIND = r8) :: sum_nscaler\n  REAL(KIND = r8) :: total_lai\n  INTEGER :: nptreemax\n  REAL(KIND = r8) :: dtime\n  INTEGER :: g\n  ft(tl, ha) = EXP(ha / (rgas * 1.E-3_r8 * (tfrz + 25._r8)) * (1._r8 - (tfrz + 25._r8) / tl))\n  fth(tl, hd, se, scaleFactor) = scaleFactor / (1._r8 + EXP((- hd + se * tl) / (rgas * 1.E-3_r8 * tl)))\n  fth25(hd, se) = 1._r8 + EXP((- hd + se * (tfrz + 25._r8)) / (rgas * 1.E-3_r8 * (tfrz + 25._r8)))\n  CALL shr_assert_all((UBOUND(esat_tv) == (/bounds % endp/)), file = sourcefile, line = 1369)\n  CALL shr_assert_all((UBOUND(eair) == (/bounds % endp/)), file = sourcefile, line = 1370)\n  CALL shr_assert_all((UBOUND(oair) == (/bounds % endp/)), file = sourcefile, line = 1371)\n  CALL shr_assert_all((UBOUND(cair) == (/bounds % endp/)), file = sourcefile, line = 1372)\n  CALL shr_assert_all((UBOUND(rb) == (/bounds % endp/)), file = sourcefile, line = 1373)\n  CALL shr_assert_all((UBOUND(btran) == (/bounds % endp/)), file = sourcefile, line = 1374)\n  CALL shr_assert_all((UBOUND(dayl_factor) == (/bounds % endp/)), file = sourcefile, line = 1375)\n  CALL shr_assert_all((UBOUND(leafn) == (/bounds % endp/)), file = sourcefile, line = 1376)\n  ASSOCIATE(c3psn =\u003e pftcon % c3psn, crop =\u003e pftcon % crop, leafcn =\u003e pftcon % leafcn, flnr =\u003e pftcon % flnr, fnitr =\u003e pftcon % fnitr, slatop =\u003e pftcon % slatop, dsladlai =\u003e pftcon % dsladlai, i_vcad =\u003e pftcon % i_vcad, s_vcad =\u003e pftcon % s_vcad, i_flnr =\u003e pftcon % i_flnr, s_flnr =\u003e pftcon % s_flnr, mbbopt =\u003e pftcon % mbbopt, ivt =\u003e patch % itype, forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, t_veg =\u003e temperature_inst % t_veg_patch, t10 =\u003e temperature_inst % t_a10_patch, tgcm =\u003e temperature_inst % thm_patch, nrad =\u003e surfalb_inst % nrad_patch, tlai_z =\u003e surfalb_inst % tlai_z_patch, tlai =\u003e canopystate_inst % tlai_patch, c3flag =\u003e photosyns_inst % c3flag_patch, ac =\u003e photosyns_inst % ac_patch, aj =\u003e photosyns_inst % aj_patch, ap =\u003e photosyns_inst % ap_patch, ag =\u003e photosyns_inst % ag_patch, an =\u003e photosyns_inst % an_patch, gb_mol =\u003e photosyns_inst % gb_mol_patch, gs_mol =\u003e photosyns_inst % gs_mol_patch, gs_mol_sun_ln =\u003e photosyns_inst % gs_mol_sun_ln_patch, gs_mol_sha_ln =\u003e photosyns_inst % gs_mol_sha_ln_patch, gs_mol_sun =\u003e photosyns_inst % gs_mol_sun_patch, gs_mol_sha =\u003e photosyns_inst % gs_mol_sha_patch, vcmax_z =\u003e photosyns_inst % vcmax_z_patch, cp =\u003e photosyns_inst % cp_patch, kc =\u003e photosyns_inst % kc_patch, ko =\u003e photosyns_inst % ko_patch, qe =\u003e photosyns_inst % qe_patch, tpu_z =\u003e photosyns_inst % tpu_z_patch, kp_z =\u003e photosyns_inst % kp_z_patch, bbb =\u003e photosyns_inst % bbb_patch, mbb =\u003e photosyns_inst % mbb_patch, rh_leaf =\u003e photosyns_inst % rh_leaf_patch, vpd_can =\u003e photosyns_inst % vpd_can_patch, lnc =\u003e photosyns_inst % lnca_patch, light_inhibit =\u003e photosyns_inst % light_inhibit, leafresp_method =\u003e photosyns_inst % leafresp_method, medlynintercept =\u003e pftcon % medlynintercept, stomatalcond_mtd =\u003e photosyns_inst % stomatalcond_mtd, leaf_mr_vcm =\u003e canopystate_inst % leaf_mr_vcm)\n    IF (phase == \u0027sun\u0027) THEN\n      par_z =\u003e solarabs_inst % parsun_z_patch\n      lai_z =\u003e canopystate_inst % laisun_z_patch\n      vcmaxcint =\u003e surfalb_inst % vcmaxcintsun_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsun_patch\n      o3coefv =\u003e ozone_inst % o3coefvsun_patch\n      o3coefg =\u003e ozone_inst % o3coefgsun_patch\n      ci_z =\u003e photosyns_inst % cisun_z_patch\n      rs =\u003e photosyns_inst % rssun_patch\n      rs_z =\u003e photosyns_inst % rssun_z_patch\n      lmr =\u003e photosyns_inst % lmrsun_patch\n      lmr_z =\u003e photosyns_inst % lmrsun_z_patch\n      psn =\u003e photosyns_inst % psnsun_patch\n      psn_z =\u003e photosyns_inst % psnsun_z_patch\n      psn_wc =\u003e photosyns_inst % psnsun_wc_patch\n      psn_wj =\u003e photosyns_inst % psnsun_wj_patch\n      psn_wp =\u003e photosyns_inst % psnsun_wp_patch\n    ELSE IF (phase == \u0027sha\u0027) THEN\n      par_z =\u003e solarabs_inst % parsha_z_patch\n      lai_z =\u003e canopystate_inst % laisha_z_patch\n      vcmaxcint =\u003e surfalb_inst % vcmaxcintsha_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsha_patch\n      o3coefv =\u003e ozone_inst % o3coefvsha_patch\n      o3coefg =\u003e ozone_inst % o3coefgsha_patch\n      ci_z =\u003e photosyns_inst % cisha_z_patch\n      rs =\u003e photosyns_inst % rssha_patch\n      rs_z =\u003e photosyns_inst % rssha_z_patch\n      lmr =\u003e photosyns_inst % lmrsha_patch\n      lmr_z =\u003e photosyns_inst % lmrsha_z_patch\n      psn =\u003e photosyns_inst % psnsha_patch\n      psn_z =\u003e photosyns_inst % psnsha_z_patch\n      psn_wc =\u003e photosyns_inst % psnsha_wc_patch\n      psn_wj =\u003e photosyns_inst % psnsha_wj_patch\n      psn_wp =\u003e photosyns_inst % psnsha_wp_patch\n    END IF\n    dtime = get_step_size_real()\n    lmrc = fth25(params_inst % lmrhd, params_inst % lmrse)\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      IF (NINT(c3psn(patch % itype(p))) == 1) THEN\n        c3flag(p) = .TRUE.\n      ELSE IF (NINT(c3psn(patch % itype(p))) == 0) THEN\n        c3flag(p) = .FALSE.\n      END IF\n      IF (c3flag(p)) THEN\n        qe(p) = 0._r8\n        IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) bbbopt(p) = bbbopt_c3\n      ELSE\n        qe(p) = 0.05_r8\n        IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) bbbopt(p) = bbbopt_c4\n      END IF\n      IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n        bbb(p) = MAX(bbbopt(p) * btran(p), 1._r8)\n        mbb(p) = mbbopt(patch % itype(p))\n      END IF\n      kc25 = params_inst % kc25_coef * forc_pbot(c)\n      ko25 = params_inst % ko25_coef * forc_pbot(c)\n      sco = 0.5_r8 * 0.209_r8 / params_inst % cp25_yr2000\n      cp25 = 0.5_r8 * oair(p) / sco\n      kc(p) = kc25 * ft(t_veg(p), params_inst % kcha)\n      ko(p) = ko25 * ft(t_veg(p), params_inst % koha)\n      cp(p) = cp25 * ft(t_veg(p), params_inst % cpha)\n    END DO\n    DO f = 1, fn\n      p = filterp(f)\n      IF (lnc_opt .EQV. .FALSE.) THEN\n        IF ((slatop(patch % itype(p)) * leafcn(patch % itype(p))) .LE. 0.0_r8) THEN\n          CALL endrun(subgrid_index = p, subgrid_level = subgrid_level_patch, msg = \"ERROR: slatop or leafcn is zero\")\n        END IF\n        lnc(p) = 1._r8 / (slatop(patch % itype(p)) * leafcn(patch % itype(p)))\n      END IF\n      IF (lnc_opt .EQV. .TRUE.) THEN\n        sum_nscaler = 0.0_r8\n        laican = 0.0_r8\n        total_lai = 0.0_r8\n        DO iv = 1, nrad(p)\n          IF (iv == 1) THEN\n            laican = 0.5_r8 * tlai_z(p, iv)\n            total_lai = tlai_z(p, iv)\n          ELSE\n            laican = laican + 0.5_r8 * (tlai_z(p, iv - 1) + tlai_z(p, iv))\n            total_lai = total_lai + tlai_z(p, iv)\n          END IF\n          IF (nlevcan == 1) THEN\n            nscaler = 1.0_r8\n          ELSE IF (nlevcan \u003e 1) THEN\n            nscaler = EXP(- kn(p) * laican)\n          END IF\n          sum_nscaler = sum_nscaler + nscaler\n        END DO\n        IF (tlai(p) \u003e 0.0_r8 .AND. sum_nscaler \u003e 0.0_r8) THEN\n          lnc(p) = leafn(p) / (tlai(p) * sum_nscaler)\n        ELSE\n          lnc(p) = 0.0_r8\n        END IF\n      END IF\n      IF (reduce_dayl_factor .EQV. .TRUE.) THEN\n        IF (dayl_factor(p) \u003e 0.25_r8) THEN\n        END IF\n      END IF\n      IF (vcmax_opt == 0) THEN\n        vcmax25top = lnc(p) * flnr(patch % itype(p)) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        IF (.NOT. use_cn) THEN\n          vcmax25top = vcmax25top * fnitr(patch % itype(p))\n        ELSE\n          IF (CNAllocate_Carbon_only()) vcmax25top = vcmax25top * fnitr(patch % itype(p))\n        END IF\n      ELSE IF (vcmax_opt == 3) THEN\n        vcmax25top = (i_vcad(patch % itype(p)) + s_vcad(patch % itype(p)) * lnc(p)) * dayl_factor(p)\n      ELSE IF (vcmax_opt == 4) THEN\n        nptreemax = 9\n        IF (patch % itype(p) \u003e= nptreemax) THEN\n          vcmax25top = lnc(p) * (i_flnr(patch % itype(p)) + s_flnr(patch % itype(p)) * lnc(p)) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        ELSE\n          vcmax25top = lnc(p) * (i_flnr(patch % itype(p)) * EXP(s_flnr(patch % itype(p)) * lnc(p))) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        END IF\n      END IF\n      jmax25top = ((2.59_r8 - 0.035_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * vcmax25top) * params_inst % jmax25top_sf\n      tpu25top = params_inst % tpu25ratio * vcmax25top\n      kp25top = params_inst % kp25ratio * vcmax25top\n      IF (dayl_factor(p) \u003c 1.0E-12_r8) THEN\n        kn(p) = 0._r8\n      ELSE\n        kn(p) = EXP(0.00963_r8 * vcmax25top / dayl_factor(p) - 2.43_r8)\n      END IF\n      IF (use_cn) THEN\n        IF (leafresp_method == leafresp_mtd_ryan1991) THEN\n          lmr25top = 2.525E-6_r8 * (1.5_r8 ** ((25._r8 - 20._r8) / 10._r8))\n          lmr25top = lmr25top * lnc(p) / 12.E-06_r8\n        ELSE IF (leafresp_method == leafresp_mtd_atkin2015) THEN\n          IF (lnc(p) \u003e 0.0_r8) THEN\n            lmr25top = params_inst % lmr_intercept_atkin(ivt(p)) + (lnc(p) * 0.2061_r8) - (0.0402_r8 * (t10(p) - tfrz))\n          ELSE\n            lmr25top = 0.0_r8\n          END IF\n        END IF\n      ELSE\n        IF (c3flag(p)) THEN\n          lmr25top = vcmax25top * leaf_mr_vcm\n        ELSE\n          lmr25top = vcmax25top * 0.025_r8\n        END IF\n      END IF\n      laican = 0._r8\n      DO iv = 1, nrad(p)\n        IF (iv == 1) THEN\n          laican = 0.5_r8 * tlai_z(p, iv)\n        ELSE\n          laican = laican + 0.5_r8 * (tlai_z(p, iv - 1) + tlai_z(p, iv))\n        END IF\n        IF (nlevcan == 1) THEN\n          nscaler = vcmaxcint(p)\n        ELSE IF (nlevcan \u003e 1) THEN\n          nscaler = EXP(- kn(p) * laican)\n        END IF\n        lmr25 = lmr25top * nscaler\n        IF (use_luna .AND. c3flag(p) .AND. crop(patch % itype(p)) == 0) THEN\n          IF (.NOT. use_cn) THEN\n            lmr25 = leaf_mr_vcm * photosyns_inst % vcmx25_z_patch(p, iv)\n          END IF\n        END IF\n        IF (c3flag(p)) THEN\n          lmr_z(p, iv) = lmr25 * ft(t_veg(p), params_inst % lmrha) * fth(t_veg(p), params_inst % lmrhd, params_inst % lmrse, lmrc)\n        ELSE\n          lmr_z(p, iv) = lmr25 * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n          lmr_z(p, iv) = lmr_z(p, iv) / (1._r8 + EXP(1.3_r8 * (t_veg(p) - (tfrz + 55._r8))))\n        END IF\n        IF (par_z(p, iv) \u003c= 0._r8) THEN\n          vcmax_z(p, iv) = 0._r8\n          jmax_z(p, iv) = 0._r8\n          tpu_z(p, iv) = 0._r8\n          kp_z(p, iv) = 0._r8\n          IF (use_c13) THEN\n            alphapsn(p) = 1._r8\n          END IF\n        ELSE\n          IF (use_luna .AND. c3flag(p) .AND. crop(patch % itype(p)) == 0) THEN\n            vcmax25 = photosyns_inst % vcmx25_z_patch(p, iv)\n            jmax25 = photosyns_inst % jmx25_z_patch(p, iv)\n            tpu25 = params_inst % tpu25ratio * vcmax25\n            IF (phase == \u0027sha\u0027 .AND. surfalb_inst % vcmaxcintsun_patch(p) .GT. 0._r8 .AND. nlevcan == 1) THEN\n              vcmax25 = vcmax25 * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n              jmax25 = jmax25 * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n              tpu25 = tpu25 * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n            END IF\n          ELSE\n            vcmax25 = vcmax25top * nscaler\n            jmax25 = jmax25top * nscaler\n            tpu25 = tpu25top * nscaler\n          END IF\n          kp25 = kp25top * nscaler\n          vcmaxse = (668.39_r8 - 1.07_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % vcmaxse_sf\n          jmaxse = (659.70_r8 - 0.75_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % jmaxse_sf\n          tpuse = (668.39_r8 - 1.07_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % tpuse_sf\n          vcmaxc = fth25(params_inst % vcmaxhd, vcmaxse)\n          jmaxc = fth25(params_inst % jmaxhd, jmaxse)\n          tpuc = fth25(params_inst % tpuhd, tpuse)\n          vcmax_z(p, iv) = vcmax25 * ft(t_veg(p), params_inst % vcmaxha) * fth(t_veg(p), params_inst % vcmaxhd, vcmaxse, vcmaxc)\n          jmax_z(p, iv) = jmax25 * ft(t_veg(p), params_inst % jmaxha) * fth(t_veg(p), params_inst % jmaxhd, jmaxse, jmaxc)\n          tpu_z(p, iv) = tpu25 * ft(t_veg(p), params_inst % tpuha) * fth(t_veg(p), params_inst % tpuhd, tpuse, tpuc)\n          IF (.NOT. c3flag(p)) THEN\n            vcmax_z(p, iv) = vcmax25 * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n            vcmax_z(p, iv) = vcmax_z(p, iv) / (1._r8 + EXP(0.2_r8 * ((tfrz + 15._r8) - t_veg(p))))\n            vcmax_z(p, iv) = vcmax_z(p, iv) / (1._r8 + EXP(0.3_r8 * (t_veg(p) - (tfrz + 40._r8))))\n          END IF\n          kp_z(p, iv) = kp25 * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n        END IF\n        vcmax_z(p, iv) = vcmax_z(p, iv) * btran(p)\n        lmr_z(p, iv) = lmr_z(p, iv) * btran(p)\n        IF (light_inhibit .AND. par_z(p, 1) \u003e 0._r8) THEN\n          lmr_z(p, iv) = lmr_z(p, iv) * 0.67_r8\n        END IF\n      END DO\n    END DO\n    rsmax0 = 2.E4_r8\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      g = patch % gridcell(p)\n      cf = forc_pbot(c) / (rgas * 1.E-3_r8 * tgcm(p)) * 1.E06_r8\n      gb = 1._r8 / rb(p)\n      gb_mol(p) = gb * cf\n      DO iv = 1, nrad(p)\n        IF (par_z(p, iv) \u003c= 0._r8) THEN\n          ac(p, iv) = 0._r8\n          aj(p, iv) = 0._r8\n          ap(p, iv) = 0._r8\n          ag(p, iv) = 0._r8\n          an(p, iv) = ag(p, iv) - lmr_z(p, iv)\n          psn_z(p, iv) = 0._r8\n          psn_wc_z(p, iv) = 0._r8\n          psn_wj_z(p, iv) = 0._r8\n          psn_wp_z(p, iv) = 0._r8\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            rs_z(p, iv) = MIN(rsmax0, 1._r8 / bbb(p) * cf)\n          ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n            rs_z(p, iv) = MIN(rsmax0, 1._r8 / medlynintercept(patch % itype(p)) * cf)\n          END IF\n          ci_z(p, iv) = 0._r8\n          rh_leaf(p) = 0._r8\n        ELSE\n          ceair = MIN(eair(p), esat_tv(p))\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            rh_can = ceair / esat_tv(p)\n          ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n            rh_can = MAX((esat_tv(p) - ceair), medlyn_rh_can_max) * medlyn_rh_can_fact\n            vpd_can(p) = rh_can\n          END IF\n          qabs = 0.5_r8 * (1._r8 - params_inst % fnps) * par_z(p, iv) * 4.6_r8\n          aquad = params_inst % theta_psii\n          bquad = - (qabs + jmax_z(p, iv))\n          cquad = qabs * jmax_z(p, iv)\n          CALL quadratic(aquad, bquad, cquad, r1, r2)\n          je = MIN(r1, r2)\n          IF (c3flag(p)) THEN\n            ci_z(p, iv) = 0.7_r8 * cair(p)\n          ELSE\n            ci_z(p, iv) = 0.4_r8 * cair(p)\n          END IF\n          niter = 0\n          niter = niter + 1\n          ciold = ci_z(p, iv)\n          CALL hybrid(ciold, p, iv, c, gb_mol(p), je, cair(p), oair(p), lmr_z(p, iv), par_z(p, iv), rh_can, gs_mol(p, iv), niter, atm2lnd_inst, photosyns_inst)\n          IF (an(p, iv) \u003c 0._r8) THEN\n            IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n              gs_mol(p, iv) = bbb(p)\n            ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n              gs_mol(p, iv) = medlynintercept(patch % itype(p))\n            END IF\n          END IF\n          IF (phase == \u0027sun\u0027) THEN\n            gs_mol_sun(p, iv) = gs_mol(p, iv)\n          ELSE IF (phase == \u0027sha\u0027) THEN\n            gs_mol_sha(p, iv) = gs_mol(p, iv)\n          END IF\n          IF (is_near_local_noon(grc % londeg(g), deltasec = 3600)) THEN\n            IF (phase == \u0027sun\u0027) THEN\n              gs_mol_sun_ln(p, iv) = gs_mol(p, iv)\n            ELSE IF (phase == \u0027sha\u0027) THEN\n              gs_mol_sha_ln(p, iv) = gs_mol(p, iv)\n            END IF\n          ELSE\n            IF (phase == \u0027sun\u0027) THEN\n              gs_mol_sun_ln(p, iv) = spval\n            ELSE IF (phase == \u0027sha\u0027) THEN\n              gs_mol_sha_ln(p, iv) = spval\n            END IF\n          END IF\n          cs = cair(p) - 1.4_r8 / gb_mol(p) * an(p, iv) * forc_pbot(c)\n          cs = MAX(cs, max_cs)\n          ci_z(p, iv) = cair(p) - an(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol(p, iv) + 1.6_r8 * gb_mol(p)) / (gb_mol(p) * gs_mol(p, iv))\n          ci_z(p, iv) = MAX(ci_z(p, iv), 1.E-06_r8)\n          gs = gs_mol(p, iv) / cf\n          rs_z(p, iv) = MIN(1._r8 / gs, rsmax0)\n          rs_z(p, iv) = rs_z(p, iv) / o3coefg(p)\n          psn_z(p, iv) = ag(p, iv)\n          psn_z(p, iv) = psn_z(p, iv) * o3coefv(p)\n          psn_wc_z(p, iv) = 0._r8\n          psn_wj_z(p, iv) = 0._r8\n          psn_wp_z(p, iv) = 0._r8\n          IF (ac(p, iv) \u003c= aj(p, iv) .AND. ac(p, iv) \u003c= ap(p, iv)) THEN\n            psn_wc_z(p, iv) = psn_z(p, iv)\n          ELSE IF (aj(p, iv) \u003c ac(p, iv) .AND. aj(p, iv) \u003c= ap(p, iv)) THEN\n            psn_wj_z(p, iv) = psn_z(p, iv)\n          ELSE IF (ap(p, iv) \u003c ac(p, iv) .AND. ap(p, iv) \u003c aj(p, iv)) THEN\n            psn_wp_z(p, iv) = psn_z(p, iv)\n          END IF\n          IF (gs_mol(p, iv) \u003c 0._r8) THEN\n            WRITE(iulog, *) \u0027Negative stomatal conductance:\u0027\n            WRITE(iulog, *) \u0027p,iv,gs_mol= \u0027, p, iv, gs_mol(p, iv)\n            CALL endrun(subgrid_index = p, subgrid_level = subgrid_level_patch, msg = errmsg(sourcefile, 1963))\n          END IF\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            hs = (gb_mol(p) * ceair + gs_mol(p, iv) * esat_tv(p)) / ((gb_mol(p) + gs_mol(p, iv)) * esat_tv(p))\n            rh_leaf(p) = hs\n            gs_mol_err = mbb(p) * MAX(an(p, iv), 0._r8) * hs / cs * forc_pbot(c) + bbb(p)\n            IF (ABS(gs_mol(p, iv) - gs_mol_err) \u003e 1.E-01_r8) THEN\n              WRITE(iulog, *) \u0027Ball-Berry error check - stomatal conductance error:\u0027\n              WRITE(iulog, *) gs_mol(p, iv), gs_mol_err\n            END IF\n          END IF\n        END IF\n      END DO\n    END DO\n    DO f = 1, fn\n      p = filterp(f)\n      psncan = 0._r8\n      psncan_wc = 0._r8\n      psncan_wj = 0._r8\n      psncan_wp = 0._r8\n      lmrcan = 0._r8\n      gscan = 0._r8\n      laican = 0._r8\n      DO iv = 1, nrad(p)\n        psncan = psncan + psn_z(p, iv) * lai_z(p, iv)\n        psncan_wc = psncan_wc + psn_wc_z(p, iv) * lai_z(p, iv)\n        psncan_wj = psncan_wj + psn_wj_z(p, iv) * lai_z(p, iv)\n        psncan_wp = psncan_wp + psn_wp_z(p, iv) * lai_z(p, iv)\n        lmrcan = lmrcan + lmr_z(p, iv) * lai_z(p, iv)\n        gscan = gscan + lai_z(p, iv) / (rb(p) + rs_z(p, iv))\n        laican = laican + lai_z(p, iv)\n      END DO\n      IF (laican \u003e 0._r8) THEN\n        psn(p) = psncan / laican\n        psn_wc(p) = psncan_wc / laican\n        psn_wj(p) = psncan_wj / laican\n        psn_wp(p) = psncan_wp / laican\n        lmr(p) = lmrcan / laican\n        rs(p) = laican / gscan - rb(p)\n      ELSE\n        psn(p) = 0._r8\n        psn_wc(p) = 0._r8\n        psn_wj(p) = 0._r8\n        psn_wp(p) = 0._r8\n        lmr(p) = 0._r8\n        rs(p) = 0._r8\n      END IF\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE Photosynthesis"}, {"color": "#97c2fc", "id": "brent", "label": "brent", "shape": "dot", "size": 10, "source": "SUBROUTINE brent(x, x1, x2, f1, f2, tol, ip, iv, ic, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  REAL(KIND = r8), INTENT(OUT) :: x\n  REAL(KIND = r8), INTENT(IN) :: x1, x2, f1, f2\n  REAL(KIND = r8), INTENT(IN) :: tol\n  REAL(KIND = r8), INTENT(IN) :: lmr_z\n  REAL(KIND = r8), INTENT(IN) :: par_z\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: je\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  INTEGER, INTENT(IN) :: ip, iv, ic\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  INTEGER, PARAMETER :: itmax = 20\n  REAL(KIND = r8), PARAMETER :: eps = 1.E-2_r8\n  INTEGER :: iter\n  REAL(KIND = r8) :: a, b, c, d, e, fa, fb, fc, p, q, r, s, tol1, xm\n  a = x1\n  b = x2\n  fa = f1\n  fb = f2\n  IF ((fa \u003e 0._r8 .AND. fb \u003e 0._r8) .OR. (fa \u003c 0._r8 .AND. fb \u003c 0._r8)) THEN\n    WRITE(iulog, *) \u0027root must be bracketed for brent\u0027\n    CALL endrun(subgrid_index = ip, subgrid_level = subgrid_level_patch, msg = errmsg(sourcefile, 2398))\n  END IF\n  c = b\n  fc = fb\n  iter = 0\n  DO\n    IF (iter == itmax) EXIT\n    iter = iter + 1\n    IF ((fb \u003e 0._r8 .AND. fc \u003e 0._r8) .OR. (fb \u003c 0._r8 .AND. fc \u003c 0._r8)) THEN\n      c = a\n      fc = fa\n      d = b - a\n      e = d\n    END IF\n    IF (ABS(fc) \u003c ABS(fb)) THEN\n      a = b\n      b = c\n      c = a\n      fa = fb\n      fb = fc\n      fc = fa\n    END IF\n    tol1 = 2._r8 * eps * ABS(b) + 0.5_r8 * tol\n    xm = 0.5_r8 * (c - b)\n    IF (ABS(xm) \u003c= tol1 .OR. fb == 0.) THEN\n      x = b\n      RETURN\n    END IF\n    IF (ABS(e) \u003e= tol1 .AND. ABS(fa) \u003e ABS(fb)) THEN\n      s = fb / fa\n      IF (a == c) THEN\n        p = 2._r8 * xm * s\n        q = 1._r8 - s\n      ELSE\n        q = fa / fc\n        r = fb / fc\n        p = s * (2._r8 * xm * q * (q - r) - (b - a) * (r - 1._r8))\n        q = (q - 1._r8) * (r - 1._r8) * (s - 1._r8)\n      END IF\n      IF (p \u003e 0._r8) q = - q\n      p = ABS(p)\n      IF (2._r8 * p \u003c MIN(3._r8 * xm * q - ABS(tol1 * q), ABS(e * q))) THEN\n        e = d\n        d = p / q\n      ELSE\n        d = xm\n        e = d\n      END IF\n    ELSE\n      d = xm\n      e = d\n    END IF\n    a = b\n    fa = fb\n    IF (ABS(d) \u003e tol1) THEN\n      b = b + d\n    ELSE\n      b = b + SIGN(tol1, xm)\n    END IF\n    CALL ci_func(b, fb, ip, iv, ic, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n    IF (fb == 0._r8) EXIT\n  END DO\n  IF (iter == itmax) WRITE(iulog, *) \u0027brent exceeding maximum iterations\u0027, b, fb\n  x = b\n  RETURN\nEND SUBROUTINE brent"}, {"color": "#97c2fc", "id": "PhotosynthesisHydraulicStress", "label": "PhotosynthesisHydraulicStress", "shape": "dot", "size": 10, "source": "SUBROUTINE PhotosynthesisHydraulicStress(bounds, fn, filterp, esat_tv, eair, oair, cair, rb, bsun, bsha, btran, dayl_factor, leafn, qsatl, qaf, atm2lnd_inst, temperature_inst, soilstate_inst, waterdiagnosticbulk_inst, surfalb_inst, solarabs_inst, canopystate_inst, ozone_inst, photosyns_inst, waterfluxbulk_inst, froot_carbon, croot_carbon)\n  USE clm_varcon, ONLY: rgas, tfrz, rpi, spval\n  USE GridcellType, ONLY: grc\n  USE clm_time_manager, ONLY: get_step_size_real, is_near_local_noon\n  USE clm_varctl, ONLY: cnallocate_carbon_only\n  USE clm_varctl, ONLY: lnc_opt, reduce_dayl_factor, vcmax_opt\n  USE clm_varpar, ONLY: nlevsoi\n  USE pftconMod, ONLY: nbrdlf_dcd_tmp_shrub, npcropmin\n  USE ColumnType, ONLY: col\n  USE shr_infnan_mod, ONLY: shr_infnan_isnan\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER, INTENT(IN) :: fn\n  INTEGER, INTENT(IN) :: filterp(fn)\n  REAL(KIND = r8), INTENT(IN) :: esat_tv(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: eair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: oair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: cair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: rb(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: dayl_factor(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: qsatl(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: qaf(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: leafn(bounds % begp :)\n  REAL(KIND = r8), INTENT(OUT) :: bsun(bounds % begp :)\n  REAL(KIND = r8), INTENT(OUT) :: bsha(bounds % begp :)\n  REAL(KIND = r8), INTENT(OUT) :: btran(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: froot_carbon(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: croot_carbon(bounds % begp :)\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  TYPE(surfalb_type), INTENT(IN) :: surfalb_inst\n  TYPE(solarabs_type), INTENT(IN) :: solarabs_inst\n  TYPE(canopystate_type), INTENT(INOUT) :: canopystate_inst\n  TYPE(waterdiagnosticbulk_type), INTENT(INOUT) :: waterdiagnosticbulk_inst\n  TYPE(waterfluxbulk_type), INTENT(INOUT) :: waterfluxbulk_inst\n  TYPE(soilstate_type), INTENT(INOUT) :: soilstate_inst\n  CLASS(ozone_base_type), INTENT(IN) :: ozone_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  REAL(KIND = r8) :: jmax_z(bounds % begp : bounds % endp, 2, nlevcan)\n  REAL(KIND = r8) :: bbbopt(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: kn(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: vcmax25top\n  REAL(KIND = r8) :: jmax25top\n  REAL(KIND = r8) :: tpu25top\n  REAL(KIND = r8) :: lmr25top\n  REAL(KIND = r8) :: kp25top\n  REAL(KIND = r8) :: vcmax25_sun\n  REAL(KIND = r8) :: vcmax25_sha\n  REAL(KIND = r8) :: jmax25_sun\n  REAL(KIND = r8) :: jmax25_sha\n  REAL(KIND = r8) :: tpu25_sun\n  REAL(KIND = r8) :: tpu25_sha\n  REAL(KIND = r8) :: lmr25_sun\n  REAL(KIND = r8) :: lmr25_sha\n  REAL(KIND = r8) :: kp25_sun\n  REAL(KIND = r8) :: kp25_sha\n  REAL(KIND = r8) :: kc25\n  REAL(KIND = r8) :: ko25\n  REAL(KIND = r8) :: cp25\n  REAL(KIND = r8) :: vcmaxse\n  REAL(KIND = r8) :: jmaxse\n  REAL(KIND = r8) :: tpuse\n  REAL(KIND = r8) :: vcmaxc\n  REAL(KIND = r8) :: jmaxc\n  REAL(KIND = r8) :: tpuc\n  REAL(KIND = r8) :: lmrc\n  INTEGER :: f, p, c, iv\n  REAL(KIND = r8) :: cf\n  REAL(KIND = r8) :: rsmax0\n  REAL(KIND = r8) :: gb\n  REAL(KIND = r8) :: cs_sun\n  REAL(KIND = r8) :: cs_sha\n  REAL(KIND = r8) :: gs\n  REAL(KIND = r8) :: hs\n  REAL(KIND = r8) :: sco\n  REAL(KIND = r8) :: ft\n  REAL(KIND = r8) :: fth\n  REAL(KIND = r8) :: fth25\n  REAL(KIND = r8) :: tl\n  REAL(KIND = r8) :: ha\n  REAL(KIND = r8) :: hd\n  REAL(KIND = r8) :: se\n  REAL(KIND = r8) :: scaleFactor\n  REAL(KIND = r8) :: ciold\n  REAL(KIND = r8) :: gs_mol_err\n  REAL(KIND = r8) :: je_sun\n  REAL(KIND = r8) :: je_sha\n  REAL(KIND = r8) :: qabs\n  REAL(KIND = r8) :: aquad, bquad, cquad\n  REAL(KIND = r8) :: r1, r2\n  REAL(KIND = r8) :: ceair\n  INTEGER :: iter1\n  INTEGER :: iter2\n  REAL(KIND = r8) :: nscaler\n  REAL(KIND = r8) :: nscaler_sun\n  REAL(KIND = r8) :: nscaler_sha\n  REAL(KIND = r8) :: ai\n  REAL(KIND = r8) :: psn_wc_z_sun(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wj_z_sun(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wp_z_sun(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wc_z_sha(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wj_z_sha(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wp_z_sha(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: rh_leaf_sun(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: rh_leaf_sha(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: psncan_sun\n  REAL(KIND = r8) :: psncan_wc_sun\n  REAL(KIND = r8) :: psncan_wj_sun\n  REAL(KIND = r8) :: psncan_wp_sun\n  REAL(KIND = r8) :: lmrcan_sun\n  REAL(KIND = r8) :: gscan_sun\n  REAL(KIND = r8) :: laican_sun\n  REAL(KIND = r8) :: psncan_sha\n  REAL(KIND = r8) :: psncan_wc_sha\n  REAL(KIND = r8) :: psncan_wj_sha\n  REAL(KIND = r8) :: psncan_wp_sha\n  REAL(KIND = r8) :: lmrcan_sha\n  REAL(KIND = r8) :: gscan_sha\n  REAL(KIND = r8) :: laican_sha\n  REAL(KIND = r8) :: laican\n  REAL(KIND = r8) :: rh_can\n  REAL(KIND = r8), POINTER :: lai_z_sun(:, :)\n  REAL(KIND = r8), POINTER :: par_z_sun(:, :)\n  REAL(KIND = r8), POINTER :: vcmaxcint_sun(:)\n  REAL(KIND = r8), POINTER :: alphapsn_sun(:)\n  REAL(KIND = r8), POINTER :: psn_sun(:)\n  REAL(KIND = r8), POINTER :: psn_wc_sun(:)\n  REAL(KIND = r8), POINTER :: psn_wj_sun(:)\n  REAL(KIND = r8), POINTER :: psn_wp_sun(:)\n  REAL(KIND = r8), POINTER :: psn_z_sun(:, :)\n  REAL(KIND = r8), POINTER :: lmr_sun(:)\n  REAL(KIND = r8), POINTER :: lmr_z_sun(:, :)\n  REAL(KIND = r8), POINTER :: rs_sun(:)\n  REAL(KIND = r8), POINTER :: rs_z_sun(:, :)\n  REAL(KIND = r8), POINTER :: ci_z_sun(:, :)\n  REAL(KIND = r8), POINTER :: o3coefv_sun(:)\n  REAL(KIND = r8), POINTER :: o3coefg_sun(:)\n  REAL(KIND = r8), POINTER :: lai_z_sha(:, :)\n  REAL(KIND = r8), POINTER :: par_z_sha(:, :)\n  REAL(KIND = r8), POINTER :: vcmaxcint_sha(:)\n  REAL(KIND = r8), POINTER :: alphapsn_sha(:)\n  REAL(KIND = r8), POINTER :: psn_sha(:)\n  REAL(KIND = r8), POINTER :: psn_wc_sha(:)\n  REAL(KIND = r8), POINTER :: psn_wj_sha(:)\n  REAL(KIND = r8), POINTER :: psn_wp_sha(:)\n  REAL(KIND = r8), POINTER :: psn_z_sha(:, :)\n  REAL(KIND = r8), POINTER :: lmr_sha(:)\n  REAL(KIND = r8), POINTER :: lmr_z_sha(:, :)\n  REAL(KIND = r8), POINTER :: rs_sha(:)\n  REAL(KIND = r8), POINTER :: rs_z_sha(:, :)\n  REAL(KIND = r8), POINTER :: ci_z_sha(:, :)\n  REAL(KIND = r8), POINTER :: o3coefv_sha(:)\n  REAL(KIND = r8), POINTER :: o3coefg_sha(:)\n  REAL(KIND = r8) :: sum_nscaler\n  REAL(KIND = r8) :: total_lai\n  INTEGER :: nptreemax\n  REAL(KIND = r8) :: dtime\n  INTEGER :: j, g\n  REAL(KIND = r8) :: rs_resis\n  REAL(KIND = r8) :: r_soil\n  REAL(KIND = r8) :: root_biomass_density\n  REAL(KIND = r8) :: root_cross_sec_area\n  REAL(KIND = r8) :: root_length_density\n  REAL(KIND = r8) :: froot_average_length\n  REAL(KIND = r8) :: croot_average_length\n  REAL(KIND = r8) :: soil_conductance\n  REAL(KIND = r8) :: root_conductance\n  REAL(KIND = r8) :: rai(nlevsoi)\n  REAL(KIND = r8) :: fs(nlevsoi)\n  REAL(KIND = r8) :: gsminsun\n  REAL(KIND = r8) :: gsminsha\n  REAL(KIND = r8) :: gs_slope_sun\n  REAL(KIND = r8) :: gs_slope_sha\n  REAL(KIND = r8), PARAMETER :: croot_lateral_length = 0.25_r8\n  REAL(KIND = r8), PARAMETER :: c_to_b = 2.0_r8\n  ft(tl, ha) = EXP(ha / (rgas * 1.E-3_r8 * (tfrz + 25._r8)) * (1._r8 - (tfrz + 25._r8) / tl))\n  fth(tl, hd, se, scaleFactor) = scaleFactor / (1._r8 + EXP((- hd + se * tl) / (rgas * 1.E-3_r8 * tl)))\n  fth25(hd, se) = 1._r8 + EXP((- hd + se * (tfrz + 25._r8)) / (rgas * 1.E-3_r8 * (tfrz + 25._r8)))\n  CALL shr_assert_all((UBOUND(esat_tv) == (/bounds % endp/)), file = sourcefile, line = 2903)\n  CALL shr_assert_all((UBOUND(eair) == (/bounds % endp/)), file = sourcefile, line = 2904)\n  CALL shr_assert_all((UBOUND(oair) == (/bounds % endp/)), file = sourcefile, line = 2905)\n  CALL shr_assert_all((UBOUND(cair) == (/bounds % endp/)), file = sourcefile, line = 2906)\n  CALL shr_assert_all((UBOUND(rb) == (/bounds % endp/)), file = sourcefile, line = 2907)\n  CALL shr_assert_all((UBOUND(bsun) == (/bounds % endp/)), file = sourcefile, line = 2908)\n  CALL shr_assert_all((UBOUND(bsha) == (/bounds % endp/)), file = sourcefile, line = 2909)\n  CALL shr_assert_all((UBOUND(btran) == (/bounds % endp/)), file = sourcefile, line = 2910)\n  CALL shr_assert_all((UBOUND(dayl_factor) == (/bounds % endp/)), file = sourcefile, line = 2911)\n  CALL shr_assert_all((UBOUND(qsatl) == (/bounds % endp/)), file = sourcefile, line = 2912)\n  CALL shr_assert_all((UBOUND(qaf) == (/bounds % endp/)), file = sourcefile, line = 2913)\n  ASSOCIATE(k_soil_root =\u003e soilstate_inst % k_soil_root_patch, hk_l =\u003e soilstate_inst % hk_l_col, hksat =\u003e soilstate_inst % hksat_col, smp =\u003e soilstate_inst % smp_l_col, froot_leaf =\u003e pftcon % froot_leaf, root_conductance_patch =\u003e soilstate_inst % root_conductance_patch, soil_conductance_patch =\u003e soilstate_inst % soil_conductance_patch, rootfr =\u003e soilstate_inst % rootfr_patch, dz =\u003e col % dz, z =\u003e col % z, root_radius =\u003e pftcon % root_radius, root_density =\u003e pftcon % root_density, tsai =\u003e canopystate_inst % tsai_patch, c3psn =\u003e pftcon % c3psn, crop =\u003e pftcon % crop, leafcn =\u003e pftcon % leafcn, flnr =\u003e pftcon % flnr, fnitr =\u003e pftcon % fnitr, slatop =\u003e pftcon % slatop, dsladlai =\u003e pftcon % dsladlai, i_vcad =\u003e pftcon % i_vcad, s_vcad =\u003e pftcon % s_vcad, i_flnr =\u003e pftcon % i_flnr, s_flnr =\u003e pftcon % s_flnr, mbbopt =\u003e pftcon % mbbopt, medlynintercept =\u003e pftcon % medlynintercept, medlynslope =\u003e pftcon % medlynslope, forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, ivt =\u003e patch % itype, t_veg =\u003e temperature_inst % t_veg_patch, t10 =\u003e temperature_inst % t_a10_patch, tgcm =\u003e temperature_inst % thm_patch, nrad =\u003e surfalb_inst % nrad_patch, tlai_z =\u003e surfalb_inst % tlai_z_patch, tlai =\u003e canopystate_inst % tlai_patch, c3flag =\u003e photosyns_inst % c3flag_patch, ac =\u003e photosyns_inst % ac_phs_patch, aj =\u003e photosyns_inst % aj_phs_patch, ap =\u003e photosyns_inst % ap_phs_patch, ag =\u003e photosyns_inst % ag_phs_patch, vcmax_z =\u003e photosyns_inst % vcmax_z_phs_patch, luvcmax25top =\u003e photosyns_inst % luvcmax25top_patch, lujmax25top =\u003e photosyns_inst % lujmax25top_patch, lutpu25top =\u003e photosyns_inst % lutpu25top_patch, tpu_z =\u003e photosyns_inst % tpu_z_phs_patch, kp_z =\u003e photosyns_inst % kp_z_phs_patch, gb_mol =\u003e photosyns_inst % gb_mol_patch, cp =\u003e photosyns_inst % cp_patch, kc =\u003e photosyns_inst % kc_patch, ko =\u003e photosyns_inst % ko_patch, qe =\u003e photosyns_inst % qe_patch, bbb =\u003e photosyns_inst % bbb_patch, mbb =\u003e photosyns_inst % mbb_patch, rh_leaf =\u003e photosyns_inst % rh_leaf_patch, vpd_can =\u003e photosyns_inst % vpd_can_patch, lnc =\u003e photosyns_inst % lnca_patch, light_inhibit =\u003e photosyns_inst % light_inhibit, leafresp_method =\u003e photosyns_inst % leafresp_method, stomatalcond_mtd =\u003e photosyns_inst % stomatalcond_mtd, modifyphoto_and_lmr_forcrop =\u003e photosyns_inst % modifyphoto_and_lmr_forcrop, leaf_mr_vcm =\u003e canopystate_inst % leaf_mr_vcm, vegwp =\u003e canopystate_inst % vegwp_patch, an_sun =\u003e photosyns_inst % an_sun_patch, an_sha =\u003e photosyns_inst % an_sha_patch, gs_mol_sun =\u003e photosyns_inst % gs_mol_sun_patch, gs_mol_sha =\u003e photosyns_inst % gs_mol_sha_patch, gs_mol_sun_ln =\u003e photosyns_inst % gs_mol_sun_ln_patch, gs_mol_sha_ln =\u003e photosyns_inst % gs_mol_sha_ln_patch)\n    par_z_sun =\u003e solarabs_inst % parsun_z_patch\n    lai_z_sun =\u003e canopystate_inst % laisun_z_patch\n    vcmaxcint_sun =\u003e surfalb_inst % vcmaxcintsun_patch\n    alphapsn_sun =\u003e photosyns_inst % alphapsnsun_patch\n    o3coefv_sun =\u003e ozone_inst % o3coefvsun_patch\n    o3coefg_sun =\u003e ozone_inst % o3coefgsun_patch\n    ci_z_sun =\u003e photosyns_inst % cisun_z_patch\n    rs_sun =\u003e photosyns_inst % rssun_patch\n    rs_z_sun =\u003e photosyns_inst % rssun_z_patch\n    lmr_sun =\u003e photosyns_inst % lmrsun_patch\n    lmr_z_sun =\u003e photosyns_inst % lmrsun_z_patch\n    psn_sun =\u003e photosyns_inst % psnsun_patch\n    psn_z_sun =\u003e photosyns_inst % psnsun_z_patch\n    psn_wc_sun =\u003e photosyns_inst % psnsun_wc_patch\n    psn_wj_sun =\u003e photosyns_inst % psnsun_wj_patch\n    psn_wp_sun =\u003e photosyns_inst % psnsun_wp_patch\n    par_z_sha =\u003e solarabs_inst % parsha_z_patch\n    lai_z_sha =\u003e canopystate_inst % laisha_z_patch\n    vcmaxcint_sha =\u003e surfalb_inst % vcmaxcintsha_patch\n    alphapsn_sha =\u003e photosyns_inst % alphapsnsha_patch\n    o3coefv_sha =\u003e ozone_inst % o3coefvsha_patch\n    o3coefg_sha =\u003e ozone_inst % o3coefgsha_patch\n    ci_z_sha =\u003e photosyns_inst % cisha_z_patch\n    rs_sha =\u003e photosyns_inst % rssha_patch\n    rs_z_sha =\u003e photosyns_inst % rssha_z_patch\n    lmr_sha =\u003e photosyns_inst % lmrsha_patch\n    lmr_z_sha =\u003e photosyns_inst % lmrsha_z_patch\n    psn_sha =\u003e photosyns_inst % psnsha_patch\n    psn_z_sha =\u003e photosyns_inst % psnsha_z_patch\n    psn_wc_sha =\u003e photosyns_inst % psnsha_wc_patch\n    psn_wj_sha =\u003e photosyns_inst % psnsha_wj_patch\n    psn_wp_sha =\u003e photosyns_inst % psnsha_wp_patch\n    dtime = get_step_size_real()\n    lmrc = fth25(params_inst % lmrhd, params_inst % lmrse)\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      DO j = 1, nlevsoi\n        root_biomass_density = c_to_b * froot_carbon(p) * rootfr(p, j) / dz(c, j)\n        root_biomass_density = MAX(c_to_b * 1._r8, root_biomass_density)\n        root_cross_sec_area = rpi * root_radius(ivt(p)) ** 2\n        root_length_density = root_biomass_density / (root_density(ivt(p)) * root_cross_sec_area)\n        rai(j) = (tsai(p) + tlai(p)) * froot_leaf(ivt(p)) * rootfr(p, j)\n        croot_average_length = croot_lateral_length\n        r_soil = SQRT(1. / (rpi * root_length_density))\n        soil_conductance = MIN(hksat(c, j), hk_l(c, j)) / (1.E3_r8 * r_soil)\n        fs(j) = plc(smp(c, j), p, root, veg)\n        root_conductance = (fs(j) * rai(j) * params_inst % krmax(ivt(p))) / (croot_average_length + z(c, j))\n        soil_conductance = MAX(soil_conductance, 1.E-16_r8)\n        root_conductance = MAX(root_conductance, 1.E-16_r8)\n        root_conductance_patch(p, j) = root_conductance\n        soil_conductance_patch(p, j) = soil_conductance\n        rs_resis = 1._r8 / soil_conductance + 1._r8 / root_conductance\n        IF (rai(j) * rootfr(p, j) \u003e 0._r8 .AND. j \u003e 1) THEN\n          k_soil_root(p, j) = 1._r8 / rs_resis\n        ELSE\n          k_soil_root(p, j) = 0._r8\n        END IF\n      END DO\n    END DO\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      IF (NINT(c3psn(patch % itype(p))) == 1) THEN\n        c3flag(p) = .TRUE.\n      ELSE IF (NINT(c3psn(patch % itype(p))) == 0) THEN\n        c3flag(p) = .FALSE.\n      END IF\n      IF (c3flag(p)) THEN\n        qe(p) = 0._r8\n        IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) bbbopt(p) = bbbopt_c3\n      ELSE\n        qe(p) = 0.05_r8\n        IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) bbbopt(p) = bbbopt_c4\n      END IF\n      IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n        bbb(p) = bbbopt(p)\n        mbb(p) = mbbopt(patch % itype(p))\n      END IF\n      kc25 = params_inst % kc25_coef * forc_pbot(c)\n      ko25 = params_inst % ko25_coef * forc_pbot(c)\n      sco = 0.5_r8 * 0.209_r8 / params_inst % cp25_yr2000\n      cp25 = 0.5_r8 * oair(p) / sco\n      kc(p) = kc25 * ft(t_veg(p), params_inst % kcha)\n      ko(p) = ko25 * ft(t_veg(p), params_inst % koha)\n      cp(p) = cp25 * ft(t_veg(p), params_inst % cpha)\n    END DO\n    DO f = 1, fn\n      p = filterp(f)\n      IF (lnc_opt .EQV. .FALSE.) THEN\n        lnc(p) = 1._r8 / (slatop(patch % itype(p)) * leafcn(patch % itype(p)))\n      END IF\n      IF (lnc_opt .EQV. .TRUE.) THEN\n        sum_nscaler = 0.0_r8\n        laican = 0.0_r8\n        total_lai = 0.0_r8\n        DO iv = 1, nrad(p)\n          IF (iv == 1) THEN\n            laican = 0.5_r8 * tlai_z(p, iv)\n            total_lai = tlai_z(p, iv)\n          ELSE\n            laican = laican + 0.5_r8 * (tlai_z(p, iv - 1) + tlai_z(p, iv))\n            total_lai = total_lai + tlai_z(p, iv)\n          END IF\n          IF (nlevcan == 1) THEN\n            nscaler = 1.0_r8\n          ELSE IF (nlevcan \u003e 1) THEN\n            nscaler = EXP(- kn(p) * laican)\n          END IF\n          sum_nscaler = sum_nscaler + nscaler\n        END DO\n        IF (tlai(p) \u003e 0.0_r8 .AND. sum_nscaler \u003e 0.0_r8) THEN\n          lnc(p) = leafn(p) / (tlai(p) * sum_nscaler)\n        ELSE\n          lnc(p) = 0.0_r8\n        END IF\n      END IF\n      lnc(p) = MIN(lnc(p), 10._r8)\n      IF (reduce_dayl_factor .EQV. .TRUE.) THEN\n        IF (dayl_factor(p) \u003e 0.25_r8) THEN\n        END IF\n      END IF\n      IF (vcmax_opt == 0) THEN\n        vcmax25top = lnc(p) * flnr(patch % itype(p)) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        IF (.NOT. use_cn) THEN\n          vcmax25top = vcmax25top * fnitr(patch % itype(p))\n        ELSE\n          IF (CNAllocate_Carbon_only()) vcmax25top = vcmax25top * fnitr(patch % itype(p))\n        END IF\n      ELSE IF (vcmax_opt == 3) THEN\n        vcmax25top = (i_vcad(patch % itype(p)) + s_vcad(patch % itype(p)) * lnc(p)) * dayl_factor(p)\n      ELSE IF (vcmax_opt == 4) THEN\n        nptreemax = 9\n        IF (patch % itype(p) \u003e= nptreemax) THEN\n          vcmax25top = lnc(p) * (i_flnr(patch % itype(p)) + s_flnr(patch % itype(p)) * lnc(p)) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        ELSE\n          vcmax25top = lnc(p) * (i_flnr(patch % itype(p)) * EXP(s_flnr(patch % itype(p)) * lnc(p))) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        END IF\n      END IF\n      jmax25top = ((2.59_r8 - 0.035_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * vcmax25top) * params_inst % jmax25top_sf\n      tpu25top = params_inst % tpu25ratio * vcmax25top\n      kp25top = params_inst % kp25ratio * vcmax25top\n      luvcmax25top(p) = vcmax25top\n      lujmax25top(p) = jmax25top\n      lutpu25top(p) = tpu25top\n      IF (dayl_factor(p) .EQ. 0._r8) THEN\n        kn(p) = 0._r8\n      ELSE\n        kn(p) = EXP(0.00963_r8 * vcmax25top / dayl_factor(p) - 2.43_r8)\n      END IF\n      IF (use_cn) THEN\n        IF (leafresp_method == leafresp_mtd_ryan1991) THEN\n          lmr25top = 2.525E-6_r8 * (1.5_r8 ** ((25._r8 - 20._r8) / 10._r8))\n          lmr25top = lmr25top * lnc(p) / 12.E-06_r8\n        ELSE IF (leafresp_method == leafresp_mtd_atkin2015) THEN\n          IF (lnc(p) \u003e 0.0_r8) THEN\n            lmr25top = params_inst % lmr_intercept_atkin(ivt(p)) + (lnc(p) * 0.2061_r8) - (0.0402_r8 * (t10(p) - tfrz))\n          ELSE\n            lmr25top = 0.0_r8\n          END IF\n        END IF\n      ELSE\n        IF (c3flag(p)) THEN\n          lmr25top = vcmax25top * leaf_mr_vcm\n        ELSE\n          lmr25top = vcmax25top * 0.025_r8\n        END IF\n      END IF\n      laican = 0._r8\n      DO iv = 1, nrad(p)\n        IF (iv == 1) THEN\n          laican = 0.5_r8 * tlai_z(p, iv)\n        ELSE\n          laican = laican + 0.5_r8 * (tlai_z(p, iv - 1) + tlai_z(p, iv))\n        END IF\n        IF (nlevcan == 1) THEN\n          nscaler_sun = vcmaxcint_sun(p)\n          nscaler_sha = vcmaxcint_sha(p)\n        ELSE IF (nlevcan \u003e 1) THEN\n          nscaler_sun = EXP(- kn(p) * laican)\n          nscaler_sha = EXP(- kn(p) * laican)\n        END IF\n        lmr25_sun = lmr25top * nscaler_sun\n        lmr25_sha = lmr25top * nscaler_sha\n        IF (use_luna .AND. c3flag(p) .AND. crop(patch % itype(p)) == 0) THEN\n          IF (.NOT. use_cn) THEN\n            lmr25_sun = leaf_mr_vcm * photosyns_inst % vcmx25_z_patch(p, iv)\n            lmr25_sha = leaf_mr_vcm * photosyns_inst % vcmx25_z_patch(p, iv)\n          END IF\n        END IF\n        IF (c3flag(p)) THEN\n          lmr_z_sun(p, iv) = lmr25_sun * ft(t_veg(p), params_inst % lmrha) * fth(t_veg(p), params_inst % lmrhd, params_inst % lmrse, lmrc)\n          lmr_z_sha(p, iv) = lmr25_sha * ft(t_veg(p), params_inst % lmrha) * fth(t_veg(p), params_inst % lmrhd, params_inst % lmrse, lmrc)\n        ELSE\n          lmr_z_sun(p, iv) = lmr25_sun * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n          lmr_z_sun(p, iv) = lmr_z_sun(p, iv) / (1._r8 + EXP(1.3_r8 * (t_veg(p) - (tfrz + 55._r8))))\n          lmr_z_sha(p, iv) = lmr25_sha * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n          lmr_z_sha(p, iv) = lmr_z_sha(p, iv) / (1._r8 + EXP(1.3_r8 * (t_veg(p) - (tfrz + 55._r8))))\n        END IF\n        lmr_z_sun(p, iv) = lmr_z_sun(p, iv) * MIN((0.2_r8 * EXP(3.218_r8 * tlai_z(p, iv))), 1._r8)\n        lmr_z_sha(p, iv) = lmr_z_sha(p, iv) * MIN((0.2_r8 * EXP(3.218_r8 * tlai_z(p, iv))), 1._r8)\n        IF (par_z_sun(p, iv) \u003c= 0._r8) THEN\n          vcmax_z(p, sun, iv) = 0._r8\n          jmax_z(p, sun, iv) = 0._r8\n          tpu_z(p, sun, iv) = 0._r8\n          kp_z(p, sun, iv) = 0._r8\n          vcmax_z(p, sha, iv) = 0._r8\n          jmax_z(p, sha, iv) = 0._r8\n          tpu_z(p, sha, iv) = 0._r8\n          kp_z(p, sha, iv) = 0._r8\n          IF (use_c13) THEN\n            alphapsn_sun(p) = 1._r8\n            alphapsn_sha(p) = 1._r8\n          END IF\n        ELSE\n          IF (use_luna .AND. c3flag(p) .AND. crop(patch % itype(p)) == 0) THEN\n            vcmax25_sun = photosyns_inst % vcmx25_z_patch(p, iv)\n            vcmax25_sha = photosyns_inst % vcmx25_z_patch(p, iv)\n            jmax25_sun = photosyns_inst % jmx25_z_patch(p, iv)\n            jmax25_sha = photosyns_inst % jmx25_z_patch(p, iv)\n            tpu25_sun = params_inst % tpu25ratio * vcmax25_sun\n            tpu25_sha = params_inst % tpu25ratio * vcmax25_sha\n            IF (surfalb_inst % vcmaxcintsun_patch(p) .GT. 0._r8 .AND. nlevcan == 1) THEN\n              vcmax25_sha = vcmax25_sun * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n              jmax25_sha = jmax25_sun * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n              tpu25_sha = tpu25_sun * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n            END IF\n          ELSE\n            vcmax25_sun = vcmax25top * nscaler_sun\n            jmax25_sun = jmax25top * nscaler_sun\n            tpu25_sun = tpu25top * nscaler_sun\n            vcmax25_sha = vcmax25top * nscaler_sha\n            jmax25_sha = jmax25top * nscaler_sha\n            tpu25_sha = tpu25top * nscaler_sha\n          END IF\n          kp25_sun = kp25top * nscaler_sun\n          kp25_sha = kp25top * nscaler_sha\n          vcmaxse = (668.39_r8 - 1.07_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % vcmaxse_sf\n          jmaxse = (659.70_r8 - 0.75_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % jmaxse_sf\n          tpuse = (668.39_r8 - 1.07_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % tpuse_sf\n          vcmaxc = fth25(params_inst % vcmaxhd, vcmaxse)\n          jmaxc = fth25(params_inst % jmaxhd, jmaxse)\n          tpuc = fth25(params_inst % tpuhd, tpuse)\n          vcmax_z(p, sun, iv) = vcmax25_sun * ft(t_veg(p), params_inst % vcmaxha) * fth(t_veg(p), params_inst % vcmaxhd, vcmaxse, vcmaxc)\n          jmax_z(p, sun, iv) = jmax25_sun * ft(t_veg(p), params_inst % jmaxha) * fth(t_veg(p), params_inst % jmaxhd, jmaxse, jmaxc)\n          tpu_z(p, sun, iv) = tpu25_sun * ft(t_veg(p), params_inst % tpuha) * fth(t_veg(p), params_inst % tpuhd, tpuse, tpuc)\n          vcmax_z(p, sha, iv) = vcmax25_sha * ft(t_veg(p), params_inst % vcmaxha) * fth(t_veg(p), params_inst % vcmaxhd, vcmaxse, vcmaxc)\n          jmax_z(p, sha, iv) = jmax25_sha * ft(t_veg(p), params_inst % jmaxha) * fth(t_veg(p), params_inst % jmaxhd, jmaxse, jmaxc)\n          tpu_z(p, sha, iv) = tpu25_sha * ft(t_veg(p), params_inst % tpuha) * fth(t_veg(p), params_inst % tpuhd, tpuse, tpuc)\n          IF (.NOT. c3flag(p)) THEN\n            vcmax_z(p, sun, iv) = vcmax25_sun * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n            vcmax_z(p, sun, iv) = vcmax_z(p, sun, iv) / (1._r8 + EXP(0.2_r8 * ((tfrz + 15._r8) - t_veg(p))))\n            vcmax_z(p, sun, iv) = vcmax_z(p, sun, iv) / (1._r8 + EXP(0.3_r8 * (t_veg(p) - (tfrz + 40._r8))))\n            vcmax_z(p, sha, iv) = vcmax25_sha * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n            vcmax_z(p, sha, iv) = vcmax_z(p, sha, iv) / (1._r8 + EXP(0.2_r8 * ((tfrz + 15._r8) - t_veg(p))))\n            vcmax_z(p, sha, iv) = vcmax_z(p, sha, iv) / (1._r8 + EXP(0.3_r8 * (t_veg(p) - (tfrz + 40._r8))))\n          END IF\n          kp_z(p, sun, iv) = kp25_sun * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n          kp_z(p, sha, iv) = kp25_sha * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n        END IF\n        IF (light_inhibit .AND. par_z_sun(p, 1) \u003e 0._r8) THEN\n          lmr_z_sun(p, iv) = lmr_z_sun(p, iv) * 0.67_r8\n        END IF\n        IF (light_inhibit .AND. par_z_sha(p, 1) \u003e 0._r8) THEN\n          lmr_z_sha(p, iv) = lmr_z_sha(p, iv) * 0.67_r8\n        END IF\n      END DO\n    END DO\n    rsmax0 = 2.E4_r8\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      g = patch % gridcell(p)\n      cf = forc_pbot(c) / (rgas * 1.E-3_r8 * tgcm(p)) * 1.E06_r8\n      gb = 1._r8 / rb(p)\n      gb_mol(p) = gb * cf\n      DO iv = 1, nrad(p)\n        IF (par_z_sun(p, iv) \u003c= 0._r8) THEN\n          vegwp(p, sun) = 1._r8\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            gsminsun = bbb(p)\n            gsminsha = bbb(p)\n          ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n            gsminsun = medlynintercept(patch % itype(p))\n            gsminsha = medlynintercept(patch % itype(p))\n          ELSE\n            gsminsun = nan\n            gsminsha = nan\n          END IF\n          CALL calcstress(p, c, vegwp(p, :), bsun(p), bsha(p), gb_mol(p), gsminsun, gsminsha, qsatl(p), qaf(p), atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n          ac(p, sun, iv) = 0._r8\n          aj(p, sun, iv) = 0._r8\n          ap(p, sun, iv) = 0._r8\n          ag(p, sun, iv) = 0._r8\n          IF (crop(patch % itype(p)) == 0 .OR. .NOT. modifyphoto_and_lmr_forcrop) THEN\n            an_sun(p, iv) = ag(p, sun, iv) - bsun(p) * lmr_z_sun(p, iv)\n          ELSE\n            an_sun(p, iv) = ag(p, sun, iv) - lmr_z_sun(p, iv)\n          END IF\n          psn_z_sun(p, iv) = 0._r8\n          psn_wc_z_sun(p, iv) = 0._r8\n          psn_wj_z_sun(p, iv) = 0._r8\n          psn_wp_z_sun(p, iv) = 0._r8\n          rs_z_sun(p, iv) = MIN(rsmax0, 1._r8 / (MAX(bsun(p) * gsminsun, 1._r8)) * cf)\n          ci_z_sun(p, iv) = 0._r8\n          rh_leaf_sun(p) = 0._r8\n          ac(p, sha, iv) = 0._r8\n          aj(p, sha, iv) = 0._r8\n          ap(p, sha, iv) = 0._r8\n          ag(p, sha, iv) = 0._r8\n          IF (crop(patch % itype(p)) == 0 .OR. .NOT. modifyphoto_and_lmr_forcrop) THEN\n            an_sha(p, iv) = ag(p, sha, iv) - bsha(p) * lmr_z_sha(p, iv)\n          ELSE\n            an_sha(p, iv) = ag(p, sha, iv) - lmr_z_sha(p, iv)\n          END IF\n          psn_z_sha(p, iv) = 0._r8\n          psn_wc_z_sha(p, iv) = 0._r8\n          psn_wj_z_sha(p, iv) = 0._r8\n          psn_wp_z_sha(p, iv) = 0._r8\n          rs_z_sha(p, iv) = MIN(rsmax0, 1._r8 / (MAX(bsha(p) * gsminsha, 1._r8)) * cf)\n          ci_z_sha(p, iv) = 0._r8\n          rh_leaf_sha(p) = 0._r8\n        ELSE\n          ceair = MIN(eair(p), esat_tv(p))\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            rh_can = ceair / esat_tv(p)\n          ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n            rh_can = MAX((esat_tv(p) - ceair), medlyn_rh_can_max) * medlyn_rh_can_fact\n            vpd_can(p) = rh_can\n          END IF\n          qabs = 0.5_r8 * (1._r8 - params_inst % fnps) * par_z_sun(p, iv) * 4.6_r8\n          aquad = params_inst % theta_psii\n          bquad = - (qabs + jmax_z(p, sun, iv))\n          cquad = qabs * jmax_z(p, sun, iv)\n          CALL quadratic(aquad, bquad, cquad, r1, r2)\n          je_sun = MIN(r1, r2)\n          qabs = 0.5_r8 * (1._r8 - params_inst % fnps) * par_z_sha(p, iv) * 4.6_r8\n          aquad = params_inst % theta_psii\n          bquad = - (qabs + jmax_z(p, sha, iv))\n          cquad = qabs * jmax_z(p, sha, iv)\n          CALL quadratic(aquad, bquad, cquad, r1, r2)\n          je_sha = MIN(r1, r2)\n          IF (c3flag(p)) THEN\n            ci_z_sun(p, iv) = 0.7_r8 * cair(p)\n            ci_z_sha(p, iv) = 0.7_r8 * cair(p)\n          ELSE\n            ci_z_sun(p, iv) = 0.4_r8 * cair(p)\n            ci_z_sha(p, iv) = 0.4_r8 * cair(p)\n          END IF\n          CALL hybrid_PHS(ci_z_sun(p, iv), ci_z_sha(p, iv), p, iv, c, g, gb_mol(p), bsun(p), bsha(p), je_sun, je_sha, cair(p), oair(p), lmr_z_sun(p, iv), lmr_z_sha(p, iv), par_z_sun(p, iv), par_z_sha(p, iv), rh_can, gs_mol_sun(p, iv), gs_mol_sha(p, iv), qsatl(p), qaf(p), iter1, iter2, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n          IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n            gsminsun = medlynintercept(patch % itype(p))\n            gsminsha = medlynintercept(patch % itype(p))\n            gs_slope_sun = medlynslope(patch % itype(p))\n            gs_slope_sha = medlynslope(patch % itype(p))\n          ELSE IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            gsminsun = bbb(p)\n            gsminsha = bbb(p)\n            gs_slope_sun = mbb(p)\n            gs_slope_sha = mbb(p)\n          END IF\n          IF (an_sun(p, iv) \u003c 0._r8) gs_mol_sun(p, iv) = MAX(bsun(p) * gsminsun, 1._r8)\n          IF (an_sha(p, iv) \u003c 0._r8) gs_mol_sha(p, iv) = MAX(bsha(p) * gsminsha, 1._r8)\n          IF (is_near_local_noon(grc % londeg(g), deltasec = 3600)) THEN\n            gs_mol_sun_ln(p, iv) = gs_mol_sun(p, iv)\n            gs_mol_sha_ln(p, iv) = gs_mol_sha(p, iv)\n          ELSE\n            gs_mol_sun_ln(p, iv) = spval\n            gs_mol_sha_ln(p, iv) = spval\n          END IF\n          cs_sun = cair(p) - 1.4_r8 / gb_mol(p) * an_sun(p, iv) * forc_pbot(c)\n          cs_sun = MAX(cs_sun, max_cs)\n          ci_z_sun(p, iv) = cair(p) - an_sun(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol_sun(p, iv) + 1.6_r8 * gb_mol(p)) / (gb_mol(p) * gs_mol_sun(p, iv))\n          ci_z_sun(p, iv) = MAX(ci_z_sun(p, iv), 1.E-06_r8)\n          cs_sha = cair(p) - 1.4_r8 / gb_mol(p) * an_sha(p, iv) * forc_pbot(c)\n          cs_sha = MAX(cs_sha, max_cs)\n          ci_z_sha(p, iv) = cair(p) - an_sha(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol_sha(p, iv) + 1.6_r8 * gb_mol(p)) / (gb_mol(p) * gs_mol_sha(p, iv))\n          ci_z_sha(p, iv) = MAX(ci_z_sha(p, iv), 1.E-06_r8)\n          gs = gs_mol_sun(p, iv) / cf\n          rs_z_sun(p, iv) = MIN(1._r8 / gs, rsmax0)\n          rs_z_sun(p, iv) = rs_z_sun(p, iv) / o3coefg_sun(p)\n          gs = gs_mol_sha(p, iv) / cf\n          rs_z_sha(p, iv) = MIN(1._r8 / gs, rsmax0)\n          rs_z_sha(p, iv) = rs_z_sha(p, iv) / o3coefg_sha(p)\n          psn_z_sun(p, iv) = ag(p, sun, iv)\n          psn_z_sun(p, iv) = psn_z_sun(p, iv) * o3coefv_sun(p)\n          psn_wc_z_sun(p, iv) = 0._r8\n          psn_wj_z_sun(p, iv) = 0._r8\n          psn_wp_z_sun(p, iv) = 0._r8\n          IF (ac(p, sun, iv) \u003c= aj(p, sun, iv) .AND. ac(p, sun, iv) \u003c= ap(p, sun, iv)) THEN\n            psn_wc_z_sun(p, iv) = psn_z_sun(p, iv)\n          ELSE IF (aj(p, sun, iv) \u003c ac(p, sun, iv) .AND. aj(p, sun, iv) \u003c= ap(p, sun, iv)) THEN\n            psn_wj_z_sun(p, iv) = psn_z_sun(p, iv)\n          ELSE IF (ap(p, sun, iv) \u003c ac(p, sun, iv) .AND. ap(p, sun, iv) \u003c aj(p, sun, iv)) THEN\n            psn_wp_z_sun(p, iv) = psn_z_sun(p, iv)\n          END IF\n          psn_z_sha(p, iv) = ag(p, sha, iv)\n          psn_z_sha(p, iv) = psn_z_sha(p, iv) * o3coefv_sha(p)\n          psn_wc_z_sha(p, iv) = 0._r8\n          psn_wj_z_sha(p, iv) = 0._r8\n          psn_wp_z_sha(p, iv) = 0._r8\n          IF (ac(p, sha, iv) \u003c= aj(p, sha, iv) .AND. ac(p, sha, iv) \u003c= ap(p, sha, iv)) THEN\n            psn_wc_z_sha(p, iv) = psn_z_sha(p, iv)\n          ELSE IF (aj(p, sha, iv) \u003c ac(p, sha, iv) .AND. aj(p, sha, iv) \u003c= ap(p, sha, iv)) THEN\n            psn_wj_z_sha(p, iv) = psn_z_sha(p, iv)\n          ELSE IF (ap(p, sha, iv) \u003c ac(p, sha, iv) .AND. ap(p, sha, iv) \u003c aj(p, sha, iv)) THEN\n            psn_wp_z_sha(p, iv) = psn_z_sha(p, iv)\n          END IF\n          IF (gs_mol_sun(p, iv) \u003c 0._r8 .OR. gs_mol_sha(p, iv) \u003c 0._r8) THEN\n            WRITE(iulog, *) \u0027Negative stomatal conductance:\u0027\n            WRITE(iulog, *) \u0027p,iv,gs_mol_sun,gs_mol_sha= \u0027, p, iv, gs_mol_sun(p, iv), gs_mol_sha(p, iv)\n            CALL endrun(subgrid_index = p, subgrid_level = subgrid_level_patch, msg = errmsg(sourcefile, 3659))\n          END IF\n          hs = (gb_mol(p) * ceair + gs_mol_sun(p, iv) * esat_tv(p)) / ((gb_mol(p) + gs_mol_sun(p, iv)) * esat_tv(p))\n          rh_leaf_sun(p) = hs\n          gs_mol_err = gs_slope_sun * MAX(an_sun(p, iv), 0._r8) * hs / cs_sun * forc_pbot(c) + MAX(bsun(p) * gsminsun, 1._r8)\n          IF (ABS(gs_mol_sun(p, iv) - gs_mol_err) \u003e 1.E-01_r8 .AND. (stomatalcond_mtd == stomatalcond_mtd_bb1987)) THEN\n            WRITE(iulog, *) \u0027Ball-Berry error check - sunlit stomatal conductance error:\u0027\n            WRITE(iulog, *) gs_mol_sun(p, iv), gs_mol_err\n          END IF\n          hs = (gb_mol(p) * ceair + gs_mol_sha(p, iv) * esat_tv(p)) / ((gb_mol(p) + gs_mol_sha(p, iv)) * esat_tv(p))\n          rh_leaf_sha(p) = hs\n          gs_mol_err = gs_slope_sha * MAX(an_sha(p, iv), 0._r8) * hs / cs_sha * forc_pbot(c) + MAX(bsha(p) * gsminsha, 1._r8)\n          IF (ABS(gs_mol_sha(p, iv) - gs_mol_err) \u003e 1.E-01_r8 .AND. (stomatalcond_mtd == stomatalcond_mtd_bb1987)) THEN\n            WRITE(iulog, *) \u0027Ball-Berry error check - shaded stomatal conductance error:\u0027\n            WRITE(iulog, *) gs_mol_sha(p, iv), gs_mol_err\n          END IF\n        END IF\n      END DO\n    END DO\n    DO f = 1, fn\n      p = filterp(f)\n      psncan_sun = 0._r8\n      psncan_wc_sun = 0._r8\n      psncan_wj_sun = 0._r8\n      psncan_wp_sun = 0._r8\n      lmrcan_sun = 0._r8\n      gscan_sun = 0._r8\n      laican_sun = 0._r8\n      DO iv = 1, nrad(p)\n        psncan_sun = psncan_sun + psn_z_sun(p, iv) * lai_z_sun(p, iv)\n        psncan_wc_sun = psncan_wc_sun + psn_wc_z_sun(p, iv) * lai_z_sun(p, iv)\n        psncan_wj_sun = psncan_wj_sun + psn_wj_z_sun(p, iv) * lai_z_sun(p, iv)\n        psncan_wp_sun = psncan_wp_sun + psn_wp_z_sun(p, iv) * lai_z_sun(p, iv)\n        IF (crop(patch % itype(p)) == 0 .AND. modifyphoto_and_lmr_forcrop) THEN\n          lmrcan_sun = lmrcan_sun + lmr_z_sun(p, iv) * lai_z_sun(p, iv) * bsun(p)\n        ELSE\n          lmrcan_sun = lmrcan_sun + lmr_z_sun(p, iv) * lai_z_sun(p, iv)\n        END IF\n        gscan_sun = gscan_sun + lai_z_sun(p, iv) / (rb(p) + rs_z_sun(p, iv))\n        laican_sun = laican_sun + lai_z_sun(p, iv)\n      END DO\n      IF (laican_sun \u003e 0._r8) THEN\n        psn_sun(p) = psncan_sun / laican_sun\n        psn_wc_sun(p) = psncan_wc_sun / laican_sun\n        psn_wj_sun(p) = psncan_wj_sun / laican_sun\n        psn_wp_sun(p) = psncan_wp_sun / laican_sun\n        lmr_sun(p) = lmrcan_sun / laican_sun\n        rs_sun(p) = laican_sun / gscan_sun - rb(p)\n      ELSE\n        psn_sun(p) = 0._r8\n        psn_wc_sun(p) = 0._r8\n        psn_wj_sun(p) = 0._r8\n        psn_wp_sun(p) = 0._r8\n        lmr_sun(p) = 0._r8\n        rs_sun(p) = 0._r8\n      END IF\n      psncan_sha = 0._r8\n      psncan_wc_sha = 0._r8\n      psncan_wj_sha = 0._r8\n      psncan_wp_sha = 0._r8\n      lmrcan_sha = 0._r8\n      gscan_sha = 0._r8\n      laican_sha = 0._r8\n      DO iv = 1, nrad(p)\n        psncan_sha = psncan_sha + psn_z_sha(p, iv) * lai_z_sha(p, iv)\n        psncan_wc_sha = psncan_wc_sha + psn_wc_z_sha(p, iv) * lai_z_sha(p, iv)\n        psncan_wj_sha = psncan_wj_sha + psn_wj_z_sha(p, iv) * lai_z_sha(p, iv)\n        psncan_wp_sha = psncan_wp_sha + psn_wp_z_sha(p, iv) * lai_z_sha(p, iv)\n        IF (crop(patch % itype(p)) == 0 .AND. modifyphoto_and_lmr_forcrop) THEN\n          lmrcan_sha = lmrcan_sha + lmr_z_sha(p, iv) * lai_z_sha(p, iv) * bsha(p)\n        ELSE\n          lmrcan_sha = lmrcan_sha + lmr_z_sha(p, iv) * lai_z_sha(p, iv)\n        END IF\n        gscan_sha = gscan_sha + lai_z_sha(p, iv) / (rb(p) + rs_z_sha(p, iv))\n        laican_sha = laican_sha + lai_z_sha(p, iv)\n      END DO\n      IF (laican_sha \u003e 0._r8) THEN\n        psn_sha(p) = psncan_sha / laican_sha\n        psn_wc_sha(p) = psncan_wc_sha / laican_sha\n        psn_wj_sha(p) = psncan_wj_sha / laican_sha\n        psn_wp_sha(p) = psncan_wp_sha / laican_sha\n        lmr_sha(p) = lmrcan_sha / laican_sha\n        rs_sha(p) = laican_sha / gscan_sha - rb(p)\n      ELSE\n        psn_sha(p) = 0._r8\n        psn_wc_sha(p) = 0._r8\n        psn_wj_sha(p) = 0._r8\n        psn_wp_sha(p) = 0._r8\n        lmr_sha(p) = 0._r8\n        rs_sha(p) = 0._r8\n      END IF\n      IF (laican_sha + laican_sun \u003e 0._r8) THEN\n        btran(p) = bsun(p) * (laican_sun / (laican_sun + laican_sha)) + bsha(p) * (laican_sha / (laican_sun + laican_sha))\n      ELSE\n        btran(p) = bsun(p)\n      END IF\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE PhotosynthesisHydraulicStress"}, {"color": "#97c2fc", "id": "brent_PHS", "label": "brent_PHS", "shape": "dot", "size": 10, "source": "SUBROUTINE brent_PHS(xsun, x1sun, x2sun, f1sun, f2sun, xsha, x1sha, x2sha, f1sha, f2sha, tol, ip, iv, ic, gb_mol, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, gs_mol_sun, gs_mol_sha, bsun, bsha, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n  IMPLICIT NONE\n  REAL(KIND = r8), INTENT(OUT) :: xsun\n  REAL(KIND = r8), INTENT(IN) :: x1sun, x2sun\n  REAL(KIND = r8), INTENT(IN) :: f1sun, f2sun\n  REAL(KIND = r8), INTENT(OUT) :: xsha\n  REAL(KIND = r8), INTENT(IN) :: x1sha, x2sha\n  REAL(KIND = r8), INTENT(IN) :: f1sha, f2sha\n  REAL(KIND = r8), INTENT(IN) :: tol\n  INTEGER, INTENT(IN) :: ip, iv, ic\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: jesun, jesha\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  REAL(KIND = r8), INTENT(IN) :: lmr_z_sun, lmr_z_sha\n  REAL(KIND = r8), INTENT(IN) :: par_z_sun, par_z_sha\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol_sun\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol_sha\n  REAL(KIND = r8), INTENT(INOUT) :: bsun\n  REAL(KIND = r8), INTENT(INOUT) :: bsha\n  REAL(KIND = r8), INTENT(IN) :: qsatl\n  REAL(KIND = r8), INTENT(IN) :: qaf\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  TYPE(canopystate_type), INTENT(INOUT) :: canopystate_inst\n  TYPE(waterdiagnosticbulk_type), INTENT(INOUT) :: waterdiagnosticbulk_inst\n  TYPE(waterfluxbulk_type), INTENT(INOUT) :: waterfluxbulk_inst\n  TYPE(soilstate_type), INTENT(INOUT) :: soilstate_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  REAL(KIND = r8) :: gs0sun\n  REAL(KIND = r8) :: gs0sha\n  INTEGER :: phase\n  INTEGER, PARAMETER :: nphs = 2\n  INTEGER, PARAMETER :: itmax = 20\n  REAL(KIND = r8), PARAMETER :: eps = 1.E-4_r8\n  INTEGER :: iter\n  REAL(KIND = r8) :: a(nphs), b(nphs), c(nphs), d(nphs), e(nphs), fa(nphs), fb(nphs), fc(nphs)\n  REAL(KIND = r8) :: p(nphs), q(nphs), r(nphs), s(nphs), tol1(nphs), xm(nphs)\n  REAL(KIND = r8) :: x(nvegwcs)\n  LOGICAL, PARAMETER :: bflag = .FALSE.\n  a(:) = (/x1sun, x1sha/)\n  b(:) = (/x2sun, x2sha/)\n  fa(:) = (/f1sun, f1sha/)\n  fb(:) = (/f2sun, f2sha/)\n  DO phase = 1, nphs\n    IF ((fa(phase) \u003e 0._r8 .AND. fb(phase) \u003e 0._r8) .OR. (fa(phase) \u003c 0._r8 .AND. fb(phase) \u003c 0._r8)) THEN\n      WRITE(iulog, *) \u0027root must be bracketed for brent\u0027\n      CALL endrun(subgrid_index = ip, subgrid_level = subgrid_level_patch, msg = errmsg(sourcefile, 4103))\n    END IF\n  END DO\n  c = b\n  fc = fb\n  iter = 0\n  DO\n    IF (iter == itmax) EXIT\n    iter = iter + 1\n    DO phase = 1, nphs\n      IF ((fb(phase) \u003e 0._r8 .AND. fc(phase) \u003e 0._r8) .OR. (fb(phase) \u003c 0._r8 .AND. fc(phase) \u003c 0._r8)) THEN\n        c(phase) = a(phase)\n        fc(phase) = fa(phase)\n        d(phase) = b(phase) - a(phase)\n        e(phase) = d(phase)\n      END IF\n      IF (ABS(fc(phase)) \u003c ABS(fb(phase))) THEN\n        a(phase) = b(phase)\n        b(phase) = c(phase)\n        c(phase) = a(phase)\n        fa(phase) = fb(phase)\n        fb(phase) = fc(phase)\n        fc(phase) = fa(phase)\n      END IF\n    END DO\n    tol1 = 2._r8 * eps * ABS(b) + 0.5_r8 * tol\n    xm = 0.5_r8 * (c - b)\n    IF (ABS(xm(sun)) \u003c= tol1(sun) .OR. fb(sun) == 0._r8) THEN\n      IF (ABS(xm(sha)) \u003c= tol1(sha) .OR. fb(sha) == 0._r8) THEN\n        xsun = b(sun)\n        xsha = b(sha)\n        RETURN\n      END IF\n    END IF\n    DO phase = 1, nphs\n      IF (ABS(e(phase)) \u003e= tol1(phase) .AND. ABS(fa(phase)) \u003e ABS(fb(phase))) THEN\n        s(phase) = fb(phase) / fa(phase)\n        IF (a(phase) == c(phase)) THEN\n          p(phase) = 2._r8 * xm(phase) * s(phase)\n          q(phase) = 1._r8 - s(phase)\n        ELSE\n          q(phase) = fa(phase) / fc(phase)\n          r(phase) = fb(phase) / fc(phase)\n          p(phase) = s(phase) * (2._r8 * xm(phase) * q(phase) * (q(phase) - r(phase)) - (b(phase) - a(phase)) * (r(phase) - 1._r8))\n          q(phase) = (q(phase) - 1._r8) * (r(phase) - 1._r8) * (s(phase) - 1._r8)\n        END IF\n        IF (p(phase) \u003e 0._r8) q(phase) = - q(phase)\n        p(phase) = ABS(p(phase))\n        IF (2._r8 * p(phase) \u003c MIN(3._r8 * xm(phase) * q(phase) - ABS(tol1(phase) * q(phase)), ABS(e(phase) * q(phase)))) THEN\n          e(phase) = d(phase)\n          d(phase) = p(phase) / q(phase)\n        ELSE\n          d(phase) = xm(phase)\n          e(phase) = d(phase)\n        END IF\n      ELSE\n        d(phase) = xm(phase)\n        e(phase) = d(phase)\n      END IF\n      a(phase) = b(phase)\n      fa(phase) = fb(phase)\n      IF (ABS(d(phase)) \u003e tol1(phase)) THEN\n        b(phase) = b(phase) + d(phase)\n      ELSE\n        b(phase) = b(phase) + SIGN(tol1(phase), xm(phase))\n      END IF\n    END DO\n    gs0sun = gs_mol_sun\n    gs0sha = gs_mol_sha\n    CALL ci_func_PHS(x, b(sun), b(sha), fb(sun), fb(sha), ip, iv, ic, bsun, bsha, bflag, gb_mol, gs0sun, gs0sha, gs_mol_sun, gs_mol_sha, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n    IF ((fb(sun) == 0._r8) .AND. (fb(sha) == 0._r8)) EXIT\n  END DO\n  IF (iter == itmax) WRITE(iulog, *) \u0027brent exceeding maximum iterations\u0027, b, fb\n  xsun = b(sun)\n  xsha = b(sha)\n  RETURN\nEND SUBROUTINE brent_PHS"}, {"color": "#97c2fc", "id": "spacA", "label": "spacA", "shape": "dot", "size": 10, "source": "SUBROUTINE spacA(p, c, x, invA, qflx_sun, qflx_sha, flag, atm2lnd_inst, canopystate_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n  USE clm_varpar, ONLY: nlevsoi\n  USE clm_varcon, ONLY: rgas\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: c\n  REAL(KIND = r8), INTENT(IN) :: x(nvegwcs)\n  REAL(KIND = r8), INTENT(OUT) :: invA(nvegwcs, nvegwcs)\n  REAL(KIND = r8), INTENT(IN) :: qflx_sun\n  REAL(KIND = r8), INTENT(IN) :: qflx_sha\n  LOGICAL, INTENT(OUT) :: flag\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(soilstate_type), INTENT(IN) :: soilstate_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  TYPE(waterfluxbulk_type), INTENT(IN) :: waterfluxbulk_inst\n  REAL(KIND = r8) :: wtl\n  REAL(KIND = r8) :: fsto1\n  REAL(KIND = r8) :: fsto2\n  REAL(KIND = r8) :: fx\n  REAL(KIND = r8) :: fr\n  REAL(KIND = r8) :: dfsto1\n  REAL(KIND = r8) :: dfsto2\n  REAL(KIND = r8) :: dfx\n  REAL(KIND = r8) :: dfr\n  REAL(KIND = r8) :: A(nvegwcs, nvegwcs)\n  REAL(KIND = r8) :: leading\n  REAL(KIND = r8) :: determ\n  REAL(KIND = r8) :: grav1\n  REAL(KIND = r8) :: invfactor\n  REAL(KIND = r8), PARAMETER :: tol_lai = .001_r8\n  INTEGER :: j\n  IF (nvegwcs /= 4) THEN\n    CALL endrun(subgrid_index = p, subgrid_level = subgrid_level_patch, msg = \u0027Error:: this function is hardcoded for 4x4 matrices with nvegwcs==4\u0027 // errMsg(\"./examples/photosynthesis/PhotosynthesisMod.f90\", 4735))\n  END IF\n  ASSOCIATE(k_soil_root =\u003e soilstate_inst % k_soil_root_patch, laisun =\u003e canopystate_inst % laisun_patch, laisha =\u003e canopystate_inst % laisha_patch, htop =\u003e canopystate_inst % htop_patch, tsai =\u003e canopystate_inst % tsai_patch, ivt =\u003e patch % itype)\n    A = 0._r8\n    invA = 0._r8\n    grav1 = htop(p) * 1000._r8\n    fsto1 = plc(x(sun), p, sun, veg)\n    fsto2 = plc(x(sha), p, sha, veg)\n    fx = plc(x(xyl), p, xyl, veg)\n    fr = plc(x(root), p, root, veg)\n    dfsto1 = d1plc(x(sun), p, sun, veg)\n    dfsto2 = d1plc(x(sha), p, sha, veg)\n    dfx = d1plc(x(xyl), p, xyl, veg)\n    dfr = d1plc(x(root), p, root, veg)\n    A(1, 1) = - laisun(p) * params_inst % kmax(ivt(p), sun) * fx - qflx_sun * dfsto1\n    A(1, 3) = laisun(p) * params_inst % kmax(ivt(p), sun) * dfx * (x(xyl) - x(sun)) + laisun(p) * params_inst % kmax(ivt(p), sun) * fx\n    A(2, 2) = - laisha(p) * params_inst % kmax(ivt(p), sha) * fx - qflx_sha * dfsto2\n    A(2, 3) = laisha(p) * params_inst % kmax(ivt(p), sha) * dfx * (x(xyl) - x(sha)) + laisha(p) * params_inst % kmax(ivt(p), sha) * fx\n    A(3, 1) = laisun(p) * params_inst % kmax(ivt(p), sun) * fx\n    A(3, 2) = laisha(p) * params_inst % kmax(ivt(p), sha) * fx\n    A(3, 3) = - laisun(p) * params_inst % kmax(ivt(p), sun) * dfx * (x(xyl) - x(sun)) - laisun(p) * params_inst % kmax(ivt(p), sun) * fx - laisha(p) * params_inst % kmax(ivt(p), sha) * dfx * (x(xyl) - x(sha)) - laisha(p) * params_inst % kmax(ivt(p), sha) * fx - tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * fr\n    A(3, 4) = tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * dfr * (x(root) - x(xyl) - grav1) + tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * fr\n    A(4, 3) = tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * fr\n    A(4, 4) = - tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * fr - tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * dfr * (x(root) - x(xyl) - grav1) - SUM(k_soil_root(p, 1 : nlevsoi))\n    invfactor = 1._r8\n    A = invfactor * A\n    IF (laisun(p) \u003e tol_lai .AND. laisha(p) \u003e tol_lai) THEN\n      determ = A(4, 4) * A(2, 2) * A(3, 3) * A(1, 1) - A(4, 4) * A(2, 2) * A(3, 1) * A(1, 3) - A(4, 4) * A(3, 2) * A(2, 3) * A(1, 1) - A(4, 3) * A(1, 1) * A(2, 2) * A(3, 4)\n      IF (ABS(determ) \u003c= 1.E-50_r8) THEN\n        flag = .TRUE.\n        RETURN\n      ELSE\n        flag = .FALSE.\n      END IF\n      leading = 1._r8 / determ\n      invA(1, 1) = leading * A(4, 4) * A(2, 2) * A(3, 3) - leading * A(4, 4) * A(3, 2) * A(2, 3) - leading * A(4, 3) * A(2, 2) * A(3, 4)\n      invA(2, 1) = leading * A(2, 3) * A(4, 4) * A(3, 1)\n      invA(3, 1) = - leading * A(4, 4) * A(2, 2) * A(3, 1)\n      invA(4, 1) = leading * A(4, 3) * A(2, 2) * A(3, 1)\n      invA(1, 2) = leading * A(1, 3) * A(4, 4) * A(3, 2)\n      invA(2, 2) = leading * A(4, 4) * A(3, 3) * A(1, 1) - leading * A(4, 4) * A(3, 1) * A(1, 3) - leading * A(4, 3) * A(1, 1) * A(3, 4)\n      invA(3, 2) = - leading * A(1, 1) * A(4, 4) * A(3, 2)\n      invA(4, 2) = leading * A(4, 3) * A(1, 1) * A(3, 2)\n      invA(1, 3) = - leading * A(1, 3) * A(2, 2) * A(4, 4)\n      invA(2, 3) = - leading * A(2, 3) * A(1, 1) * A(4, 4)\n      invA(3, 3) = leading * A(2, 2) * A(1, 1) * A(4, 4)\n      invA(4, 3) = - leading * A(4, 3) * A(1, 1) * A(2, 2)\n      invA(1, 4) = leading * A(1, 3) * A(3, 4) * A(2, 2)\n      invA(2, 4) = leading * A(2, 3) * A(3, 4) * A(1, 1)\n      invA(3, 4) = - leading * A(3, 4) * A(1, 1) * A(2, 2)\n      invA(4, 4) = leading * A(2, 2) * A(3, 3) * A(1, 1) - leading * A(2, 2) * A(3, 1) * A(1, 3) - leading * A(3, 2) * A(2, 3) * A(1, 1)\n      invA = invfactor * invA\n    ELSE\n      IF (laisha(p) \u003c= tol_lai) THEN\n        A(2, 2) = A(1, 1)\n        A(3, 2) = A(3, 1)\n        A(2, 3) = A(1, 3)\n      END IF\n      determ = A(2, 2) * A(3, 3) * A(4, 4) - A(3, 4) * A(2, 2) * A(4, 3) - A(2, 3) * A(3, 2) * A(4, 4)\n      IF (ABS(determ) \u003c= 1.E-50_r8) THEN\n        flag = .TRUE.\n        RETURN\n      ELSE\n        flag = .FALSE.\n      END IF\n      invA(2, 2) = A(3, 3) * A(4, 4) - A(3, 4) * A(4, 3)\n      invA(2, 3) = - A(2, 3) * A(4, 4)\n      invA(2, 4) = A(3, 4) * A(2, 3)\n      invA(3, 2) = - A(3, 2) * A(4, 4)\n      invA(3, 3) = A(2, 2) * A(4, 4)\n      invA(3, 4) = - A(3, 4) * A(2, 2)\n      invA(4, 2) = A(3, 2) * A(4, 3)\n      invA(4, 3) = - A(2, 2) * A(4, 3)\n      invA(4, 4) = A(2, 2) * A(3, 3) - A(2, 3) * A(3, 2)\n      invA = 1._r8 / determ * invA\n    END IF\n  END ASSOCIATE\nEND SUBROUTINE spacA"}, {"color": "#97c2fc", "id": "plc", "label": "plc", "shape": "dot", "size": 10, "source": "FUNCTION plc(x, p, level, plc_method)\n  REAL(KIND = r8), INTENT(IN) :: x\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: level\n  INTEGER, INTENT(IN) :: plc_method\n  REAL(KIND = r8) :: plc\n  ASSOCIATE(ivt =\u003e patch % itype)\n    SELECT CASE (plc_method)\n    CASE (vegetation_weibull)\n      plc = 2._r8 ** (- (x / params_inst % psi50(ivt(p), level)) ** params_inst % ck(ivt(p), level))\n      IF (plc \u003c 0.005_r8) plc = 0._r8\n    CASE DEFAULT\n      plc = nan\n      CALL endrun(\u0027ERROR:: Photosynthesis::PLC must choose plc method\u0027)\n    END SELECT\n  END ASSOCIATE\nEND FUNCTION plc"}, {"color": "#97c2fc", "id": "d1plc", "label": "d1plc", "shape": "dot", "size": 10, "source": "FUNCTION d1plc(x, p, level, plc_method)\n  REAL(KIND = r8), INTENT(IN) :: x\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: level\n  INTEGER, INTENT(IN) :: plc_method\n  REAL(KIND = r8) :: d1plc\n  ASSOCIATE(ivt =\u003e patch % itype)\n    SELECT CASE (plc_method)\n    CASE (vegetation_weibull)\n      d1plc = - params_inst % ck(ivt(p), level) * LOG(2._r8) * (2._r8 ** (- (x / params_inst % psi50(ivt(p), level)) ** params_inst % ck(ivt(p), level))) * ((x / params_inst % psi50(ivt(p), level)) ** params_inst % ck(ivt(p), level)) / x\n    CASE DEFAULT\n      d1plc = nan\n      CALL endrun(\u0027ERROR:: Photosynthesis::D1PLC must choose plc method\u0027)\n    END SELECT\n  END ASSOCIATE\nEND FUNCTION d1plc"}, {"color": "#97c2fc", "id": "params_inst % allocParams", "label": "params_inst % allocParams", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "setParamsForTesting", "label": "setParamsForTesting", "shape": "dot", "size": 10, "source": "SUBROUTINE setParamsForTesting(this)\n  IMPLICIT NONE\n  CLASS(photosyns_type) :: this\n  CHARACTER(LEN = 32) :: subname = \u0027setParamsForTesting\u0027\n  CALL params_inst % allocParams\n  params_inst % ck = 3.95_r8\n  params_inst % psi50(1, :) = - 150000._r8\n  params_inst % psi50(2, :) = - 530000._r8\n  params_inst % psi50(3 : 12, :) = - 400000._r8\n  params_inst % psi50(13 :, :) = - 340000._r8\nEND SUBROUTINE setParamsForTesting"}, {"color": "#97c2fc", "id": "ncd_io", "label": "ncd_io", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "readNcdioScalar", "label": "readNcdioScalar", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "opnfil", "label": "opnfil", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "shr_nl_find_group_name", "label": "shr_nl_find_group_name", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "relavu", "label": "relavu", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "shr_mpi_bcast", "label": "shr_mpi_bcast", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "restartvar", "label": "restartvar", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Restart", "label": "Restart", "shape": "dot", "size": 10, "source": "SUBROUTINE Restart(this, bounds, ncid, flag)\n  USE ncdio_pio, ONLY: file_desc_t, ncd_defvar, ncd_io, ncd_double, ncd_int, ncd_inqvdlen\n  USE restUtilMod\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  TYPE(file_desc_t), INTENT(INOUT) :: ncid\n  CHARACTER(LEN = *), INTENT(IN) :: flag\n  INTEGER :: j, c\n  LOGICAL :: readvar\n  IF (use_c13) THEN\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027rc13_canair\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027\u0027, units = \u0027\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % rc13_canair_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027rc13_psnsun\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027\u0027, units = \u0027\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % rc13_psnsun_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027rc13_psnsha\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027\u0027, units = \u0027\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % rc13_psnsha_patch)\n  END IF\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSUN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027sunlit leaf stomatal conductance\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sun_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSHA\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027shaded leaf stomatal conductance\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sha_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSUNLN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027sunlit leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sun_ln_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSHALN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027shaded leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sha_ln_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027lnca\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027leaf N concentration\u0027, units = \u0027gN leaf/m^2\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % lnca_patch)\n  IF (use_luna) THEN\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027vcmx25_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027Maximum carboxylation rate at 25 Celcius for canopy layers\u0027, units = \u0027umol CO2/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % vcmx25_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027jmx25_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027Maximum rate of electron transport at 25 Celcius for canopy layers\u0027, units = \u0027umol electrons/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % jmx25_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027vcmx25_z_last_valid_patch:vcmx_prevyr\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027avg carboxylation rate at 25 celsius for canopy layers\u0027, units = \u0027umol CO2/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % vcmx25_z_last_valid_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027jmx25_z_last_valid_patch:jmx_prevyr\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027avg rate of electron transport at 25 Celcius for canopy layers\u0027, units = \u0027umol electrons/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % jmx25_z_last_valid_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027pnlc_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027proportion of leaf nitrogen allocated for light capture\u0027, units = \u0027unitless\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % pnlc_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027enzs_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027enzyme decay status during stress: 1.0-fully active; 0.0-all decayed\u0027, units = \u0027unitless\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % enzs_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027gpp24\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027accumulative gross primary production\u0027, units = \u0027umol CO2/m**2 ground/day\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % fpsn24_patch)\n  END IF\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027vcmx25t\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy profile of vcmax25\u0027, units = \u0027umol/m2/s\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % luvcmax25top_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027jmx25t\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy profile of jmax\u0027, units = \u0027umol/m2/s\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % lujmax25top_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027tpu25t\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy profile of tpu\u0027, units = \u0027umol/m2/s\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % lutpu25top_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027VPD_CAN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy vapor pressure deficit\u0027, units = \u0027kPa\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % vpd_can_patch)\nEND SUBROUTINE Restart"}, {"color": "#97c2fc", "id": "shr_assert_all", "label": "shr_assert_all", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Fractionation", "label": "Fractionation", "shape": "dot", "size": 10, "source": "SUBROUTINE Fractionation(bounds, fn, filterp, downreg, atm2lnd_inst, canopystate_inst, solarabs_inst, surfalb_inst, photosyns_inst, phase)\n  USE clm_varctl, ONLY: use_hydrstress\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER, INTENT(IN) :: fn\n  INTEGER, INTENT(IN) :: filterp(fn)\n  REAL(KIND = r8), INTENT(IN) :: downreg(bounds % begp :)\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(solarabs_type), INTENT(IN) :: solarabs_inst\n  TYPE(surfalb_type), INTENT(IN) :: surfalb_inst\n  TYPE(photosyns_type), INTENT(IN) :: photosyns_inst\n  CHARACTER(LEN = *), INTENT(IN) :: phase\n  REAL(KIND = r8), POINTER :: par_z(:, :)\n  REAL(KIND = r8), POINTER :: alphapsn(:)\n  REAL(KIND = r8), POINTER :: gs_mol(:, :)\n  REAL(KIND = r8), POINTER :: an(:, :)\n  INTEGER :: f, p, c, g, iv\n  REAL(KIND = r8) :: co2(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: ci\n  CALL shr_assert_all((UBOUND(downreg) == (/bounds % endp/)), file = sourcefile, line = 2181)\n  ASSOCIATE(forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, forc_pco2 =\u003e atm2lnd_inst % forc_pco2_grc, c3psn =\u003e pftcon % c3psn, nrad =\u003e surfalb_inst % nrad_patch, gb_mol =\u003e photosyns_inst % gb_mol_patch)\n    IF (phase == \u0027sun\u0027) THEN\n      par_z =\u003e solarabs_inst % parsun_z_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsun_patch\n      IF (use_hydrstress) THEN\n        gs_mol =\u003e photosyns_inst % gs_mol_sun_patch\n        an =\u003e photosyns_inst % an_sun_patch\n      ELSE\n        gs_mol =\u003e photosyns_inst % gs_mol_patch\n        an =\u003e photosyns_inst % an_patch\n      END IF\n    ELSE IF (phase == \u0027sha\u0027) THEN\n      par_z =\u003e solarabs_inst % parsha_z_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsha_patch\n      IF (use_hydrstress) THEN\n        gs_mol =\u003e photosyns_inst % gs_mol_sha_patch\n        an =\u003e photosyns_inst % an_sha_patch\n      ELSE\n        gs_mol =\u003e photosyns_inst % gs_mol_patch\n        an =\u003e photosyns_inst % an_patch\n      END IF\n    END IF\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      g = patch % gridcell(p)\n      co2(p) = forc_pco2(g)\n      DO iv = 1, nrad(p)\n        IF (par_z(p, iv) \u003c= 0._r8) THEN\n          alphapsn(p) = 1._r8\n        ELSE\n          ci = co2(p) - (an(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol(p, iv) + 1.6_r8 * gb_mol(p)) / (gb_mol(p) * gs_mol(p, iv)))\n          alphapsn(p) = 1._r8 + (((c3psn(patch % itype(p)) * (4.4_r8 + (22.6_r8 * (ci / co2(p))))) + ((1._r8 - c3psn(patch % itype(p))) * 4.4_r8)) / 1000._r8)\n        END IF\n      END DO\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE Fractionation"}, {"color": "#97c2fc", "id": "quadratic", "label": "quadratic", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "ci_func", "label": "ci_func", "shape": "dot", "size": 10, "source": "SUBROUTINE ci_func(ci, fval, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  REAL(KIND = r8), INTENT(IN) :: ci\n  REAL(KIND = r8), INTENT(IN) :: lmr_z\n  REAL(KIND = r8), INTENT(IN) :: par_z\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: je\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  INTEGER, INTENT(IN) :: p, iv, c\n  REAL(KIND = r8), INTENT(OUT) :: fval\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  REAL(KIND = r8) :: ai\n  REAL(KIND = r8) :: cs\n  REAL(KIND = r8) :: term\n  REAL(KIND = r8) :: aquad, bquad, cquad\n  REAL(KIND = r8) :: r1, r2\n  ASSOCIATE(forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, c3flag =\u003e photosyns_inst % c3flag_patch, ivt =\u003e patch % itype, medlynslope =\u003e pftcon % medlynslope, medlynintercept =\u003e pftcon % medlynintercept, stomatalcond_mtd =\u003e photosyns_inst % stomatalcond_mtd, ac =\u003e photosyns_inst % ac_patch, aj =\u003e photosyns_inst % aj_patch, ap =\u003e photosyns_inst % ap_patch, ag =\u003e photosyns_inst % ag_patch, an =\u003e photosyns_inst % an_patch, vcmax_z =\u003e photosyns_inst % vcmax_z_patch, cp =\u003e photosyns_inst % cp_patch, kc =\u003e photosyns_inst % kc_patch, ko =\u003e photosyns_inst % ko_patch, qe =\u003e photosyns_inst % qe_patch, tpu_z =\u003e photosyns_inst % tpu_z_patch, kp_z =\u003e photosyns_inst % kp_z_patch, bbb =\u003e photosyns_inst % bbb_patch, mbb =\u003e photosyns_inst % mbb_patch)\n    IF (c3flag(p)) THEN\n      ac(p, iv) = vcmax_z(p, iv) * MAX(ci - cp(p), 0._r8) / (ci + kc(p) * (1._r8 + oair / ko(p)))\n      aj(p, iv) = je * MAX(ci - cp(p), 0._r8) / (4._r8 * ci + 8._r8 * cp(p))\n      ap(p, iv) = 3._r8 * tpu_z(p, iv)\n    ELSE\n      ac(p, iv) = vcmax_z(p, iv)\n      aj(p, iv) = qe(p) * par_z * 4.6_r8\n      ap(p, iv) = kp_z(p, iv) * MAX(ci, 0._r8) / forc_pbot(c)\n    END IF\n    aquad = params_inst % theta_cj(ivt(p))\n    bquad = - (ac(p, iv) + aj(p, iv))\n    cquad = ac(p, iv) * aj(p, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ai = MIN(r1, r2)\n    aquad = params_inst % theta_ip\n    bquad = - (ai + ap(p, iv))\n    cquad = ai * ap(p, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ag(p, iv) = MAX(0._r8, MIN(r1, r2))\n    an(p, iv) = ag(p, iv) - lmr_z\n    IF (an(p, iv) \u003c 0._r8) THEN\n      fval = 0._r8\n      RETURN\n    END IF\n    cs = cair - 1.4_r8 / gb_mol * an(p, iv) * forc_pbot(c)\n    cs = MAX(cs, max_cs)\n    IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n      term = 1.6_r8 * an(p, iv) / (cs / forc_pbot(c) * 1.E06_r8)\n      aquad = 1.0_r8\n      bquad = - (2.0 * (medlynintercept(patch % itype(p)) * 1.E-06_r8 + term) + (medlynslope(patch % itype(p)) * term) ** 2 / (gb_mol * 1.E-06_r8 * rh_can))\n      cquad = medlynintercept(patch % itype(p)) * medlynintercept(patch % itype(p)) * 1.E-12_r8 + (2.0 * medlynintercept(patch % itype(p)) * 1.E-06_r8 + term * (1.0 - medlynslope(patch % itype(p)) * medlynslope(patch % itype(p)) / rh_can)) * term\n      CALL quadratic(aquad, bquad, cquad, r1, r2)\n      gs_mol = MAX(r1, r2) * 1.E06_r8\n    ELSE IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n      aquad = cs\n      bquad = cs * (gb_mol - bbb(p)) - mbb(p) * an(p, iv) * forc_pbot(c)\n      cquad = - gb_mol * (cs * bbb(p) + mbb(p) * an(p, iv) * forc_pbot(c) * rh_can)\n      CALL quadratic(aquad, bquad, cquad, r1, r2)\n      gs_mol = MAX(r1, r2)\n    END IF\n    fval = ci - cair + an(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol + 1.6_r8 * gb_mol) / (gb_mol * gs_mol)\n  END ASSOCIATE\nEND SUBROUTINE ci_func"}, {"color": "#97c2fc", "id": "ci_func_PHS", "label": "ci_func_PHS", "shape": "dot", "size": 10, "source": "SUBROUTINE ci_func_PHS(x, cisun, cisha, fvalsun, fvalsha, p, iv, c, bsun, bsha, bflag, gb_mol, gs0sun, gs0sha, gs_mol_sun, gs_mol_sha, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n  USE clm_varpar, ONLY: nlevsoi\n  IMPLICIT NONE\n  REAL(KIND = r8), INTENT(INOUT) :: x(nvegwcs)\n  REAL(KIND = r8), INTENT(IN) :: cisun, cisha\n  REAL(KIND = r8), INTENT(OUT) :: fvalsun, fvalsha\n  INTEGER, INTENT(IN) :: p, c, iv\n  REAL(KIND = r8), INTENT(INOUT) :: bsun\n  REAL(KIND = r8), INTENT(INOUT) :: bsha\n  LOGICAL, INTENT(IN) :: bflag\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: gs0sun, gs0sha\n  REAL(KIND = r8), INTENT(INOUT) :: gs_mol_sun, gs_mol_sha\n  REAL(KIND = r8), INTENT(IN) :: jesun, jesha\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  REAL(KIND = r8), INTENT(IN) :: lmr_z_sun, lmr_z_sha\n  REAL(KIND = r8), INTENT(IN) :: par_z_sun, par_z_sha\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  REAL(KIND = r8), INTENT(IN) :: qsatl\n  REAL(KIND = r8), INTENT(IN) :: qaf\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(waterdiagnosticbulk_type), INTENT(IN) :: waterdiagnosticbulk_inst\n  TYPE(waterfluxbulk_type), INTENT(IN) :: waterfluxbulk_inst\n  TYPE(soilstate_type), INTENT(IN) :: soilstate_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  REAL(KIND = r8) :: ai\n  REAL(KIND = r8) :: cs_sun, cs_sha\n  REAL(KIND = r8) :: aquad, bquad, cquad\n  REAL(KIND = r8) :: r1, r2\n  REAL(KIND = r8) :: term\n  ASSOCIATE(forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, c3flag =\u003e photosyns_inst % c3flag_patch, ivt =\u003e patch % itype, medlynslope =\u003e pftcon % medlynslope, medlynintercept =\u003e pftcon % medlynintercept, stomatalcond_mtd =\u003e photosyns_inst % stomatalcond_mtd, ac =\u003e photosyns_inst % ac_phs_patch, aj =\u003e photosyns_inst % aj_phs_patch, ap =\u003e photosyns_inst % ap_phs_patch, ag =\u003e photosyns_inst % ag_phs_patch, vcmax_z =\u003e photosyns_inst % vcmax_z_phs_patch, cp =\u003e photosyns_inst % cp_patch, kc =\u003e photosyns_inst % kc_patch, ko =\u003e photosyns_inst % ko_patch, qe =\u003e photosyns_inst % qe_patch, tpu_z =\u003e photosyns_inst % tpu_z_phs_patch, kp_z =\u003e photosyns_inst % kp_z_phs_patch, bbb =\u003e photosyns_inst % bbb_patch, mbb =\u003e photosyns_inst % mbb_patch, an_sun =\u003e photosyns_inst % an_sun_patch, an_sha =\u003e photosyns_inst % an_sha_patch)\n    IF (bflag) THEN\n      CALL calcstress(p, c, x, bsun, bsha, gb_mol, gs0sun, gs0sha, qsatl, qaf, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n    END IF\n    IF (c3flag(p)) THEN\n      ac(p, sun, iv) = bsun * vcmax_z(p, sun, iv) * MAX(cisun - cp(p), 0._r8) / (cisun + kc(p) * (1._r8 + oair / ko(p)))\n      ac(p, sha, iv) = bsha * vcmax_z(p, sha, iv) * MAX(cisha - cp(p), 0._r8) / (cisha + kc(p) * (1._r8 + oair / ko(p)))\n      aj(p, sun, iv) = jesun * MAX(cisun - cp(p), 0._r8) / (4._r8 * cisun + 8._r8 * cp(p))\n      aj(p, sha, iv) = jesha * MAX(cisha - cp(p), 0._r8) / (4._r8 * cisha + 8._r8 * cp(p))\n      ap(p, sun, iv) = 3._r8 * tpu_z(p, sun, iv)\n      ap(p, sha, iv) = 3._r8 * tpu_z(p, sha, iv)\n    ELSE\n      ac(p, sun, iv) = bsun * vcmax_z(p, sun, iv)\n      ac(p, sha, iv) = bsha * vcmax_z(p, sha, iv)\n      aj(p, sun, iv) = qe(p) * par_z_sun * 4.6_r8\n      aj(p, sha, iv) = qe(p) * par_z_sha * 4.6_r8\n      ap(p, sun, iv) = kp_z(p, sun, iv) * MAX(cisun, 0._r8) / forc_pbot(c)\n      ap(p, sha, iv) = kp_z(p, sha, iv) * MAX(cisha, 0._r8) / forc_pbot(c)\n    END IF\n    aquad = params_inst % theta_cj(ivt(p))\n    bquad = - (ac(p, sun, iv) + aj(p, sun, iv))\n    cquad = ac(p, sun, iv) * aj(p, sun, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ai = MIN(r1, r2)\n    aquad = params_inst % theta_ip\n    bquad = - (ai + ap(p, sun, iv))\n    cquad = ai * ap(p, sun, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ag(p, sun, iv) = MAX(0._r8, MIN(r1, r2))\n    aquad = params_inst % theta_cj(ivt(p))\n    bquad = - (ac(p, sha, iv) + aj(p, sha, iv))\n    cquad = ac(p, sha, iv) * aj(p, sha, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ai = MIN(r1, r2)\n    aquad = params_inst % theta_ip\n    bquad = - (ai + ap(p, sha, iv))\n    cquad = ai * ap(p, sha, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ag(p, sha, iv) = MAX(0._r8, MIN(r1, r2))\n    an_sun(p, iv) = ag(p, sun, iv) - bsun * lmr_z_sun\n    an_sha(p, iv) = ag(p, sha, iv) - bsha * lmr_z_sha\n    IF (an_sun(p, iv) \u003c 0._r8) THEN\n      IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n        gs_mol_sun = medlynintercept(patch % itype(p))\n      ELSE IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n        gs_mol_sun = bbb(p)\n      ELSE\n        gs_mol_sun = nan\n      END IF\n      gs_mol_sun = MAX(bsun * gs_mol_sun, 1._r8)\n      fvalsun = 0._r8\n    END IF\n    IF (an_sha(p, iv) \u003c 0._r8) THEN\n      IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n        gs_mol_sha = medlynintercept(patch % itype(p))\n      ELSE IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n        gs_mol_sha = bbb(p)\n      ELSE\n        gs_mol_sha = nan\n      END IF\n      gs_mol_sha = MAX(bsha * gs_mol_sha, 1._r8)\n      fvalsha = 0._r8\n    END IF\n    IF ((an_sun(p, iv) \u003c 0._r8) .AND. (an_sha(p, iv) \u003c 0._r8)) THEN\n      RETURN\n    END IF\n    IF (an_sun(p, iv) \u003e= 0._r8) THEN\n      cs_sun = cair - 1.4_r8 / gb_mol * an_sun(p, iv) * forc_pbot(c)\n      cs_sun = MAX(cs_sun, max_cs)\n    END IF\n    IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n      IF (an_sun(p, iv) \u003e= 0._r8) THEN\n        term = 1.6_r8 * an_sun(p, iv) / (cs_sun / forc_pbot(c) * 1.E06_r8)\n        aquad = 1.0_r8\n        bquad = - (2.0_r8 * (medlynintercept(patch % itype(p)) * 1.E-06_r8 + term) + (medlynslope(patch % itype(p)) * term) ** 2 / (gb_mol * 1.E-06_r8 * rh_can))\n        cquad = medlynintercept(patch % itype(p)) * medlynintercept(patch % itype(p)) * 1.E-12_r8 + (2.0_r8 * medlynintercept(patch % itype(p)) * 1.E-06_r8 + term * (1.0_r8 - medlynslope(patch % itype(p)) * medlynslope(patch % itype(p)) / rh_can)) * term\n        CALL quadratic(aquad, bquad, cquad, r1, r2)\n        gs_mol_sun = MAX(r1, r2) * 1.E06_r8\n      END IF\n      IF (an_sha(p, iv) \u003e= 0._r8) THEN\n        cs_sha = cair - 1.4_r8 / gb_mol * an_sha(p, iv) * forc_pbot(c)\n        cs_sha = MAX(cs_sha, max_cs)\n        term = 1.6_r8 * an_sha(p, iv) / (cs_sha / forc_pbot(c) * 1.E06_r8)\n        aquad = 1.0_r8\n        bquad = - (2.0_r8 * (medlynintercept(patch % itype(p)) * 1.E-06_r8 + term) + (medlynslope(patch % itype(p)) * term) ** 2 / (gb_mol * 1.E-06_r8 * rh_can))\n        cquad = medlynintercept(patch % itype(p)) * medlynintercept(patch % itype(p)) * 1.E-12_r8 + (2.0_r8 * medlynintercept(patch % itype(p)) * 1.E-06_r8 + term * (1.0 - medlynslope(patch % itype(p)) * medlynslope(patch % itype(p)) / rh_can)) * term\n        CALL quadratic(aquad, bquad, cquad, r1, r2)\n        gs_mol_sha = MAX(r1, r2) * 1.E06_r8\n      END IF\n    ELSE IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n      IF (an_sun(p, iv) \u003e= 0._r8) THEN\n        aquad = cs_sun\n        bquad = cs_sun * (gb_mol - MAX(bsun * bbb(p), 1._r8)) - mbb(p) * an_sun(p, iv) * forc_pbot(c)\n        cquad = - gb_mol * (cs_sun * MAX(bsun * bbb(p), 1._r8) + mbb(p) * an_sun(p, iv) * forc_pbot(c) * rh_can)\n        CALL quadratic(aquad, bquad, cquad, r1, r2)\n        gs_mol_sun = MAX(r1, r2)\n      END IF\n      IF (an_sha(p, iv) \u003e= 0._r8) THEN\n        cs_sha = cair - 1.4_r8 / gb_mol * an_sha(p, iv) * forc_pbot(c)\n        cs_sha = MAX(cs_sha, max_cs)\n        aquad = cs_sha\n        bquad = cs_sha * (gb_mol - MAX(bsha * bbb(p), 1._r8)) - mbb(p) * an_sha(p, iv) * forc_pbot(c)\n        cquad = - gb_mol * (cs_sha * MAX(bsha * bbb(p), 1._r8) + mbb(p) * an_sha(p, iv) * forc_pbot(c) * rh_can)\n        CALL quadratic(aquad, bquad, cquad, r1, r2)\n        gs_mol_sha = MAX(r1, r2)\n      END IF\n    END IF\n    IF (an_sun(p, iv) \u003e= 0._r8) THEN\n      IF (gs_mol_sun \u003e 0._r8) THEN\n        fvalsun = cisun - cair + an_sun(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol_sun + 1.6_r8 * gb_mol) / (gb_mol * gs_mol_sun)\n      ELSE\n        fvalsun = cisun - cair\n      END IF\n    END IF\n    IF (an_sha(p, iv) \u003e= 0._r8) THEN\n      IF (gs_mol_sha \u003e 0._r8) THEN\n        fvalsha = cisha - cair + an_sha(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol_sha + 1.6_r8 * gb_mol) / (gb_mol * gs_mol_sha)\n      ELSE\n        fvalsha = cisha - cair\n      END IF\n    END IF\n  END ASSOCIATE\nEND SUBROUTINE ci_func_PHS"}, {"color": "#97c2fc", "id": "hybrid", "label": "hybrid", "shape": "dot", "size": 10, "source": "SUBROUTINE hybrid(x0, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, iter, atm2lnd_inst, photosyns_inst)\n  IMPLICIT NONE\n  REAL(KIND = r8), INTENT(INOUT) :: x0\n  REAL(KIND = r8), INTENT(IN) :: lmr_z\n  REAL(KIND = r8), INTENT(IN) :: par_z\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: je\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  INTEGER, INTENT(IN) :: p, iv, c\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol\n  INTEGER, INTENT(OUT) :: iter\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  REAL(KIND = r8) :: a, b\n  REAL(KIND = r8) :: fa, fb\n  REAL(KIND = r8) :: x1, f0, f1\n  REAL(KIND = r8) :: x, dx\n  REAL(KIND = r8), PARAMETER :: eps = 1.E-2_r8\n  REAL(KIND = r8), PARAMETER :: eps1 = 1.E-4_r8\n  INTEGER, PARAMETER :: itmax = 40\n  REAL(KIND = r8) :: tol, minx, minf\n  CALL ci_func(x0, f0, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  IF (f0 == 0._r8) RETURN\n  minx = x0\n  minf = f0\n  x1 = x0 * 0.99_r8\n  CALL ci_func(x1, f1, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  IF (f1 == 0._r8) THEN\n    x0 = x1\n    RETURN\n  END IF\n  IF (f1 \u003c minf) THEN\n    minx = x1\n    minf = f1\n  END IF\n  iter = 0\n  DO\n    iter = iter + 1\n    dx = - f1 * (x1 - x0) / (f1 - f0)\n    x = x1 + dx\n    tol = ABS(x) * eps\n    IF (ABS(dx) \u003c tol) THEN\n      x0 = x\n      EXIT\n    END IF\n    x0 = x1\n    f0 = f1\n    x1 = x\n    CALL ci_func(x1, f1, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n    IF (f1 \u003c minf) THEN\n      minx = x1\n      minf = f1\n    END IF\n    IF (ABS(f1) \u003c= eps1) THEN\n      x0 = x1\n      EXIT\n    END IF\n    IF (f1 * f0 \u003c 0._r8) THEN\n      CALL brent(x, x0, x1, f0, f1, tol, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n      x0 = x\n      EXIT\n    END IF\n    IF (iter \u003e itmax) THEN\n      CALL ci_func(minx, f1, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n      EXIT\n    END IF\n  END DO\nEND SUBROUTINE hybrid"}, {"color": "#97c2fc", "id": "C14BombSpike", "label": "C14BombSpike", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "PhotosynthesisTotal", "label": "PhotosynthesisTotal", "shape": "dot", "size": 10, "source": "SUBROUTINE PhotosynthesisTotal(fn, filterp, atm2lnd_inst, canopystate_inst, photosyns_inst)\n  INTEGER, INTENT(IN) :: fn\n  INTEGER, INTENT(IN) :: filterp(fn)\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  INTEGER :: f, fp, p, l, g\n  REAL(KIND = r8) :: rc14_atm(nsectors_c14), rc13_atm\n  INTEGER :: sector_c14\n  ASSOCIATE(forc_pco2 =\u003e atm2lnd_inst % forc_pco2_grc, forc_pc13o2 =\u003e atm2lnd_inst % forc_pc13o2_grc, forc_po2 =\u003e atm2lnd_inst % forc_po2_grc, laisun =\u003e canopystate_inst % laisun_patch, laisha =\u003e canopystate_inst % laisha_patch, psnsun =\u003e photosyns_inst % psnsun_patch, psnsha =\u003e photosyns_inst % psnsha_patch, rc13_canair =\u003e photosyns_inst % rc13_canair_patch, rc13_psnsun =\u003e photosyns_inst % rc13_psnsun_patch, rc13_psnsha =\u003e photosyns_inst % rc13_psnsha_patch, alphapsnsun =\u003e photosyns_inst % alphapsnsun_patch, alphapsnsha =\u003e photosyns_inst % alphapsnsha_patch, psnsun_wc =\u003e photosyns_inst % psnsun_wc_patch, psnsun_wj =\u003e photosyns_inst % psnsun_wj_patch, psnsun_wp =\u003e photosyns_inst % psnsun_wp_patch, psnsha_wc =\u003e photosyns_inst % psnsha_wc_patch, psnsha_wj =\u003e photosyns_inst % psnsha_wj_patch, psnsha_wp =\u003e photosyns_inst % psnsha_wp_patch, c13_psnsun =\u003e photosyns_inst % c13_psnsun_patch, c13_psnsha =\u003e photosyns_inst % c13_psnsha_patch, c14_psnsun =\u003e photosyns_inst % c14_psnsun_patch, c14_psnsha =\u003e photosyns_inst % c14_psnsha_patch, fpsn =\u003e photosyns_inst % fpsn_patch, fpsn_wc =\u003e photosyns_inst % fpsn_wc_patch, fpsn_wj =\u003e photosyns_inst % fpsn_wj_patch, fpsn_wp =\u003e photosyns_inst % fpsn_wp_patch)\n    IF (use_c14) THEN\n      IF (use_c14_bombspike) THEN\n        CALL C14BombSpike(rc14_atm)\n      ELSE\n        rc14_atm(:) = c14ratio\n      END IF\n    END IF\n    IF (use_c13) THEN\n      IF (use_c13_timeseries) THEN\n        CALL C13TimeSeries(rc13_atm)\n      END IF\n    END IF\n    DO f = 1, fn\n      p = filterp(f)\n      g = patch % gridcell(p)\n      IF (.NOT. use_fates) THEN\n        fpsn(p) = psnsun(p) * laisun(p) + psnsha(p) * laisha(p)\n        fpsn_wc(p) = psnsun_wc(p) * laisun(p) + psnsha_wc(p) * laisha(p)\n        fpsn_wj(p) = psnsun_wj(p) * laisun(p) + psnsha_wj(p) * laisha(p)\n        fpsn_wp(p) = psnsun_wp(p) * laisun(p) + psnsha_wp(p) * laisha(p)\n      END IF\n      IF (use_cn) THEN\n        IF (use_c13) THEN\n          IF (use_c13_timeseries) THEN\n            rc13_canair(p) = rc13_atm\n          ELSE\n            rc13_canair(p) = forc_pc13o2(g) / (forc_pco2(g) - forc_pc13o2(g))\n          END IF\n          rc13_psnsun(p) = rc13_canair(p) / alphapsnsun(p)\n          rc13_psnsha(p) = rc13_canair(p) / alphapsnsha(p)\n          c13_psnsun(p) = psnsun(p) * (rc13_psnsun(p) / (1._r8 + rc13_psnsun(p)))\n          c13_psnsha(p) = psnsha(p) * (rc13_psnsha(p) / (1._r8 + rc13_psnsha(p)))\n        END IF\n        IF (use_c14) THEN\n          IF (grc % latdeg(g) .GE. 30._r8) THEN\n            sector_c14 = 1\n          ELSE IF (grc % latdeg(g) .GE. - 30._r8) THEN\n            sector_c14 = 2\n          ELSE\n            sector_c14 = 3\n          END IF\n          c14_psnsun(p) = rc14_atm(sector_c14) * psnsun(p)\n          c14_psnsha(p) = rc14_atm(sector_c14) * psnsha(p)\n        END IF\n      END IF\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE PhotosynthesisTotal"}, {"color": "#97c2fc", "id": "C13TimeSeries", "label": "C13TimeSeries", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "calcstress", "label": "calcstress", "shape": "dot", "size": 10, "source": "SUBROUTINE calcstress(p, c, x, bsun, bsha, gb_mol, gs_mol_sun, gs_mol_sha, qsatl, qaf, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n  USE clm_varpar, ONLY: nlevsoi\n  USE clm_varcon, ONLY: rgas\n  USE clm_time_manager, ONLY: get_local_time\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: c\n  REAL(KIND = r8), INTENT(INOUT) :: x(nvegwcs)\n  REAL(KIND = r8), INTENT(OUT) :: bsun\n  REAL(KIND = r8), INTENT(OUT) :: bsha\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: gs_mol_sun\n  REAL(KIND = r8), INTENT(IN) :: gs_mol_sha\n  REAL(KIND = r8), INTENT(IN) :: qsatl\n  REAL(KIND = r8), INTENT(IN) :: qaf\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(waterdiagnosticbulk_type), INTENT(IN) :: waterdiagnosticbulk_inst\n  TYPE(soilstate_type), INTENT(IN) :: soilstate_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  TYPE(waterfluxbulk_type), INTENT(IN) :: waterfluxbulk_inst\n  REAL(KIND = r8) :: wtl\n  REAL(KIND = r8) :: A(nvegwcs, nvegwcs)\n  REAL(KIND = r8) :: f(nvegwcs)\n  REAL(KIND = r8) :: dx(nvegwcs)\n  REAL(KIND = r8) :: efpot\n  REAL(KIND = r8) :: rppdry_sun\n  REAL(KIND = r8) :: rppdry_sha\n  REAL(KIND = r8) :: qflx_sun\n  REAL(KIND = r8) :: qflx_sha\n  REAL(KIND = r8) :: gs0sun, gs0sha\n  REAL(KIND = r8) :: qsun, qsha\n  INTEGER :: j\n  INTEGER :: g\n  REAL(KIND = r8) :: cf\n  INTEGER :: iter\n  LOGICAL :: flag\n  LOGICAL :: night\n  INTEGER, PARAMETER :: itmax = 50\n  REAL(KIND = r8), PARAMETER :: tolf = 1.E-6_r8, toldx = 1.E-9_r8\n  LOGICAL :: havegs\n  REAL(KIND = r8) :: soilflux\n  REAL(KIND = r8), PARAMETER :: tol_lai = .001_r8\n  ASSOCIATE(laisun =\u003e canopystate_inst % laisun_patch, laisha =\u003e canopystate_inst % laisha_patch, elai =\u003e canopystate_inst % elai_patch, esai =\u003e canopystate_inst % esai_patch, tsai =\u003e canopystate_inst % tsai_patch, fdry =\u003e waterdiagnosticbulk_inst % fdry_patch, forc_rho =\u003e atm2lnd_inst % forc_rho_downscaled_col, forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, tgcm =\u003e temperature_inst % thm_patch, bsw =\u003e soilstate_inst % bsw_col, qflx_tran_veg =\u003e waterfluxbulk_inst % qflx_tran_veg_patch, vegwp_pd =\u003e canopystate_inst % vegwp_pd_patch, sucsat =\u003e soilstate_inst % sucsat_col)\n    IF (x(sun) \u003e 0._r8) THEN\n      night = .TRUE.\n      x(sun) = x(sha)\n    ELSE\n      night = .FALSE.\n    END IF\n    gs0sun = gs_mol_sun\n    gs0sha = gs_mol_sha\n    havegs = .TRUE.\n    CALL getqflx(p, c, gb_mol, gs0sun, gs0sha, qflx_sun, qflx_sha, qsatl, qaf, havegs, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, temperature_inst)\n    IF ((laisun(p) \u003e tol_lai .OR. laisha(p) \u003e tol_lai) .AND. (qflx_sun \u003e 0._r8 .OR. qflx_sha \u003e 0._r8)) THEN\n      iter = 0\n      DO\n        iter = iter + 1\n        CALL spacF(p, c, x, f, qflx_sun, qflx_sha, atm2lnd_inst, canopystate_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n        IF (SQRT(SUM(f * f)) \u003c tolf * (qflx_sun + qflx_sha)) THEN\n          flag = .FALSE.\n          EXIT\n        END IF\n        IF (iter \u003e itmax) THEN\n          flag = .FALSE.\n          EXIT\n        END IF\n        CALL spacA(p, c, x, A, qflx_sun, qflx_sha, flag, atm2lnd_inst, canopystate_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n        IF (flag) THEN\n          EXIT\n        END IF\n        IF (laisun(p) \u003e tol_lai .AND. laisha(p) \u003e tol_lai) THEN\n          dx = MATMUL(A, f)\n        ELSE\n          dx(sun) = 0._r8\n          dx(sha : root) = MATMUL(A(sha : root, sha : root), f(sha : root))\n        END IF\n        IF (MAXVAL(ABS(dx)) \u003e 50000._r8) THEN\n          dx = 50000._r8 * dx / MAXVAL(ABS(dx))\n        END IF\n        IF (laisun(p) \u003e tol_lai .AND. laisha(p) \u003e tol_lai) THEN\n          x = x + dx\n        ELSE IF (laisha(p) \u003e tol_lai) THEN\n          x = x + dx\n          x(sun) = x(xyl)\n        ELSE\n          x(xyl : root) = x(xyl : root) + dx(xyl : root)\n          x(sun) = x(sun) + dx(sha)\n          x(sha) = x(xyl)\n        END IF\n        IF (SQRT(SUM(dx * dx)) \u003c toldx) THEN\n          EXIT\n        END IF\n        IF (x(xyl) \u003e x(root)) x(xyl) = x(root)\n        IF (x(sun) \u003e x(xyl)) x(sun) = x(xyl)\n        IF (x(sha) \u003e x(xyl)) x(sha) = x(xyl)\n      END DO\n    ELSE\n      flag = .TRUE.\n    END IF\n    IF (flag) THEN\n      CALL getvegwp(p, c, x, gb_mol, gs0sun, gs0sha, qsatl, qaf, soilflux, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst)\n      bsun = plc(x(sun), p, sun, veg)\n      bsha = plc(x(sha), p, sha, veg)\n    ELSE\n      qsun = qflx_sun * plc(x(sun), p, sun, veg)\n      qsha = qflx_sha * plc(x(sha), p, sha, veg)\n      havegs = .FALSE.\n      CALL getqflx(p, c, gb_mol, gs0sun, gs0sha, qsun, qsha, qsatl, qaf, havegs, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, temperature_inst)\n      IF (qflx_sun \u003e 0._r8) THEN\n        bsun = gs0sun / gs_mol_sun\n      ELSE\n        bsun = plc(x(sun), p, sun, veg)\n      END IF\n      IF (qflx_sha \u003e 0._r8) THEN\n        bsha = gs0sha / gs_mol_sha\n      ELSE\n        bsha = plc(x(sha), p, sha, veg)\n      END IF\n    END IF\n    IF (bsun \u003c 0.01_r8) bsun = 0._r8\n    IF (bsha \u003c 0.01_r8) bsha = 0._r8\n    IF (night) THEN\n      gs0sun = bsun * gs_mol_sun\n      gs0sha = bsha * gs_mol_sha\n      CALL getvegwp(p, c, x, gb_mol, gs0sun, gs0sha, qsatl, qaf, soilflux, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst)\n      IF (soilflux \u003c 0._r8) soilflux = 0._r8\n      qflx_tran_veg(p) = soilflux\n    END IF\n    g = patch % gridcell(p)\n    IF (night .AND. get_local_time(grc % londeg(g)) \u003c (isecspday / 2)) THEN\n      vegwp_pd(p, :) = x\n    ELSE\n      vegwp_pd(p, :) = spval\n    END IF\n  END ASSOCIATE\nEND SUBROUTINE calcstress"}, {"color": "#97c2fc", "id": "hybrid_PHS", "label": "hybrid_PHS", "shape": "dot", "size": 10, "source": "SUBROUTINE hybrid_PHS(x0sun, x0sha, p, iv, c, g, gb_mol, bsun, bsha, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, gs_mol_sun, gs_mol_sha, qsatl, qaf, iter1, iter2, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n  USE clm_time_manager, ONLY: is_near_local_noon\n  IMPLICIT NONE\n  REAL(KIND = r8), INTENT(INOUT) :: x0sun, x0sha\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: iv\n  INTEGER, INTENT(IN) :: c\n  INTEGER, INTENT(IN) :: g\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(OUT) :: bsun\n  REAL(KIND = r8), INTENT(OUT) :: bsha\n  REAL(KIND = r8), INTENT(IN) :: jesun\n  REAL(KIND = r8), INTENT(IN) :: jesha\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  REAL(KIND = r8), INTENT(IN) :: lmr_z_sun\n  REAL(KIND = r8), INTENT(IN) :: lmr_z_sha\n  REAL(KIND = r8), INTENT(IN) :: par_z_sun\n  REAL(KIND = r8), INTENT(IN) :: par_z_sha\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol_sun\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol_sha\n  REAL(KIND = r8), INTENT(IN) :: qsatl\n  REAL(KIND = r8), INTENT(IN) :: qaf\n  INTEGER, INTENT(OUT) :: iter1\n  INTEGER, INTENT(OUT) :: iter2\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  TYPE(canopystate_type), INTENT(INOUT) :: canopystate_inst\n  TYPE(waterdiagnosticbulk_type), INTENT(INOUT) :: waterdiagnosticbulk_inst\n  TYPE(waterfluxbulk_type), INTENT(INOUT) :: waterfluxbulk_inst\n  TYPE(soilstate_type), INTENT(INOUT) :: soilstate_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  REAL(KIND = r8) :: x(nvegwcs)\n  REAL(KIND = r8) :: gs0sun\n  REAL(KIND = r8) :: gs0sha\n  LOGICAL :: havegs\n  REAL(KIND = r8) :: soilflux\n  REAL(KIND = r8) :: x1sun\n  REAL(KIND = r8) :: f0sun\n  REAL(KIND = r8) :: f1sun\n  REAL(KIND = r8) :: xsun\n  REAL(KIND = r8) :: dxsun\n  REAL(KIND = r8) :: x1sha\n  REAL(KIND = r8) :: f0sha\n  REAL(KIND = r8) :: f1sha\n  REAL(KIND = r8) :: xsha\n  REAL(KIND = r8) :: dxsha\n  REAL(KIND = r8) :: b0sun\n  REAL(KIND = r8) :: b0sha\n  REAL(KIND = r8) :: dbsun\n  REAL(KIND = r8) :: dbsha\n  LOGICAL :: bflag\n  REAL(KIND = r8) :: tolsun\n  REAL(KIND = r8) :: tolsha\n  REAL(KIND = r8) :: minf\n  REAL(KIND = r8) :: minxsun\n  REAL(KIND = r8) :: minxsha\n  REAL(KIND = r8), PARAMETER :: toldb = 1.E-2_r8\n  REAL(KIND = r8), PARAMETER :: eps = 1.E-2_r8\n  REAL(KIND = r8), PARAMETER :: eps1 = 1.E-4_r8\n  INTEGER, PARAMETER :: itmax = 3\n  ASSOCIATE(qflx_tran_veg =\u003e waterfluxbulk_inst % qflx_tran_veg_patch, vegwp =\u003e canopystate_inst % vegwp_patch, vegwp_ln =\u003e canopystate_inst % vegwp_ln_patch)\n    x1sun = x0sun\n    x1sha = x0sha\n    bflag = .FALSE.\n    b0sun = - 1._r8\n    b0sha = - 1._r8\n    gs0sun = 0._r8\n    gs0sha = 0._r8\n    bsun = 1._r8\n    bsha = 1._r8\n    iter1 = 0\n    DO\n      x = vegwp(p, :)\n      iter1 = iter1 + 1\n      iter2 = 0\n      x0sun = MAX(0.1_r8, x1sun)\n      x1sun = 0.99_r8 * x1sun\n      x0sha = MAX(0.1_r8, x1sha)\n      x1sha = 0.99_r8 * x1sha\n      tolsun = ABS(x1sun) * eps\n      tolsha = ABS(x1sha) * eps\n      CALL ci_func_PHS(x, x0sun, x0sha, f0sun, f0sha, p, iv, c, bsun, bsha, bflag, gb_mol, gs0sun, gs0sha, gs_mol_sun, gs_mol_sha, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n      dbsun = b0sun - bsun\n      dbsha = b0sha - bsha\n      b0sun = bsun\n      b0sha = bsha\n      bflag = .FALSE.\n      CALL ci_func_PHS(x, x1sun, x1sha, f1sun, f1sha, p, iv, c, bsun, bsha, bflag, gb_mol, gs0sun, gs0sha, gs_mol_sun, gs_mol_sha, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n      DO\n        IF ((ABS(f0sun) \u003c eps1) .AND. (ABS(f0sha) \u003c eps1)) THEN\n          x1sun = x0sun\n          x1sha = x0sha\n          EXIT\n        END IF\n        IF ((ABS(f1sun) \u003c eps1) .AND. (ABS(f1sha) \u003c eps1)) THEN\n          EXIT\n        END IF\n        iter2 = iter2 + 1\n        IF ((f1sun - f0sun) == 0._r8) THEN\n          dxsun = 0.5_r8 * (x1sun + x0sun) - x1sun\n        ELSE\n          dxsun = - f1sun * (x1sun - x0sun) / (f1sun - f0sun)\n        END IF\n        IF ((f1sha - f0sha) == 0._r8) THEN\n          dxsha = 0.5_r8 * (x1sha + x0sha) - x1sha\n        ELSE\n          dxsha = - f1sha * (x1sha - x0sha) / (f1sha - f0sha)\n        END IF\n        x0sun = x1sun\n        x1sun = x1sun + dxsun\n        x0sha = x1sha\n        x1sha = x1sha + dxsha\n        CALL ci_func_PHS(x, x1sun, x1sha, f1sun, f1sha, p, iv, c, bsun, bsha, bflag, gb_mol, gs0sun, gs0sha, gs_mol_sun, gs_mol_sha, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n        IF ((ABS(dxsun) \u003c tolsun) .AND. (ABS(dxsha) \u003c tolsha)) THEN\n          x0sun = x1sun\n          x0sha = x1sha\n          EXIT\n        END IF\n        IF (iter2 .EQ. 1) THEN\n          minf = ABS(f1sun + f1sha)\n          minxsun = x1sun\n          minxsha = x1sha\n        ELSE\n          IF (ABS(f1sun + f1sha) \u003c minf) THEN\n            minf = ABS(f1sun + f1sha)\n            minxsun = x1sun\n            minxsha = x1sha\n          END IF\n        END IF\n        IF ((ABS(f1sun) \u003c eps1) .AND. (ABS(f1sha) \u003c eps1)) THEN\n          EXIT\n        END IF\n        IF ((f1sun * f0sun \u003c 0._r8) .AND. (f1sha * f0sha \u003c 0._r8)) THEN\n          CALL brent_PHS(xsun, x0sun, x1sun, f0sun, f1sun, xsha, x0sha, x1sha, f0sha, f1sha, tolsun, p, iv, c, gb_mol, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, gs_mol_sun, gs_mol_sha, bsun, bsha, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n          x0sun = xsun\n          x0sha = xsha\n          EXIT\n        END IF\n        IF (iter2 \u003e itmax) THEN\n          x1sun = minxsun\n          x1sha = minxsha\n          CALL ci_func_PHS(x, x1sun, x1sha, f1sun, f1sha, p, iv, c, bsun, bsha, bflag, gb_mol, gs0sun, gs0sha, gs_mol_sun, gs_mol_sha, jesun, jesha, cair, oair, lmr_z_sun, lmr_z_sha, par_z_sun, par_z_sha, rh_can, qsatl, qaf, atm2lnd_inst, photosyns_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n          EXIT\n        END IF\n      END DO\n      IF (bsun \u003e 0.01_r8) THEN\n        gs0sun = gs_mol_sun / bsun\n      END IF\n      IF (bsha \u003e 0.01_r8) THEN\n        gs0sha = gs_mol_sha / bsha\n      END IF\n      bflag = .TRUE.\n      IF ((ABS(dbsun) \u003c toldb) .AND. (ABS(dbsha) \u003c toldb)) THEN\n        EXIT\n      END IF\n      IF (iter1 \u003e itmax) THEN\n        EXIT\n      END IF\n    END DO\n    x0sun = x1sun\n    x0sha = x1sha\n    CALL getvegwp(p, c, x, gb_mol, gs_mol_sun, gs_mol_sha, qsatl, qaf, soilflux, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst)\n    vegwp(p, :) = x\n    IF (is_near_local_noon(grc % londeg(g), deltasec = 3600)) THEN\n      vegwp_ln(p, :) = vegwp(p, :)\n    ELSE\n      vegwp_ln(p, :) = spval\n    END IF\n    IF (soilflux \u003c 0._r8) soilflux = 0._r8\n    qflx_tran_veg(p) = soilflux\n  END ASSOCIATE\nEND SUBROUTINE hybrid_PHS"}, {"color": "#97c2fc", "id": "getvegwp", "label": "getvegwp", "shape": "dot", "size": 10, "source": "SUBROUTINE getvegwp(p, c, x, gb_mol, gs_mol_sun, gs_mol_sha, qsatl, qaf, soilflux, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, soilstate_inst, temperature_inst)\n  USE clm_varpar, ONLY: nlevsoi\n  USE ColumnType, ONLY: col\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: c\n  REAL(KIND = r8), INTENT(OUT) :: x(nvegwcs)\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(INOUT) :: gs_mol_sun\n  REAL(KIND = r8), INTENT(INOUT) :: gs_mol_sha\n  REAL(KIND = r8), INTENT(IN) :: qsatl\n  REAL(KIND = r8), INTENT(IN) :: qaf\n  REAL(KIND = r8), INTENT(OUT) :: soilflux\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(waterdiagnosticbulk_type), INTENT(IN) :: waterdiagnosticbulk_inst\n  TYPE(soilstate_type), INTENT(IN) :: soilstate_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  REAL(KIND = r8) :: qflx_sun\n  REAL(KIND = r8) :: qflx_sha\n  REAL(KIND = r8) :: fx\n  REAL(KIND = r8) :: fr\n  REAL(KIND = r8) :: grav1\n  REAL(KIND = r8) :: grav2(nlevsoi)\n  INTEGER :: j\n  LOGICAL :: havegs\n  ASSOCIATE(k_soil_root =\u003e soilstate_inst % k_soil_root_patch, laisun =\u003e canopystate_inst % laisun_patch, laisha =\u003e canopystate_inst % laisha_patch, htop =\u003e canopystate_inst % htop_patch, tsai =\u003e canopystate_inst % tsai_patch, smp =\u003e soilstate_inst % smp_l_col, rootfr =\u003e soilstate_inst % rootfr_patch, bsw =\u003e soilstate_inst % bsw_col, ivt =\u003e patch % itype, hk_l =\u003e soilstate_inst % hk_l_col, hksat =\u003e soilstate_inst % hksat_col, sucsat =\u003e soilstate_inst % sucsat_col, z =\u003e col % z)\n    grav1 = 1000._r8 * htop(p)\n    grav2(1 : nlevsoi) = 1000._r8 * z(c, 1 : nlevsoi)\n    havegs = .TRUE.\n    CALL getqflx(p, c, gb_mol, gs_mol_sun, gs_mol_sha, qflx_sun, qflx_sha, qsatl, qaf, havegs, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, temperature_inst)\n    IF (ABS(SUM(k_soil_root(p, 1 : nlevsoi))) == 0._r8) THEN\n      x(root) = SUM(smp(c, 1 : nlevsoi) - grav2) / nlevsoi\n    ELSE\n      x(root) = (SUM(k_soil_root(p, 1 : nlevsoi) * (smp(c, 1 : nlevsoi) - grav2)) - qflx_sun - qflx_sha) / SUM(k_soil_root(p, 1 : nlevsoi))\n    END IF\n    fr = plc(x(root), p, root, veg)\n    IF ((tsai(p) \u003e 0._r8) .AND. (fr \u003e 0._r8)) THEN\n      x(xyl) = x(root) - grav1 - (qflx_sun + qflx_sha) / (fr * params_inst % kmax(ivt(p), root) / htop(p) * tsai(p))\n    ELSE\n      x(xyl) = x(root) - grav1\n    END IF\n    fx = plc(x(xyl), p, xyl, veg)\n    IF ((laisha(p) \u003e 0._r8) .AND. (fx \u003e 0._r8)) THEN\n      x(sha) = x(xyl) - (qflx_sha / (fx * params_inst % kmax(ivt(p), xyl) * laisha(p)))\n    ELSE\n      x(sha) = x(xyl)\n    END IF\n    IF ((laisun(p) \u003e 0._r8) .AND. (fx \u003e 0._r8)) THEN\n      x(sun) = x(xyl) - (qflx_sun / (fx * params_inst % kmax(ivt(p), xyl) * laisun(p)))\n    ELSE\n      x(sun) = x(xyl)\n    END IF\n    soilflux = 0._r8\n    DO j = 1, nlevsoi\n      soilflux = soilflux + k_soil_root(p, j) * (smp(c, j) - x(root) - grav2(j))\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE getvegwp"}, {"color": "#97c2fc", "id": "getqflx", "label": "getqflx", "shape": "dot", "size": 10, "source": "SUBROUTINE getqflx(p, c, gb_mol, gs_mol_sun, gs_mol_sha, qflx_sun, qflx_sha, qsatl, qaf, havegs, atm2lnd_inst, canopystate_inst, waterdiagnosticbulk_inst, temperature_inst)\n  USE clm_varcon, ONLY: rgas\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: c\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(INOUT) :: gs_mol_sun\n  REAL(KIND = r8), INTENT(INOUT) :: gs_mol_sha\n  REAL(KIND = r8), INTENT(INOUT) :: qflx_sun\n  REAL(KIND = r8), INTENT(INOUT) :: qflx_sha\n  REAL(KIND = r8), INTENT(IN) :: qsatl\n  REAL(KIND = r8), INTENT(IN) :: qaf\n  LOGICAL, INTENT(IN) :: havegs\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(waterdiagnosticbulk_type), INTENT(IN) :: waterdiagnosticbulk_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  REAL(KIND = r8) :: wtl\n  REAL(KIND = r8) :: efpot\n  REAL(KIND = r8) :: rppdry_sun\n  REAL(KIND = r8) :: rppdry_sha\n  REAL(KIND = r8) :: cf\n  ASSOCIATE(laisun =\u003e canopystate_inst % laisun_patch, laisha =\u003e canopystate_inst % laisha_patch, elai =\u003e canopystate_inst % elai_patch, esai =\u003e canopystate_inst % esai_patch, fdry =\u003e waterdiagnosticbulk_inst % fdry_patch, forc_rho =\u003e atm2lnd_inst % forc_rho_downscaled_col, forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, tgcm =\u003e temperature_inst % thm_patch)\n    cf = forc_pbot(c) / (rgas * 1.E-3_r8 * tgcm(p)) * 1.E6_r8\n    wtl = (elai(p) + esai(p)) * gb_mol\n    efpot = forc_rho(c) * wtl * (qsatl - qaf)\n    IF (havegs) THEN\n      IF ((efpot \u003e 0._r8) .AND. (elai(p) \u003e 0._r8)) THEN\n        IF (gs_mol_sun \u003e 0._r8) THEN\n          rppdry_sun = fdry(p) / gb_mol * (laisun(p) / (1._r8 / gb_mol + 1._r8 / gs_mol_sun)) / elai(p)\n          qflx_sun = efpot * rppdry_sun / cf\n        ELSE\n          qflx_sun = 0._r8\n        END IF\n        IF (gs_mol_sha \u003e 0._r8) THEN\n          rppdry_sha = fdry(p) / gb_mol * (laisha(p) / (1._r8 / gb_mol + 1._r8 / gs_mol_sha)) / elai(p)\n          qflx_sha = efpot * rppdry_sha / cf\n        ELSE\n          qflx_sha = 0._r8\n        END IF\n      ELSE\n        qflx_sun = 0._r8\n        qflx_sha = 0._r8\n      END IF\n    ELSE\n      IF (qflx_sun \u003e 0._r8) THEN\n        gs_mol_sun = gb_mol * qflx_sun * cf * elai(p) / (efpot * fdry(p) * laisun(p) - qflx_sun * cf * elai(p))\n      ELSE\n        gs_mol_sun = 0._r8\n      END IF\n      IF (qflx_sha \u003e 0._r8) THEN\n        gs_mol_sha = gb_mol * qflx_sha * cf * elai(p) / (efpot * fdry(p) * laisha(p) - qflx_sha * cf * elai(p))\n      ELSE\n        gs_mol_sha = 0._r8\n      END IF\n    END IF\n  END ASSOCIATE\nEND SUBROUTINE getqflx"}, {"color": "#97c2fc", "id": "spacF", "label": "spacF", "shape": "dot", "size": 10, "source": "SUBROUTINE spacF(p, c, x, f, qflx_sun, qflx_sha, atm2lnd_inst, canopystate_inst, soilstate_inst, temperature_inst, waterfluxbulk_inst)\n  USE clm_varpar, ONLY: nlevsoi\n  USE clm_varcon, ONLY: rgas\n  USE ColumnType, ONLY: col\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: c\n  REAL(KIND = r8), INTENT(IN) :: x(nvegwcs)\n  REAL(KIND = r8), INTENT(OUT) :: f(nvegwcs)\n  REAL(KIND = r8), INTENT(IN) :: qflx_sun\n  REAL(KIND = r8), INTENT(IN) :: qflx_sha\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(soilstate_type), INTENT(IN) :: soilstate_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  TYPE(waterfluxbulk_type), INTENT(IN) :: waterfluxbulk_inst\n  REAL(KIND = r8) :: wtl\n  REAL(KIND = r8) :: fsto1\n  REAL(KIND = r8) :: fsto2\n  REAL(KIND = r8) :: fx\n  REAL(KIND = r8) :: fr\n  REAL(KIND = r8) :: grav1\n  REAL(KIND = r8) :: grav2(nlevsoi)\n  REAL(KIND = r8) :: temp\n  REAL(KIND = r8), PARAMETER :: tol_lai = .001_r8\n  INTEGER :: j\n  ASSOCIATE(k_soil_root =\u003e soilstate_inst % k_soil_root_patch, laisun =\u003e canopystate_inst % laisun_patch, laisha =\u003e canopystate_inst % laisha_patch, htop =\u003e canopystate_inst % htop_patch, tsai =\u003e canopystate_inst % tsai_patch, smp =\u003e soilstate_inst % smp_l_col, ivt =\u003e patch % itype, z =\u003e col % z)\n    grav1 = htop(p) * 1000._r8\n    grav2(1 : nlevsoi) = z(c, 1 : nlevsoi) * 1000._r8\n    fsto1 = plc(x(sun), p, sun, veg)\n    fsto2 = plc(x(sha), p, sha, veg)\n    fx = plc(x(xyl), p, xyl, veg)\n    fr = plc(x(root), p, root, veg)\n    f(sun) = qflx_sun * fsto1 - laisun(p) * params_inst % kmax(ivt(p), sun) * fx * (x(xyl) - x(sun))\n    f(sha) = qflx_sha * fsto2 - laisha(p) * params_inst % kmax(ivt(p), sha) * fx * (x(xyl) - x(sha))\n    f(xyl) = laisun(p) * params_inst % kmax(ivt(p), sun) * fx * (x(xyl) - x(sun)) + laisha(p) * params_inst % kmax(ivt(p), sha) * fx * (x(xyl) - x(sha)) - tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * fr * (x(root) - x(xyl) - grav1)\n    f(root) = tsai(p) * params_inst % kmax(ivt(p), xyl) / htop(p) * fr * (x(root) - x(xyl) - grav1) + SUM(k_soil_root(p, 1 : nlevsoi) * (x(root) + grav2(1 : nlevsoi))) - SUM(k_soil_root(p, 1 : nlevsoi) * smp(c, 1 : nlevsoi))\n    IF (laisha(p) \u003c tol_lai) THEN\n      temp = f(sun)\n      f(sun) = f(sha)\n      f(sha) = temp\n    END IF\n  END ASSOCIATE\nEND SUBROUTINE spacF"}, {"color": "#97c2fc", "id": "InitAllocate", "label": "InitAllocate", "shape": "dot", "size": 10, "source": "SUBROUTINE InitAllocate(this, bounds)\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER :: begp, endp\n  INTEGER :: begc, endc\n  begp = bounds % begp\n  endp = bounds % endp\n  begc = bounds % begc\n  endc = bounds % endc\n  ALLOCATE(this % c3flag_patch(begp : endp))\n  this % c3flag_patch(:) = .FALSE.\n  ALLOCATE(this % ac_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % ac_phs_patch(:, :, :) = nan\n  ALLOCATE(this % aj_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % aj_phs_patch(:, :, :) = nan\n  ALLOCATE(this % ap_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % ap_phs_patch(:, :, :) = nan\n  ALLOCATE(this % ag_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % ag_phs_patch(:, :, :) = nan\n  ALLOCATE(this % an_sun_patch(begp : endp, 1 : nlevcan))\n  this % an_sun_patch(:, :) = nan\n  ALLOCATE(this % an_sha_patch(begp : endp, 1 : nlevcan))\n  this % an_sha_patch(:, :) = nan\n  ALLOCATE(this % vcmax_z_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % vcmax_z_phs_patch(:, :, :) = nan\n  ALLOCATE(this % tpu_z_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % tpu_z_phs_patch(:, :, :) = nan\n  ALLOCATE(this % kp_z_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % kp_z_phs_patch(:, :, :) = nan\n  ALLOCATE(this % gs_mol_sun_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sun_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_sha_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sha_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_sun_ln_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sun_ln_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_sha_ln_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sha_ln_patch(:, :) = nan\n  ALLOCATE(this % ac_patch(begp : endp, 1 : nlevcan))\n  this % ac_patch(:, :) = nan\n  ALLOCATE(this % aj_patch(begp : endp, 1 : nlevcan))\n  this % aj_patch(:, :) = nan\n  ALLOCATE(this % ap_patch(begp : endp, 1 : nlevcan))\n  this % ap_patch(:, :) = nan\n  ALLOCATE(this % ag_patch(begp : endp, 1 : nlevcan))\n  this % ag_patch(:, :) = nan\n  ALLOCATE(this % an_patch(begp : endp, 1 : nlevcan))\n  this % an_patch(:, :) = nan\n  ALLOCATE(this % vcmax_z_patch(begp : endp, 1 : nlevcan))\n  this % vcmax_z_patch(:, :) = nan\n  ALLOCATE(this % tpu_z_patch(begp : endp, 1 : nlevcan))\n  this % tpu_z_patch(:, :) = nan\n  ALLOCATE(this % kp_z_patch(begp : endp, 1 : nlevcan))\n  this % kp_z_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_patch(:, :) = nan\n  ALLOCATE(this % cp_patch(begp : endp))\n  this % cp_patch(:) = nan\n  ALLOCATE(this % kc_patch(begp : endp))\n  this % kc_patch(:) = nan\n  ALLOCATE(this % ko_patch(begp : endp))\n  this % ko_patch(:) = nan\n  ALLOCATE(this % qe_patch(begp : endp))\n  this % qe_patch(:) = nan\n  ALLOCATE(this % bbb_patch(begp : endp))\n  this % bbb_patch(:) = nan\n  ALLOCATE(this % mbb_patch(begp : endp))\n  this % mbb_patch(:) = nan\n  ALLOCATE(this % gb_mol_patch(begp : endp))\n  this % gb_mol_patch(:) = nan\n  ALLOCATE(this % rh_leaf_patch(begp : endp))\n  this % rh_leaf_patch(:) = nan\n  ALLOCATE(this % vpd_can_patch(begp : endp))\n  this % vpd_can_patch(:) = nan\n  ALLOCATE(this % psnsun_patch(begp : endp))\n  this % psnsun_patch(:) = nan\n  ALLOCATE(this % psnsha_patch(begp : endp))\n  this % psnsha_patch(:) = nan\n  ALLOCATE(this % c13_psnsun_patch(begp : endp))\n  this % c13_psnsun_patch(:) = nan\n  ALLOCATE(this % c13_psnsha_patch(begp : endp))\n  this % c13_psnsha_patch(:) = nan\n  ALLOCATE(this % c14_psnsun_patch(begp : endp))\n  this % c14_psnsun_patch(:) = nan\n  ALLOCATE(this % c14_psnsha_patch(begp : endp))\n  this % c14_psnsha_patch(:) = nan\n  ALLOCATE(this % psnsun_z_patch(begp : endp, 1 : nlevcan))\n  this % psnsun_z_patch(:, :) = nan\n  ALLOCATE(this % psnsha_z_patch(begp : endp, 1 : nlevcan))\n  this % psnsha_z_patch(:, :) = nan\n  ALLOCATE(this % psnsun_wc_patch(begp : endp))\n  this % psnsun_wc_patch(:) = nan\n  ALLOCATE(this % psnsha_wc_patch(begp : endp))\n  this % psnsha_wc_patch(:) = nan\n  ALLOCATE(this % psnsun_wj_patch(begp : endp))\n  this % psnsun_wj_patch(:) = nan\n  ALLOCATE(this % psnsha_wj_patch(begp : endp))\n  this % psnsha_wj_patch(:) = nan\n  ALLOCATE(this % psnsun_wp_patch(begp : endp))\n  this % psnsun_wp_patch(:) = nan\n  ALLOCATE(this % psnsha_wp_patch(begp : endp))\n  this % psnsha_wp_patch(:) = nan\n  ALLOCATE(this % fpsn_patch(begp : endp))\n  this % fpsn_patch(:) = nan\n  ALLOCATE(this % fpsn_wc_patch(begp : endp))\n  this % fpsn_wc_patch(:) = nan\n  ALLOCATE(this % fpsn_wj_patch(begp : endp))\n  this % fpsn_wj_patch(:) = nan\n  ALLOCATE(this % fpsn_wp_patch(begp : endp))\n  this % fpsn_wp_patch(:) = nan\n  ALLOCATE(this % lnca_patch(begp : endp))\n  this % lnca_patch(:) = nan\n  ALLOCATE(this % lmrsun_z_patch(begp : endp, 1 : nlevcan))\n  this % lmrsun_z_patch(:, :) = nan\n  ALLOCATE(this % lmrsha_z_patch(begp : endp, 1 : nlevcan))\n  this % lmrsha_z_patch(:, :) = nan\n  ALLOCATE(this % lmrsun_patch(begp : endp))\n  this % lmrsun_patch(:) = nan\n  ALLOCATE(this % lmrsha_patch(begp : endp))\n  this % lmrsha_patch(:) = nan\n  ALLOCATE(this % alphapsnsun_patch(begp : endp))\n  this % alphapsnsun_patch(:) = nan\n  ALLOCATE(this % alphapsnsha_patch(begp : endp))\n  this % alphapsnsha_patch(:) = nan\n  ALLOCATE(this % rc13_canair_patch(begp : endp))\n  this % rc13_canair_patch(:) = nan\n  ALLOCATE(this % rc13_psnsun_patch(begp : endp))\n  this % rc13_psnsun_patch(:) = nan\n  ALLOCATE(this % rc13_psnsha_patch(begp : endp))\n  this % rc13_psnsha_patch(:) = nan\n  ALLOCATE(this % cisun_z_patch(begp : endp, 1 : nlevcan))\n  this % cisun_z_patch(:, :) = nan\n  ALLOCATE(this % cisha_z_patch(begp : endp, 1 : nlevcan))\n  this % cisha_z_patch(:, :) = nan\n  ALLOCATE(this % rssun_z_patch(begp : endp, 1 : nlevcan))\n  this % rssun_z_patch(:, :) = nan\n  ALLOCATE(this % rssha_z_patch(begp : endp, 1 : nlevcan))\n  this % rssha_z_patch(:, :) = nan\n  ALLOCATE(this % rssun_patch(begp : endp))\n  this % rssun_patch(:) = nan\n  ALLOCATE(this % rssha_patch(begp : endp))\n  this % rssha_patch(:) = nan\n  ALLOCATE(this % luvcmax25top_patch(begp : endp))\n  this % luvcmax25top_patch(:) = nan\n  ALLOCATE(this % lujmax25top_patch(begp : endp))\n  this % lujmax25top_patch(:) = nan\n  ALLOCATE(this % lutpu25top_patch(begp : endp))\n  this % lutpu25top_patch(:) = nan\n  IF (use_luna) THEN\n    ALLOCATE(this % vcmx25_z_patch(begp : endp, 1 : nlevcan))\n    this % vcmx25_z_patch(:, :) = 30._r8\n    ALLOCATE(this % jmx25_z_patch(begp : endp, 1 : nlevcan))\n    this % jmx25_z_patch(:, :) = 60._r8\n    ALLOCATE(this % vcmx25_z_last_valid_patch(begp : endp, 1 : nlevcan))\n    this % vcmx25_z_last_valid_patch(:, :) = 30._r8\n    ALLOCATE(this % jmx25_z_last_valid_patch(begp : endp, 1 : nlevcan))\n    this % jmx25_z_last_valid_patch(:, :) = 60._r8\n    ALLOCATE(this % pnlc_z_patch(begp : endp, 1 : nlevcan))\n    this % pnlc_z_patch(:, :) = 0.01_r8\n    ALLOCATE(this % fpsn24_patch(begp : endp))\n    this % fpsn24_patch(:) = nan\n    ALLOCATE(this % enzs_z_patch(begp : endp, 1 : nlevcan))\n    this % enzs_z_patch(:, :) = 1._r8\n  END IF\nEND SUBROUTINE InitAllocate"}, {"color": "#97c2fc", "id": "InitCold", "label": "InitCold", "shape": "dot", "size": 10, "source": "SUBROUTINE InitCold(this, bounds)\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER :: p, l\n  DO p = bounds % begp, bounds % endp\n    l = patch % landunit(p)\n    this % alphapsnsun_patch(p) = spval\n    this % alphapsnsha_patch(p) = spval\n    IF (lun % ifspecial(l)) THEN\n      this % psnsun_patch(p) = 0._r8\n      this % psnsha_patch(p) = 0._r8\n      IF (use_c13) THEN\n        this % c13_psnsun_patch(p) = 0._r8\n        this % c13_psnsha_patch(p) = 0._r8\n      END IF\n      IF (use_c14) THEN\n        this % c14_psnsun_patch(p) = 0._r8\n        this % c14_psnsha_patch(p) = 0._r8\n      END IF\n    END IF\n  END DO\nEND SUBROUTINE InitCold"}, {"color": "#97c2fc", "id": "cleanParams", "label": "cleanParams", "shape": "dot", "size": 10, "source": "SUBROUTINE cleanParams(this)\n  IMPLICIT NONE\n  CLASS(photo_params_type) :: this\n  CHARACTER(LEN = 32) :: subname = \u0027cleanParams\u0027\n  DEALLOCATE(this % krmax)\n  DEALLOCATE(this % theta_cj)\n  DEALLOCATE(this % kmax)\n  DEALLOCATE(this % psi50)\n  DEALLOCATE(this % ck)\nEND SUBROUTINE cleanParams"}, {"color": "#97c2fc", "id": "TimeStepInit", "label": "TimeStepInit", "shape": "dot", "size": 10, "source": "SUBROUTINE TimeStepInit(this, bounds)\n  USE landunit_varcon, ONLY: istsoil, istcrop, istice, istwet\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER :: p, l\n  DO p = bounds % begp, bounds % endp\n    l = patch % landunit(p)\n    IF (.NOT. lun % lakpoi(l)) THEN\n      this % psnsun_patch(p) = 0._r8\n      this % psnsun_wc_patch(p) = 0._r8\n      this % psnsun_wj_patch(p) = 0._r8\n      this % psnsun_wp_patch(p) = 0._r8\n      this % psnsha_patch(p) = 0._r8\n      this % psnsha_wc_patch(p) = 0._r8\n      this % psnsha_wj_patch(p) = 0._r8\n      this % psnsha_wp_patch(p) = 0._r8\n      this % fpsn_patch(p) = 0._r8\n      this % fpsn_wc_patch(p) = 0._r8\n      this % fpsn_wj_patch(p) = 0._r8\n      this % fpsn_wp_patch(p) = 0._r8\n      IF (use_c13) THEN\n        this % alphapsnsun_patch(p) = 0._r8\n        this % alphapsnsha_patch(p) = 0._r8\n        this % c13_psnsun_patch(p) = 0._r8\n        this % c13_psnsha_patch(p) = 0._r8\n      END IF\n      IF (use_c14) THEN\n        this % c14_psnsun_patch(p) = 0._r8\n        this % c14_psnsha_patch(p) = 0._r8\n      END IF\n    END IF\n    IF (lun % itype(l) == istsoil .OR. lun % itype(l) == istcrop .OR. lun % itype(l) == istice .OR. lun % itype(l) == istwet) THEN\n      IF (use_c13) THEN\n        this % rc13_canair_patch(p) = 0._r8\n        this % rc13_psnsun_patch(p) = 0._r8\n        this % rc13_psnsha_patch(p) = 0._r8\n      END IF\n    END IF\n  END DO\nEND SUBROUTINE TimeStepInit"}, {"color": "#97c2fc", "id": "NewPatchInit", "label": "NewPatchInit", "shape": "dot", "size": 10, "source": "SUBROUTINE NewPatchInit(this, p)\n  CLASS(photosyns_type) :: this\n  INTEGER, INTENT(IN) :: p\n  IF (use_c13) THEN\n    this % alphapsnsun_patch(p) = 0._r8\n    this % alphapsnsha_patch(p) = 0._r8\n    this % rc13_canair_patch(p) = 0._r8\n    this % rc13_psnsun_patch(p) = 0._r8\n    this % rc13_psnsha_patch(p) = 0._r8\n  END IF\n  this % psnsun_patch(p) = 0._r8\n  this % psnsha_patch(p) = 0._r8\n  IF (use_c13) THEN\n    this % c13_psnsun_patch(p) = 0._r8\n    this % c13_psnsha_patch(p) = 0._r8\n  END IF\n  IF (use_c14) THEN\n    this % c14_psnsun_patch(p) = 0._r8\n    this % c14_psnsha_patch(p) = 0._r8\n  END IF\nEND SUBROUTINE NewPatchInit"}, {"color": "#97c2fc", "id": "ft", "label": "ft", "shape": "dot", "size": 10, "source": "FUNCTION ft(tl, ha) RESULT(ans)\n  USE clm_varcon, ONLY: rgas, tfrz\n  REAL(KIND = r8), INTENT(IN) :: tl\n  REAL(KIND = r8), INTENT(IN) :: ha\n  REAL(KIND = r8) :: ans\n  ans = EXP(ha / (rgas * 1.E-3_r8 * (tfrz + 25._r8)) * (1._r8 - (tfrz + 25._r8) / tl))\n  RETURN\nEND FUNCTION ft"}, {"color": "#97c2fc", "id": "fth", "label": "fth", "shape": "dot", "size": 10, "source": "FUNCTION fth(tl, hd, se, scaleFactor) RESULT(ans)\n  USE clm_varcon, ONLY: rgas, tfrz\n  REAL(KIND = r8), INTENT(IN) :: tl\n  REAL(KIND = r8), INTENT(IN) :: hd\n  REAL(KIND = r8), INTENT(IN) :: se\n  REAL(KIND = r8), INTENT(IN) :: scaleFactor\n  REAL(KIND = r8) :: ans\n  ans = scaleFactor / (1._r8 + EXP((- hd + se * tl) / (rgas * 1.E-3_r8 * tl)))\n  RETURN\nEND FUNCTION fth"}, {"color": "#97c2fc", "id": "fth25", "label": "fth25", "shape": "dot", "size": 10, "source": "FUNCTION fth25(hd, se) RESULT(ans)\n  USE clm_varcon, ONLY: rgas, tfrz\n  REAL(KIND = r8), INTENT(IN) :: hd\n  REAL(KIND = r8), INTENT(IN) :: se\n  REAL(KIND = r8) :: ans\n  ans = 1._r8 + EXP((- hd + se * (tfrz + 25._r8)) / (rgas * 1.E-3_r8 * (tfrz + 25._r8)))\n  RETURN\nEND FUNCTION fth25"}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "this % InitAllocate", "to": "Init", "width": 1}, {"arrows": "to", "from": "this % InitHistory", "to": "Init", "width": 1}, {"arrows": "to", "from": "this % InitCold", "to": "Init", "width": 1}, {"arrows": "to", "from": "params_inst % cleanParams", "to": "Clean", "width": 1}, {"arrows": "to", "from": "hist_addfld1d", "to": "InitHistory", "width": 1}, {"arrows": "to", "from": "hist_addfld2d", "to": "InitHistory", "width": 1}, {"arrows": "to", "from": "endrun", "to": "allocParams", "width": 1}, {"arrows": "to", "from": "endrun", "to": "readParams", "width": 1}, {"arrows": "to", "from": "endrun", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "endrun", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "endrun", "to": "brent", "width": 1}, {"arrows": "to", "from": "endrun", "to": "PhotosynthesisHydraulicStress", "width": 1}, {"arrows": "to", "from": "endrun", "to": "brent_PHS", "width": 1}, {"arrows": "to", "from": "endrun", "to": "spacA", "width": 1}, {"arrows": "to", "from": "endrun", "to": "plc", "width": 1}, {"arrows": "to", "from": "endrun", "to": "d1plc", "width": 1}, {"arrows": "to", "from": "params_inst % allocParams", "to": "readParams", "width": 1}, {"arrows": "to", "from": "params_inst % allocParams", "to": "setParamsForTesting", "width": 1}, {"arrows": "to", "from": "ncd_io", "to": "readParams", "width": 1}, {"arrows": "to", "from": "readNcdioScalar", "to": "readParams", "width": 1}, {"arrows": "to", "from": "opnfil", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "shr_nl_find_group_name", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "relavu", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "shr_mpi_bcast", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "restartvar", "to": "Restart", "width": 1}, {"arrows": "to", "from": "shr_assert_all", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "shr_assert_all", "to": "Fractionation", "width": 1}, {"arrows": "to", "from": "shr_assert_all", "to": "PhotosynthesisHydraulicStress", "width": 1}, {"arrows": "to", "from": "quadratic", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "quadratic", "to": "ci_func", "width": 1}, {"arrows": "to", "from": "quadratic", "to": "PhotosynthesisHydraulicStress", "width": 1}, {"arrows": "to", "from": "quadratic", "to": "ci_func_PHS", "width": 1}, {"arrows": "to", "from": "hybrid", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "C14BombSpike", "to": "PhotosynthesisTotal", "width": 1}, {"arrows": "to", "from": "C13TimeSeries", "to": "PhotosynthesisTotal", "width": 1}, {"arrows": "to", "from": "ci_func", "to": "hybrid", "width": 1}, {"arrows": "to", "from": "ci_func", "to": "brent", "width": 1}, {"arrows": "to", "from": "brent", "to": "hybrid", "width": 1}, {"arrows": "to", "from": "calcstress", "to": "PhotosynthesisHydraulicStress", "width": 1}, {"arrows": "to", "from": "calcstress", "to": "ci_func_PHS", "width": 1}, {"arrows": "to", "from": "hybrid_PHS", "to": "PhotosynthesisHydraulicStress", "width": 1}, {"arrows": "to", "from": "ci_func_PHS", "to": "hybrid_PHS", "width": 1}, {"arrows": "to", "from": "ci_func_PHS", "to": "brent_PHS", "width": 1}, {"arrows": "to", "from": "brent_PHS", "to": "hybrid_PHS", "width": 1}, {"arrows": "to", "from": "getvegwp", "to": "hybrid_PHS", "width": 1}, {"arrows": "to", "from": "getvegwp", "to": "calcstress", "width": 1}, {"arrows": "to", "from": "getqflx", "to": "calcstress", "width": 1}, {"arrows": "to", "from": "getqflx", "to": "getvegwp", "width": 1}, {"arrows": "to", "from": "spacF", "to": "calcstress", "width": 1}, {"arrows": "to", "from": "spacA", "to": "calcstress", "width": 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": true,
        "filter": [
            "physics"
        ]
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  
                  // if this network requires displaying the configure window,
                  // put it in its div
                  options.configure["container"] = document.getElementById("config");
                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>