<html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             

             
             #config {
                 float: left;
                 width: 400px;
                 height: 600px;
             }
             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
        
            <div id="config"></div>
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#97c2fc", "id": "this % InitAllocate", "label": "this % InitAllocate", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Init", "label": "Init", "shape": "dot", "size": 10, "source": "SUBROUTINE Init(this, bounds)\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  CALL this % InitAllocate(bounds)\n  CALL this % InitHistory(bounds)\n  CALL this % InitCold(bounds)\nEND SUBROUTINE Init"}, {"color": "#97c2fc", "id": "this % InitHistory", "label": "this % InitHistory", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "this % InitCold", "label": "this % InitCold", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "params_inst % cleanParams", "label": "params_inst % cleanParams", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Clean", "label": "Clean", "shape": "dot", "size": 10, "source": "SUBROUTINE Clean(this)\n  CLASS(photosyns_type) :: this\n  CALL params_inst % cleanParams\n  DEALLOCATE(this % c3flag_patch)\n  DEALLOCATE(this % ac_phs_patch)\n  DEALLOCATE(this % aj_phs_patch)\n  DEALLOCATE(this % ap_phs_patch)\n  DEALLOCATE(this % ag_phs_patch)\n  DEALLOCATE(this % an_sun_patch)\n  DEALLOCATE(this % an_sha_patch)\n  DEALLOCATE(this % vcmax_z_phs_patch)\n  DEALLOCATE(this % tpu_z_phs_patch)\n  DEALLOCATE(this % kp_z_phs_patch)\n  DEALLOCATE(this % gs_mol_sun_patch)\n  DEALLOCATE(this % gs_mol_sha_patch)\n  DEALLOCATE(this % gs_mol_sun_ln_patch)\n  DEALLOCATE(this % gs_mol_sha_ln_patch)\n  DEALLOCATE(this % ac_patch)\n  DEALLOCATE(this % aj_patch)\n  DEALLOCATE(this % ap_patch)\n  DEALLOCATE(this % ag_patch)\n  DEALLOCATE(this % an_patch)\n  DEALLOCATE(this % vcmax_z_patch)\n  DEALLOCATE(this % tpu_z_patch)\n  DEALLOCATE(this % kp_z_patch)\n  DEALLOCATE(this % gs_mol_patch)\n  DEALLOCATE(this % cp_patch)\n  DEALLOCATE(this % kc_patch)\n  DEALLOCATE(this % ko_patch)\n  DEALLOCATE(this % qe_patch)\n  DEALLOCATE(this % bbb_patch)\n  DEALLOCATE(this % mbb_patch)\n  DEALLOCATE(this % gb_mol_patch)\n  DEALLOCATE(this % rh_leaf_patch)\n  DEALLOCATE(this % vpd_can_patch)\n  DEALLOCATE(this % psnsun_patch)\n  DEALLOCATE(this % psnsha_patch)\n  DEALLOCATE(this % c13_psnsun_patch)\n  DEALLOCATE(this % c13_psnsha_patch)\n  DEALLOCATE(this % c14_psnsun_patch)\n  DEALLOCATE(this % c14_psnsha_patch)\n  DEALLOCATE(this % psnsun_z_patch)\n  DEALLOCATE(this % psnsha_z_patch)\n  DEALLOCATE(this % psnsun_wc_patch)\n  DEALLOCATE(this % psnsha_wc_patch)\n  DEALLOCATE(this % psnsun_wj_patch)\n  DEALLOCATE(this % psnsha_wj_patch)\n  DEALLOCATE(this % psnsun_wp_patch)\n  DEALLOCATE(this % psnsha_wp_patch)\n  DEALLOCATE(this % fpsn_patch)\n  DEALLOCATE(this % fpsn_wc_patch)\n  DEALLOCATE(this % fpsn_wj_patch)\n  DEALLOCATE(this % fpsn_wp_patch)\n  DEALLOCATE(this % lnca_patch)\n  DEALLOCATE(this % lmrsun_z_patch)\n  DEALLOCATE(this % lmrsha_z_patch)\n  DEALLOCATE(this % lmrsun_patch)\n  DEALLOCATE(this % lmrsha_patch)\n  DEALLOCATE(this % alphapsnsun_patch)\n  DEALLOCATE(this % alphapsnsha_patch)\n  DEALLOCATE(this % rc13_canair_patch)\n  DEALLOCATE(this % rc13_psnsun_patch)\n  DEALLOCATE(this % rc13_psnsha_patch)\n  DEALLOCATE(this % cisun_z_patch)\n  DEALLOCATE(this % cisha_z_patch)\n  DEALLOCATE(this % rssun_z_patch)\n  DEALLOCATE(this % rssha_z_patch)\n  DEALLOCATE(this % rssun_patch)\n  DEALLOCATE(this % rssha_patch)\n  DEALLOCATE(this % luvcmax25top_patch)\n  DEALLOCATE(this % lujmax25top_patch)\n  DEALLOCATE(this % lutpu25top_patch)\n  IF (use_luna) THEN\n    DEALLOCATE(this % vcmx25_z_patch)\n    DEALLOCATE(this % jmx25_z_patch)\n    DEALLOCATE(this % vcmx25_z_last_valid_patch)\n    DEALLOCATE(this % jmx25_z_last_valid_patch)\n    DEALLOCATE(this % pnlc_z_patch)\n    DEALLOCATE(this % fpsn24_patch)\n    DEALLOCATE(this % enzs_z_patch)\n  END IF\nEND SUBROUTINE Clean"}, {"color": "#97c2fc", "id": "hist_addfld1d", "label": "hist_addfld1d", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "InitHistory", "label": "InitHistory", "shape": "dot", "size": 10, "source": "SUBROUTINE InitHistory(this, bounds)\n  USE histFileMod, ONLY: hist_addfld1d, hist_addfld2d\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  REAL(KIND = r8), POINTER :: ptr_1d(:)\n  INTEGER :: begp, endp\n  begp = bounds % begp\n  endp = bounds % endp\n  this % rh_leaf_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027RH_LEAF\u0027, units = \u0027fraction\u0027, avgflag = \u0027A\u0027, long_name = \u0027fractional humidity at leaf surface\u0027, ptr_patch = this % rh_leaf_patch, set_spec = spval, default = \u0027inactive\u0027)\n  this % vpd_can_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027VPD_CAN\u0027, units = \u0027kPa\u0027, avgflag = \u0027A\u0027, long_name = \u0027canopy vapor pressure deficit\u0027, ptr_patch = this % vpd_can_patch, set_spec = spval, default = \u0027active\u0027)\n  this % lnca_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027LNC\u0027, units = \u0027gN leaf/m^2\u0027, avgflag = \u0027A\u0027, long_name = \u0027leaf N concentration\u0027, ptr_patch = this % lnca_patch, set_spec = spval)\n  IF (.NOT. use_fates) THEN\n    this % fpsn_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027A\u0027, long_name = \u0027photosynthesis\u0027, ptr_patch = this % fpsn_patch, set_lake = 0._r8, set_urb = 0._r8)\n    this % fpsn_wc_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN_WC\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027I\u0027, long_name = \u0027Rubisco-limited photosynthesis\u0027, ptr_patch = this % fpsn_wc_patch, set_lake = 0._r8, set_urb = 0._r8, default = \u0027inactive\u0027)\n    this % fpsn_wj_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN_WJ\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027I\u0027, long_name = \u0027RuBP-limited photosynthesis\u0027, ptr_patch = this % fpsn_wj_patch, set_lake = 0._r8, set_urb = 0._r8, default = \u0027inactive\u0027)\n    this % fpsn_wp_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027FPSN_WP\u0027, units = \u0027umol m-2 s-1\u0027, avgflag = \u0027I\u0027, long_name = \u0027Product-limited photosynthesis\u0027, ptr_patch = this % fpsn_wp_patch, set_lake = 0._r8, set_urb = 0._r8, default = \u0027inactive\u0027)\n  END IF\n  IF (use_cn) THEN\n    this % psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027PSNSUN\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf photosynthesis\u0027, ptr_patch = this % psnsun_patch)\n    this % psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027PSNSHA\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf photosynthesis\u0027, ptr_patch = this % psnsha_patch)\n  END IF\n  IF (use_c13) THEN\n    this % c13_psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C13_PSNSUN\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13 sunlit leaf photosynthesis\u0027, ptr_patch = this % c13_psnsun_patch, default = \u0027inactive\u0027)\n    this % c13_psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C13_PSNSHA\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13 shaded leaf photosynthesis\u0027, ptr_patch = this % c13_psnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  IF (use_c14) THEN\n    this % c14_psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C14_PSNSUN\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C14 sunlit leaf photosynthesis\u0027, ptr_patch = this % c14_psnsun_patch, default = \u0027inactive\u0027)\n    this % c14_psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027C14_PSNSHA\u0027, units = \u0027umolCO2/m^2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027C14 shaded leaf photosynthesis\u0027, ptr_patch = this % c14_psnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  IF (use_c13) THEN\n    this % rc13_canair_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027RC13_CANAIR\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13/C(12+13) for canopy air\u0027, ptr_patch = this % rc13_canair_patch, default = \u0027inactive\u0027)\n    this % rc13_psnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027RC13_PSNSUN\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13/C(12+13) for sunlit photosynthesis\u0027, ptr_patch = this % rc13_psnsun_patch, default = \u0027inactive\u0027)\n    this % rc13_psnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027RC13_PSNSHA\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027C13/C(12+13) for shaded photosynthesis\u0027, ptr_patch = this % rc13_psnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  IF (use_c13) THEN\n    this % alphapsnsun_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027ALPHAPSNSUN\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit c13 fractionation\u0027, ptr_patch = this % alphapsnsun_patch, default = \u0027inactive\u0027)\n    this % alphapsnsha_patch(begp : endp) = spval\n    CALL hist_addfld1d(fname = \u0027ALPHAPSNSHA\u0027, units = \u0027proportion\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded c13 fractionation\u0027, ptr_patch = this % alphapsnsha_patch, default = \u0027inactive\u0027)\n  END IF\n  this % rssun_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027RSSUN\u0027, units = \u0027s/m\u0027, avgflag = \u0027M\u0027, long_name = \u0027sunlit leaf stomatal resistance\u0027, ptr_patch = this % rssun_patch, l2g_scale_type = \u0027veg\u0027)\n  this % rssha_patch(begp : endp) = spval\n  CALL hist_addfld1d(fname = \u0027RSSHA\u0027, units = \u0027s/m\u0027, avgflag = \u0027M\u0027, long_name = \u0027shaded leaf stomatal resistance\u0027, ptr_patch = this % rssha_patch, l2g_scale_type = \u0027veg\u0027)\n  this % gs_mol_sun_patch(begp : endp, :) = spval\n  this % gs_mol_sha_patch(begp : endp, :) = spval\n  IF (nlevcan \u003e 1) THEN\n    CALL hist_addfld2d(fname = \u0027GSSUN\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance\u0027, ptr_patch = this % gs_mol_sun_patch, set_lake = spval, set_urb = spval)\n    CALL hist_addfld2d(fname = \u0027GSSHA\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance\u0027, ptr_patch = this % gs_mol_sha_patch, set_lake = spval, set_urb = spval)\n  ELSE\n    ptr_1d =\u003e this % gs_mol_sun_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSUN\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance\u0027, ptr_patch = ptr_1d)\n    ptr_1d =\u003e this % gs_mol_sha_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSHA\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance\u0027, ptr_patch = ptr_1d)\n  END IF\n  this % gs_mol_sun_ln_patch(begp : endp, :) = spval\n  this % gs_mol_sha_ln_patch(begp : endp, :) = spval\n  IF (nlevcan \u003e 1) THEN\n    CALL hist_addfld2d(fname = \u0027GSSUNLN\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, ptr_patch = this % gs_mol_sun_ln_patch, set_lake = spval, set_urb = spval)\n    CALL hist_addfld2d(fname = \u0027GSSHALN\u0027, units = \u0027umol H20/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, ptr_patch = this % gs_mol_sha_ln_patch, set_lake = spval, set_urb = spval)\n  ELSE\n    ptr_1d =\u003e this % gs_mol_sun_ln_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSUNLN\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027sunlit leaf stomatal conductance at local noon\u0027, ptr_patch = ptr_1d)\n    ptr_1d =\u003e this % gs_mol_sha_ln_patch(begp : endp, 1)\n    CALL hist_addfld1d(fname = \u0027GSSHALN\u0027, units = \u0027umol H20/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027shaded leaf stomatal conductance at local noon\u0027, ptr_patch = ptr_1d)\n  END IF\n  IF (use_luna) THEN\n    IF (nlevcan \u003e 1) THEN\n      CALL hist_addfld2d(fname = \u0027Vcmx25Z\u0027, units = \u0027umol/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027canopy profile of vcmax25 predicted by LUNA model\u0027, ptr_patch = this % vcmx25_z_patch)\n      CALL hist_addfld2d(fname = \u0027Jmx25Z\u0027, units = \u0027umol electrons/m2/s\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027maximum rate of electron transport at 25 Celcius for canopy layers\u0027, ptr_patch = this % jmx25_z_patch)\n      CALL hist_addfld2d(fname = \u0027PNLCZ\u0027, units = \u0027unitless\u0027, type2d = \u0027nlevcan\u0027, avgflag = \u0027A\u0027, long_name = \u0027Proportion of nitrogen allocated for light capture\u0027, ptr_patch = this % pnlc_z_patch, default = \u0027inactive\u0027)\n    ELSE\n      ptr_1d =\u003e this % vcmx25_z_patch(:, 1)\n      CALL hist_addfld1d(fname = \u0027Vcmx25Z\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027canopy profile of vcmax25 predicted by LUNA model\u0027, ptr_patch = ptr_1d)\n      ptr_1d =\u003e this % jmx25_z_patch(:, 1)\n      CALL hist_addfld1d(fname = \u0027Jmx25Z\u0027, units = \u0027umol electrons/m2/s\u0027, avgflag = \u0027A\u0027, long_name = \u0027maximum rate of electron transport at 25 Celcius for canopy layers\u0027, ptr_patch = ptr_1d)\n      ptr_1d =\u003e this % pnlc_z_patch(:, 1)\n      CALL hist_addfld1d(fname = \u0027PNLCZ\u0027, units = \u0027unitless\u0027, avgflag = \u0027A\u0027, long_name = \u0027Proportion of nitrogen allocated for light capture\u0027, ptr_patch = ptr_1d, default = \u0027inactive\u0027)\n      this % luvcmax25top_patch(begp : endp) = spval\n      CALL hist_addfld1d(fname = \u0027VCMX25T\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027M\u0027, long_name = \u0027canopy profile of vcmax25\u0027, ptr_patch = this % luvcmax25top_patch, set_lake = spval, set_urb = spval)\n      this % lujmax25top_patch(begp : endp) = spval\n      CALL hist_addfld1d(fname = \u0027JMX25T\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027M\u0027, long_name = \u0027canopy profile of jmax\u0027, ptr_patch = this % lujmax25top_patch, set_lake = spval, set_urb = spval)\n      this % lutpu25top_patch(begp : endp) = spval\n      CALL hist_addfld1d(fname = \u0027TPU25T\u0027, units = \u0027umol/m2/s\u0027, avgflag = \u0027M\u0027, long_name = \u0027canopy profile of tpu\u0027, ptr_patch = this % lutpu25top_patch, set_lake = spval, set_urb = spval)\n    END IF\n    this % fpsn24_patch = spval\n    CALL hist_addfld1d(fname = \u0027FPSN24\u0027, units = \u0027umol CO2/m^2 ground/day\u0027, avgflag = \u0027A\u0027, long_name = \u002724 hour accumulative patch photosynthesis starting from mid-night\u0027, ptr_patch = this % fpsn24_patch, default = \u0027inactive\u0027)\n  END IF\nEND SUBROUTINE InitHistory"}, {"color": "#97c2fc", "id": "hist_addfld2d", "label": "hist_addfld2d", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "endrun", "label": "endrun", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "allocParams", "label": "allocParams", "shape": "dot", "size": 10, "source": "SUBROUTINE allocParams(this)\n  IMPLICIT NONE\n  CLASS(photo_params_type) :: this\n  CHARACTER(LEN = 32) :: subname = \u0027allocParams\u0027\n  ALLOCATE(this % krmax(0 : mxpft))\n  this % krmax(:) = nan\n  ALLOCATE(this % theta_cj(0 : mxpft))\n  this % theta_cj(:) = nan\n  ALLOCATE(this % kmax(0 : mxpft, nvegwcs))\n  this % kmax(:, :) = nan\n  ALLOCATE(this % psi50(0 : mxpft, nvegwcs))\n  this % psi50(:, :) = nan\n  ALLOCATE(this % ck(0 : mxpft, nvegwcs))\n  this % ck(:, :) = nan\n  IF (use_hydrstress .AND. nvegwcs /= 4) THEN\n    CALL endrun(msg = \u0027Error:: the Plant Hydraulics Stress methodology is for the spacA function is hardcoded for nvegwcs==4\u0027 // errMsg(\"./examples/photosynthesis/PhotosynthesisMod.f90\", 769))\n  END IF\nEND SUBROUTINE allocParams"}, {"color": "#97c2fc", "id": "readParams", "label": "readParams", "shape": "dot", "size": 10, "source": "SUBROUTINE readParams(this, ncid)\n  USE ncdio_pio, ONLY: file_desc_t, ncd_io\n  USE paramUtilMod, ONLY: readNcdioScalar\n  IMPLICIT NONE\n  CLASS(photosyns_type) :: this\n  TYPE(file_desc_t), INTENT(INOUT) :: ncid\n  CHARACTER(LEN = 32) :: subname = \u0027readParams\u0027\n  CHARACTER(LEN = 100) :: errCode = \u0027-Error reading in parameters file:\u0027\n  LOGICAL :: readv\n  REAL(KIND = r8) :: temp1d(0 : mxpft)\n  REAL(KIND = r8) :: temp2d(0 : mxpft, nvegwcs)\n  CHARACTER(LEN = 100) :: tString\n  CALL params_inst % allocParams\n  tString = \"krmax\"\n  CALL ncd_io(varname = TRIM(tString), data = temp1d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 825))\n  params_inst % krmax = temp1d\n  tString = \"lmr_intercept_atkin\"\n  CALL ncd_io(varname = TRIM(tString), data = temp1d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 829))\n  params_inst % lmr_intercept_atkin = temp1d\n  tString = \"theta_cj\"\n  CALL ncd_io(varname = TRIM(tString), data = temp1d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 833))\n  params_inst % theta_cj = temp1d\n  tString = \"kmax\"\n  CALL ncd_io(varname = TRIM(tString), data = temp2d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 837))\n  params_inst % kmax = temp2d\n  tString = \"psi50\"\n  CALL ncd_io(varname = TRIM(tString), data = temp2d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 841))\n  params_inst % psi50 = temp2d\n  tString = \"ck\"\n  CALL ncd_io(varname = TRIM(tString), data = temp2d, flag = \u0027read\u0027, ncid = ncid, readvar = readv)\n  IF (.NOT. readv) CALL endrun(msg = TRIM(errCode) // TRIM(tString) // errMsg(sourcefile, 845))\n  params_inst % ck = temp2d\n  CALL readNcdioScalar(ncid, \u0027ko25_coef\u0027, subname, params_inst % ko25_coef)\n  CALL readNcdioScalar(ncid, \u0027kc25_coef\u0027, subname, params_inst % kc25_coef)\n  CALL readNcdioScalar(ncid, \u0027cp25_yr2000\u0027, subname, params_inst % cp25_yr2000)\n  CALL readNcdioScalar(ncid, \u0027act25\u0027, subname, params_inst % act25)\n  CALL readNcdioScalar(ncid, \u0027fnr\u0027, subname, params_inst % fnr)\n  CALL readNcdioScalar(ncid, \u0027fnps\u0027, subname, params_inst % fnps)\n  CALL readNcdioScalar(ncid, \u0027theta_psii\u0027, subname, params_inst % theta_psii)\n  CALL readNcdioScalar(ncid, \u0027theta_ip\u0027, subname, params_inst % theta_ip)\n  CALL readNcdioScalar(ncid, \u0027vcmaxha\u0027, subname, params_inst % vcmaxha)\n  CALL readNcdioScalar(ncid, \u0027jmaxha\u0027, subname, params_inst % jmaxha)\n  CALL readNcdioScalar(ncid, \u0027tpuha\u0027, subname, params_inst % tpuha)\n  CALL readNcdioScalar(ncid, \u0027lmrha\u0027, subname, params_inst % lmrha)\n  CALL readNcdioScalar(ncid, \u0027kcha\u0027, subname, params_inst % kcha)\n  CALL readNcdioScalar(ncid, \u0027koha\u0027, subname, params_inst % koha)\n  CALL readNcdioScalar(ncid, \u0027cpha\u0027, subname, params_inst % cpha)\n  CALL readNcdioScalar(ncid, \u0027vcmaxhd\u0027, subname, params_inst % vcmaxhd)\n  CALL readNcdioScalar(ncid, \u0027jmaxhd\u0027, subname, params_inst % jmaxhd)\n  CALL readNcdioScalar(ncid, \u0027tpuhd\u0027, subname, params_inst % tpuhd)\n  CALL readNcdioScalar(ncid, \u0027lmrhd\u0027, subname, params_inst % lmrhd)\n  CALL readNcdioScalar(ncid, \u0027lmrse\u0027, subname, params_inst % lmrse)\n  CALL readNcdioScalar(ncid, \u0027tpu25ratio\u0027, subname, params_inst % tpu25ratio)\n  CALL readNcdioScalar(ncid, \u0027kp25ratio\u0027, subname, params_inst % kp25ratio)\n  CALL readNcdioScalar(ncid, \u0027vcmaxse_sf\u0027, subname, params_inst % vcmaxse_sf)\n  CALL readNcdioScalar(ncid, \u0027jmaxse_sf\u0027, subname, params_inst % jmaxse_sf)\n  CALL readNcdioScalar(ncid, \u0027tpuse_sf\u0027, subname, params_inst % tpuse_sf)\n  CALL readNcdioScalar(ncid, \u0027jmax25top_sf\u0027, subname, params_inst % jmax25top_sf)\nEND SUBROUTINE readParams"}, {"color": "#97c2fc", "id": "ReadNML", "label": "ReadNML", "shape": "dot", "size": 10, "source": "SUBROUTINE ReadNML(this, NLFilename)\n  USE fileutils, ONLY: getavu, relavu, opnfil\n  USE shr_nl_mod, ONLY: shr_nl_find_group_name\n  USE spmdMod, ONLY: masterproc, mpicom\n  USE shr_mpi_mod, ONLY: shr_mpi_bcast\n  USE clm_varctl, ONLY: iulog\n  CLASS(photosyns_type) :: this\n  CHARACTER(LEN = *), INTENT(IN) :: NLFilename\n  INTEGER :: ierr\n  INTEGER :: unitn\n  CHARACTER(LEN = *), PARAMETER :: subname = \u0027Photosyn::ReadNML\u0027\n  CHARACTER(LEN = *), PARAMETER :: nmlname = \u0027photosyns_inparm\u0027\n  LOGICAL :: rootstem_acc = .FALSE.\n  LOGICAL :: light_inhibit = .FALSE.\n  INTEGER :: leafresp_method = leafresp_mtd_ryan1991\n  LOGICAL :: modifyphoto_and_lmr_forcrop = .FALSE.\n  CHARACTER(LEN = 50) :: stomatalcond_method = \u0027Ball-Berry1987\u0027\n  NAMELIST /photosyns_inparm/ leafresp_method, light_inhibit, rootstem_acc, stomatalcond_method, modifyphoto_and_lmr_forcrop\n  IF (masterproc) THEN\n    unitn = getavu()\n    WRITE(iulog, *) \u0027Read in \u0027 // nmlname // \u0027  namelist\u0027\n    CALL opnfil(NLFilename, unitn, \u0027F\u0027)\n    CALL shr_nl_find_group_name(unitn, nmlname, status = ierr)\n    IF (ierr == 0) THEN\n      READ(unitn, NML = photosyns_inparm, IOSTAT = ierr)\n      IF (ierr /= 0) THEN\n        CALL endrun(msg = \"ERROR reading \" // nmlname // \"namelist\" // errmsg(sourcefile, 971))\n      END IF\n    ELSE\n      CALL endrun(msg = \"ERROR could NOT find \" // nmlname // \"namelist\" // errmsg(sourcefile, 974))\n    END IF\n    CALL relavu(unitn)\n    this % rootstem_acc = rootstem_acc\n    this % leafresp_method = leafresp_method\n    this % light_inhibit = light_inhibit\n    this % modifyphoto_and_lmr_forcrop = modifyphoto_and_lmr_forcrop\n    IF (TRIM(stomatalcond_method) == \u0027Ball-Berry1987\u0027) THEN\n      this % stomatalcond_mtd = stomatalcond_mtd_bb1987\n    ELSE IF (TRIM(stomatalcond_method) == \u0027Medlyn2011\u0027) THEN\n      this % stomatalcond_mtd = stomatalcond_mtd_medlyn2011\n    ELSE\n      CALL endrun(msg = \"ERROR bad value for stomtalcond_method in \" // nmlname // \"namelist\" // errmsg(sourcefile, 986))\n    END IF\n  END IF\n  CALL shr_mpi_bcast(this % rootstem_acc, mpicom)\n  CALL shr_mpi_bcast(this % leafresp_method, mpicom)\n  CALL shr_mpi_bcast(this % light_inhibit, mpicom)\n  CALL shr_mpi_bcast(this % stomatalcond_mtd, mpicom)\n  CALL shr_mpi_bcast(this % modifyphoto_and_lmr_forcrop, mpicom)\n  IF (masterproc) THEN\n    WRITE(iulog, *) \u0027 \u0027\n    WRITE(iulog, *) nmlname // \u0027 settings:\u0027\n    WRITE(iulog, NML = photosyns_inparm)\n    WRITE(iulog, *) \u0027 \u0027\n  END IF\nEND SUBROUTINE ReadNML"}, {"color": "#97c2fc", "id": "Photosynthesis", "label": "Photosynthesis", "shape": "dot", "size": 10, "source": "SUBROUTINE Photosynthesis(bounds, fn, filterp, esat_tv, eair, oair, cair, rb, btran, dayl_factor, leafn, atm2lnd_inst, temperature_inst, surfalb_inst, solarabs_inst, canopystate_inst, ozone_inst, photosyns_inst, phase)\n  USE clm_varcon, ONLY: rgas, tfrz, spval\n  USE GridcellType, ONLY: grc\n  USE clm_time_manager, ONLY: get_step_size_real, is_near_local_noon\n  USE clm_varctl, ONLY: cnallocate_carbon_only\n  USE clm_varctl, ONLY: lnc_opt, reduce_dayl_factor, vcmax_opt\n  USE pftconMod, ONLY: nbrdlf_dcd_tmp_shrub, npcropmin\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER, INTENT(IN) :: fn\n  INTEGER, INTENT(IN) :: filterp(fn)\n  REAL(KIND = r8), INTENT(IN) :: esat_tv(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: eair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: oair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: cair(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: rb(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: btran(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: dayl_factor(bounds % begp :)\n  REAL(KIND = r8), INTENT(IN) :: leafn(bounds % begp :)\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(temperature_type), INTENT(IN) :: temperature_inst\n  TYPE(surfalb_type), INTENT(IN) :: surfalb_inst\n  TYPE(solarabs_type), INTENT(IN) :: solarabs_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  CLASS(ozone_base_type), INTENT(IN) :: ozone_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  CHARACTER(LEN = *), INTENT(IN) :: phase\n  REAL(KIND = r8) :: jmax_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: bbbopt(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: kn(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: vcmax25top\n  REAL(KIND = r8) :: jmax25top\n  REAL(KIND = r8) :: tpu25top\n  REAL(KIND = r8) :: lmr25top\n  REAL(KIND = r8) :: kp25top\n  REAL(KIND = r8) :: vcmax25\n  REAL(KIND = r8) :: jmax25\n  REAL(KIND = r8) :: tpu25\n  REAL(KIND = r8) :: lmr25\n  REAL(KIND = r8) :: kp25\n  REAL(KIND = r8) :: kc25\n  REAL(KIND = r8) :: ko25\n  REAL(KIND = r8) :: cp25\n  REAL(KIND = r8) :: vcmaxse\n  REAL(KIND = r8) :: jmaxse\n  REAL(KIND = r8) :: tpuse\n  REAL(KIND = r8) :: vcmaxc\n  REAL(KIND = r8) :: jmaxc\n  REAL(KIND = r8) :: tpuc\n  REAL(KIND = r8) :: lmrc\n  INTEGER :: f, p, c, iv\n  REAL(KIND = r8) :: cf\n  REAL(KIND = r8) :: rsmax0\n  REAL(KIND = r8) :: gb\n  REAL(KIND = r8) :: cs\n  REAL(KIND = r8) :: gs\n  REAL(KIND = r8) :: hs\n  REAL(KIND = r8) :: sco\n  REAL(KIND = r8) :: ft\n  REAL(KIND = r8) :: fth\n  REAL(KIND = r8) :: fth25\n  REAL(KIND = r8) :: tl\n  REAL(KIND = r8) :: ha\n  REAL(KIND = r8) :: hd\n  REAL(KIND = r8) :: se\n  REAL(KIND = r8) :: scaleFactor\n  REAL(KIND = r8) :: ciold\n  REAL(KIND = r8) :: gs_mol_err\n  REAL(KIND = r8) :: je\n  REAL(KIND = r8) :: qabs\n  REAL(KIND = r8) :: aquad, bquad, cquad\n  REAL(KIND = r8) :: r1, r2\n  REAL(KIND = r8) :: ceair\n  INTEGER :: niter\n  REAL(KIND = r8) :: nscaler\n  REAL(KIND = r8) :: ai\n  REAL(KIND = r8) :: psn_wc_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wj_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psn_wp_z(bounds % begp : bounds % endp, nlevcan)\n  REAL(KIND = r8) :: psncan\n  REAL(KIND = r8) :: psncan_wc\n  REAL(KIND = r8) :: psncan_wj\n  REAL(KIND = r8) :: psncan_wp\n  REAL(KIND = r8) :: lmrcan\n  REAL(KIND = r8) :: gscan\n  REAL(KIND = r8) :: laican\n  REAL(KIND = r8) :: rh_can\n  REAL(KIND = r8), POINTER :: lai_z(:, :)\n  REAL(KIND = r8), POINTER :: par_z(:, :)\n  REAL(KIND = r8), POINTER :: vcmaxcint(:)\n  REAL(KIND = r8), POINTER :: alphapsn(:)\n  REAL(KIND = r8), POINTER :: psn(:)\n  REAL(KIND = r8), POINTER :: psn_wc(:)\n  REAL(KIND = r8), POINTER :: psn_wj(:)\n  REAL(KIND = r8), POINTER :: psn_wp(:)\n  REAL(KIND = r8), POINTER :: psn_z(:, :)\n  REAL(KIND = r8), POINTER :: lmr(:)\n  REAL(KIND = r8), POINTER :: lmr_z(:, :)\n  REAL(KIND = r8), POINTER :: rs(:)\n  REAL(KIND = r8), POINTER :: rs_z(:, :)\n  REAL(KIND = r8), POINTER :: ci_z(:, :)\n  REAL(KIND = r8), POINTER :: o3coefv(:)\n  REAL(KIND = r8), POINTER :: o3coefg(:)\n  REAL(KIND = r8), POINTER :: alphapsnsun(:)\n  REAL(KIND = r8), POINTER :: alphapsnsha(:)\n  REAL(KIND = r8) :: sum_nscaler\n  REAL(KIND = r8) :: total_lai\n  INTEGER :: nptreemax\n  REAL(KIND = r8) :: dtime\n  INTEGER :: g\n  ft(tl, ha) = EXP(ha / (rgas * 1.E-3_r8 * (tfrz + 25._r8)) * (1._r8 - (tfrz + 25._r8) / tl))\n  fth(tl, hd, se, scaleFactor) = scaleFactor / (1._r8 + EXP((- hd + se * tl) / (rgas * 1.E-3_r8 * tl)))\n  fth25(hd, se) = 1._r8 + EXP((- hd + se * (tfrz + 25._r8)) / (rgas * 1.E-3_r8 * (tfrz + 25._r8)))\n  CALL shr_assert_all((UBOUND(esat_tv) == (/bounds % endp/)), file = sourcefile, line = 1369)\n  CALL shr_assert_all((UBOUND(eair) == (/bounds % endp/)), file = sourcefile, line = 1370)\n  CALL shr_assert_all((UBOUND(oair) == (/bounds % endp/)), file = sourcefile, line = 1371)\n  CALL shr_assert_all((UBOUND(cair) == (/bounds % endp/)), file = sourcefile, line = 1372)\n  CALL shr_assert_all((UBOUND(rb) == (/bounds % endp/)), file = sourcefile, line = 1373)\n  CALL shr_assert_all((UBOUND(btran) == (/bounds % endp/)), file = sourcefile, line = 1374)\n  CALL shr_assert_all((UBOUND(dayl_factor) == (/bounds % endp/)), file = sourcefile, line = 1375)\n  CALL shr_assert_all((UBOUND(leafn) == (/bounds % endp/)), file = sourcefile, line = 1376)\n  ASSOCIATE(c3psn =\u003e pftcon % c3psn, crop =\u003e pftcon % crop, leafcn =\u003e pftcon % leafcn, flnr =\u003e pftcon % flnr, fnitr =\u003e pftcon % fnitr, slatop =\u003e pftcon % slatop, dsladlai =\u003e pftcon % dsladlai, i_vcad =\u003e pftcon % i_vcad, s_vcad =\u003e pftcon % s_vcad, i_flnr =\u003e pftcon % i_flnr, s_flnr =\u003e pftcon % s_flnr, mbbopt =\u003e pftcon % mbbopt, ivt =\u003e patch % itype, forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, t_veg =\u003e temperature_inst % t_veg_patch, t10 =\u003e temperature_inst % t_a10_patch, tgcm =\u003e temperature_inst % thm_patch, nrad =\u003e surfalb_inst % nrad_patch, tlai_z =\u003e surfalb_inst % tlai_z_patch, tlai =\u003e canopystate_inst % tlai_patch, c3flag =\u003e photosyns_inst % c3flag_patch, ac =\u003e photosyns_inst % ac_patch, aj =\u003e photosyns_inst % aj_patch, ap =\u003e photosyns_inst % ap_patch, ag =\u003e photosyns_inst % ag_patch, an =\u003e photosyns_inst % an_patch, gb_mol =\u003e photosyns_inst % gb_mol_patch, gs_mol =\u003e photosyns_inst % gs_mol_patch, gs_mol_sun_ln =\u003e photosyns_inst % gs_mol_sun_ln_patch, gs_mol_sha_ln =\u003e photosyns_inst % gs_mol_sha_ln_patch, gs_mol_sun =\u003e photosyns_inst % gs_mol_sun_patch, gs_mol_sha =\u003e photosyns_inst % gs_mol_sha_patch, vcmax_z =\u003e photosyns_inst % vcmax_z_patch, cp =\u003e photosyns_inst % cp_patch, kc =\u003e photosyns_inst % kc_patch, ko =\u003e photosyns_inst % ko_patch, qe =\u003e photosyns_inst % qe_patch, tpu_z =\u003e photosyns_inst % tpu_z_patch, kp_z =\u003e photosyns_inst % kp_z_patch, bbb =\u003e photosyns_inst % bbb_patch, mbb =\u003e photosyns_inst % mbb_patch, rh_leaf =\u003e photosyns_inst % rh_leaf_patch, vpd_can =\u003e photosyns_inst % vpd_can_patch, lnc =\u003e photosyns_inst % lnca_patch, light_inhibit =\u003e photosyns_inst % light_inhibit, leafresp_method =\u003e photosyns_inst % leafresp_method, medlynintercept =\u003e pftcon % medlynintercept, stomatalcond_mtd =\u003e photosyns_inst % stomatalcond_mtd, leaf_mr_vcm =\u003e canopystate_inst % leaf_mr_vcm)\n    IF (phase == \u0027sun\u0027) THEN\n      par_z =\u003e solarabs_inst % parsun_z_patch\n      lai_z =\u003e canopystate_inst % laisun_z_patch\n      vcmaxcint =\u003e surfalb_inst % vcmaxcintsun_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsun_patch\n      o3coefv =\u003e ozone_inst % o3coefvsun_patch\n      o3coefg =\u003e ozone_inst % o3coefgsun_patch\n      ci_z =\u003e photosyns_inst % cisun_z_patch\n      rs =\u003e photosyns_inst % rssun_patch\n      rs_z =\u003e photosyns_inst % rssun_z_patch\n      lmr =\u003e photosyns_inst % lmrsun_patch\n      lmr_z =\u003e photosyns_inst % lmrsun_z_patch\n      psn =\u003e photosyns_inst % psnsun_patch\n      psn_z =\u003e photosyns_inst % psnsun_z_patch\n      psn_wc =\u003e photosyns_inst % psnsun_wc_patch\n      psn_wj =\u003e photosyns_inst % psnsun_wj_patch\n      psn_wp =\u003e photosyns_inst % psnsun_wp_patch\n    ELSE IF (phase == \u0027sha\u0027) THEN\n      par_z =\u003e solarabs_inst % parsha_z_patch\n      lai_z =\u003e canopystate_inst % laisha_z_patch\n      vcmaxcint =\u003e surfalb_inst % vcmaxcintsha_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsha_patch\n      o3coefv =\u003e ozone_inst % o3coefvsha_patch\n      o3coefg =\u003e ozone_inst % o3coefgsha_patch\n      ci_z =\u003e photosyns_inst % cisha_z_patch\n      rs =\u003e photosyns_inst % rssha_patch\n      rs_z =\u003e photosyns_inst % rssha_z_patch\n      lmr =\u003e photosyns_inst % lmrsha_patch\n      lmr_z =\u003e photosyns_inst % lmrsha_z_patch\n      psn =\u003e photosyns_inst % psnsha_patch\n      psn_z =\u003e photosyns_inst % psnsha_z_patch\n      psn_wc =\u003e photosyns_inst % psnsha_wc_patch\n      psn_wj =\u003e photosyns_inst % psnsha_wj_patch\n      psn_wp =\u003e photosyns_inst % psnsha_wp_patch\n    END IF\n    dtime = get_step_size_real()\n    lmrc = fth25(params_inst % lmrhd, params_inst % lmrse)\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      IF (NINT(c3psn(patch % itype(p))) == 1) THEN\n        c3flag(p) = .TRUE.\n      ELSE IF (NINT(c3psn(patch % itype(p))) == 0) THEN\n        c3flag(p) = .FALSE.\n      END IF\n      IF (c3flag(p)) THEN\n        qe(p) = 0._r8\n        IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) bbbopt(p) = bbbopt_c3\n      ELSE\n        qe(p) = 0.05_r8\n        IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) bbbopt(p) = bbbopt_c4\n      END IF\n      IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n        bbb(p) = MAX(bbbopt(p) * btran(p), 1._r8)\n        mbb(p) = mbbopt(patch % itype(p))\n      END IF\n      kc25 = params_inst % kc25_coef * forc_pbot(c)\n      ko25 = params_inst % ko25_coef * forc_pbot(c)\n      sco = 0.5_r8 * 0.209_r8 / params_inst % cp25_yr2000\n      cp25 = 0.5_r8 * oair(p) / sco\n      kc(p) = kc25 * ft(t_veg(p), params_inst % kcha)\n      ko(p) = ko25 * ft(t_veg(p), params_inst % koha)\n      cp(p) = cp25 * ft(t_veg(p), params_inst % cpha)\n    END DO\n    DO f = 1, fn\n      p = filterp(f)\n      IF (lnc_opt .EQV. .FALSE.) THEN\n        IF ((slatop(patch % itype(p)) * leafcn(patch % itype(p))) .LE. 0.0_r8) THEN\n          CALL endrun(subgrid_index = p, subgrid_level = subgrid_level_patch, msg = \"ERROR: slatop or leafcn is zero\")\n        END IF\n        lnc(p) = 1._r8 / (slatop(patch % itype(p)) * leafcn(patch % itype(p)))\n      END IF\n      IF (lnc_opt .EQV. .TRUE.) THEN\n        sum_nscaler = 0.0_r8\n        laican = 0.0_r8\n        total_lai = 0.0_r8\n        DO iv = 1, nrad(p)\n          IF (iv == 1) THEN\n            laican = 0.5_r8 * tlai_z(p, iv)\n            total_lai = tlai_z(p, iv)\n          ELSE\n            laican = laican + 0.5_r8 * (tlai_z(p, iv - 1) + tlai_z(p, iv))\n            total_lai = total_lai + tlai_z(p, iv)\n          END IF\n          IF (nlevcan == 1) THEN\n            nscaler = 1.0_r8\n          ELSE IF (nlevcan \u003e 1) THEN\n            nscaler = EXP(- kn(p) * laican)\n          END IF\n          sum_nscaler = sum_nscaler + nscaler\n        END DO\n        IF (tlai(p) \u003e 0.0_r8 .AND. sum_nscaler \u003e 0.0_r8) THEN\n          lnc(p) = leafn(p) / (tlai(p) * sum_nscaler)\n        ELSE\n          lnc(p) = 0.0_r8\n        END IF\n      END IF\n      IF (reduce_dayl_factor .EQV. .TRUE.) THEN\n        IF (dayl_factor(p) \u003e 0.25_r8) THEN\n        END IF\n      END IF\n      IF (vcmax_opt == 0) THEN\n        vcmax25top = lnc(p) * flnr(patch % itype(p)) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        IF (.NOT. use_cn) THEN\n          vcmax25top = vcmax25top * fnitr(patch % itype(p))\n        ELSE\n          IF (CNAllocate_Carbon_only()) vcmax25top = vcmax25top * fnitr(patch % itype(p))\n        END IF\n      ELSE IF (vcmax_opt == 3) THEN\n        vcmax25top = (i_vcad(patch % itype(p)) + s_vcad(patch % itype(p)) * lnc(p)) * dayl_factor(p)\n      ELSE IF (vcmax_opt == 4) THEN\n        nptreemax = 9\n        IF (patch % itype(p) \u003e= nptreemax) THEN\n          vcmax25top = lnc(p) * (i_flnr(patch % itype(p)) + s_flnr(patch % itype(p)) * lnc(p)) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        ELSE\n          vcmax25top = lnc(p) * (i_flnr(patch % itype(p)) * EXP(s_flnr(patch % itype(p)) * lnc(p))) * params_inst % fnr * params_inst % act25 * dayl_factor(p)\n        END IF\n      END IF\n      jmax25top = ((2.59_r8 - 0.035_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * vcmax25top) * params_inst % jmax25top_sf\n      tpu25top = params_inst % tpu25ratio * vcmax25top\n      kp25top = params_inst % kp25ratio * vcmax25top\n      IF (dayl_factor(p) \u003c 1.0E-12_r8) THEN\n        kn(p) = 0._r8\n      ELSE\n        kn(p) = EXP(0.00963_r8 * vcmax25top / dayl_factor(p) - 2.43_r8)\n      END IF\n      IF (use_cn) THEN\n        IF (leafresp_method == leafresp_mtd_ryan1991) THEN\n          lmr25top = 2.525E-6_r8 * (1.5_r8 ** ((25._r8 - 20._r8) / 10._r8))\n          lmr25top = lmr25top * lnc(p) / 12.E-06_r8\n        ELSE IF (leafresp_method == leafresp_mtd_atkin2015) THEN\n          IF (lnc(p) \u003e 0.0_r8) THEN\n            lmr25top = params_inst % lmr_intercept_atkin(ivt(p)) + (lnc(p) * 0.2061_r8) - (0.0402_r8 * (t10(p) - tfrz))\n          ELSE\n            lmr25top = 0.0_r8\n          END IF\n        END IF\n      ELSE\n        IF (c3flag(p)) THEN\n          lmr25top = vcmax25top * leaf_mr_vcm\n        ELSE\n          lmr25top = vcmax25top * 0.025_r8\n        END IF\n      END IF\n      laican = 0._r8\n      DO iv = 1, nrad(p)\n        IF (iv == 1) THEN\n          laican = 0.5_r8 * tlai_z(p, iv)\n        ELSE\n          laican = laican + 0.5_r8 * (tlai_z(p, iv - 1) + tlai_z(p, iv))\n        END IF\n        IF (nlevcan == 1) THEN\n          nscaler = vcmaxcint(p)\n        ELSE IF (nlevcan \u003e 1) THEN\n          nscaler = EXP(- kn(p) * laican)\n        END IF\n        lmr25 = lmr25top * nscaler\n        IF (use_luna .AND. c3flag(p) .AND. crop(patch % itype(p)) == 0) THEN\n          IF (.NOT. use_cn) THEN\n            lmr25 = leaf_mr_vcm * photosyns_inst % vcmx25_z_patch(p, iv)\n          END IF\n        END IF\n        IF (c3flag(p)) THEN\n          lmr_z(p, iv) = lmr25 * ft(t_veg(p), params_inst % lmrha) * fth(t_veg(p), params_inst % lmrhd, params_inst % lmrse, lmrc)\n        ELSE\n          lmr_z(p, iv) = lmr25 * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n          lmr_z(p, iv) = lmr_z(p, iv) / (1._r8 + EXP(1.3_r8 * (t_veg(p) - (tfrz + 55._r8))))\n        END IF\n        IF (par_z(p, iv) \u003c= 0._r8) THEN\n          vcmax_z(p, iv) = 0._r8\n          jmax_z(p, iv) = 0._r8\n          tpu_z(p, iv) = 0._r8\n          kp_z(p, iv) = 0._r8\n          IF (use_c13) THEN\n            alphapsn(p) = 1._r8\n          END IF\n        ELSE\n          IF (use_luna .AND. c3flag(p) .AND. crop(patch % itype(p)) == 0) THEN\n            vcmax25 = photosyns_inst % vcmx25_z_patch(p, iv)\n            jmax25 = photosyns_inst % jmx25_z_patch(p, iv)\n            tpu25 = params_inst % tpu25ratio * vcmax25\n            IF (phase == \u0027sha\u0027 .AND. surfalb_inst % vcmaxcintsun_patch(p) .GT. 0._r8 .AND. nlevcan == 1) THEN\n              vcmax25 = vcmax25 * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n              jmax25 = jmax25 * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n              tpu25 = tpu25 * surfalb_inst % vcmaxcintsha_patch(p) / surfalb_inst % vcmaxcintsun_patch(p)\n            END IF\n          ELSE\n            vcmax25 = vcmax25top * nscaler\n            jmax25 = jmax25top * nscaler\n            tpu25 = tpu25top * nscaler\n          END IF\n          kp25 = kp25top * nscaler\n          vcmaxse = (668.39_r8 - 1.07_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % vcmaxse_sf\n          jmaxse = (659.70_r8 - 0.75_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % jmaxse_sf\n          tpuse = (668.39_r8 - 1.07_r8 * MIN(MAX((t10(p) - tfrz), 11._r8), 35._r8)) * params_inst % tpuse_sf\n          vcmaxc = fth25(params_inst % vcmaxhd, vcmaxse)\n          jmaxc = fth25(params_inst % jmaxhd, jmaxse)\n          tpuc = fth25(params_inst % tpuhd, tpuse)\n          vcmax_z(p, iv) = vcmax25 * ft(t_veg(p), params_inst % vcmaxha) * fth(t_veg(p), params_inst % vcmaxhd, vcmaxse, vcmaxc)\n          jmax_z(p, iv) = jmax25 * ft(t_veg(p), params_inst % jmaxha) * fth(t_veg(p), params_inst % jmaxhd, jmaxse, jmaxc)\n          tpu_z(p, iv) = tpu25 * ft(t_veg(p), params_inst % tpuha) * fth(t_veg(p), params_inst % tpuhd, tpuse, tpuc)\n          IF (.NOT. c3flag(p)) THEN\n            vcmax_z(p, iv) = vcmax25 * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n            vcmax_z(p, iv) = vcmax_z(p, iv) / (1._r8 + EXP(0.2_r8 * ((tfrz + 15._r8) - t_veg(p))))\n            vcmax_z(p, iv) = vcmax_z(p, iv) / (1._r8 + EXP(0.3_r8 * (t_veg(p) - (tfrz + 40._r8))))\n          END IF\n          kp_z(p, iv) = kp25 * 2._r8 ** ((t_veg(p) - (tfrz + 25._r8)) / 10._r8)\n        END IF\n        vcmax_z(p, iv) = vcmax_z(p, iv) * btran(p)\n        lmr_z(p, iv) = lmr_z(p, iv) * btran(p)\n        IF (light_inhibit .AND. par_z(p, 1) \u003e 0._r8) THEN\n          lmr_z(p, iv) = lmr_z(p, iv) * 0.67_r8\n        END IF\n      END DO\n    END DO\n    rsmax0 = 2.E4_r8\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      g = patch % gridcell(p)\n      cf = forc_pbot(c) / (rgas * 1.E-3_r8 * tgcm(p)) * 1.E06_r8\n      gb = 1._r8 / rb(p)\n      gb_mol(p) = gb * cf\n      DO iv = 1, nrad(p)\n        IF (par_z(p, iv) \u003c= 0._r8) THEN\n          ac(p, iv) = 0._r8\n          aj(p, iv) = 0._r8\n          ap(p, iv) = 0._r8\n          ag(p, iv) = 0._r8\n          an(p, iv) = ag(p, iv) - lmr_z(p, iv)\n          psn_z(p, iv) = 0._r8\n          psn_wc_z(p, iv) = 0._r8\n          psn_wj_z(p, iv) = 0._r8\n          psn_wp_z(p, iv) = 0._r8\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            rs_z(p, iv) = MIN(rsmax0, 1._r8 / bbb(p) * cf)\n          ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n            rs_z(p, iv) = MIN(rsmax0, 1._r8 / medlynintercept(patch % itype(p)) * cf)\n          END IF\n          ci_z(p, iv) = 0._r8\n          rh_leaf(p) = 0._r8\n        ELSE\n          ceair = MIN(eair(p), esat_tv(p))\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            rh_can = ceair / esat_tv(p)\n          ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n            rh_can = MAX((esat_tv(p) - ceair), medlyn_rh_can_max) * medlyn_rh_can_fact\n            vpd_can(p) = rh_can\n          END IF\n          qabs = 0.5_r8 * (1._r8 - params_inst % fnps) * par_z(p, iv) * 4.6_r8\n          aquad = params_inst % theta_psii\n          bquad = - (qabs + jmax_z(p, iv))\n          cquad = qabs * jmax_z(p, iv)\n          CALL quadratic(aquad, bquad, cquad, r1, r2)\n          je = MIN(r1, r2)\n          IF (c3flag(p)) THEN\n            ci_z(p, iv) = 0.7_r8 * cair(p)\n          ELSE\n            ci_z(p, iv) = 0.4_r8 * cair(p)\n          END IF\n          niter = 0\n          niter = niter + 1\n          ciold = ci_z(p, iv)\n          CALL hybrid(ciold, p, iv, c, gb_mol(p), je, cair(p), oair(p), lmr_z(p, iv), par_z(p, iv), rh_can, gs_mol(p, iv), niter, atm2lnd_inst, photosyns_inst)\n          IF (an(p, iv) \u003c 0._r8) THEN\n            IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n              gs_mol(p, iv) = bbb(p)\n            ELSE IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n              gs_mol(p, iv) = medlynintercept(patch % itype(p))\n            END IF\n          END IF\n          IF (phase == \u0027sun\u0027) THEN\n            gs_mol_sun(p, iv) = gs_mol(p, iv)\n          ELSE IF (phase == \u0027sha\u0027) THEN\n            gs_mol_sha(p, iv) = gs_mol(p, iv)\n          END IF\n          IF (is_near_local_noon(grc % londeg(g), deltasec = 3600)) THEN\n            IF (phase == \u0027sun\u0027) THEN\n              gs_mol_sun_ln(p, iv) = gs_mol(p, iv)\n            ELSE IF (phase == \u0027sha\u0027) THEN\n              gs_mol_sha_ln(p, iv) = gs_mol(p, iv)\n            END IF\n          ELSE\n            IF (phase == \u0027sun\u0027) THEN\n              gs_mol_sun_ln(p, iv) = spval\n            ELSE IF (phase == \u0027sha\u0027) THEN\n              gs_mol_sha_ln(p, iv) = spval\n            END IF\n          END IF\n          cs = cair(p) - 1.4_r8 / gb_mol(p) * an(p, iv) * forc_pbot(c)\n          cs = MAX(cs, max_cs)\n          ci_z(p, iv) = cair(p) - an(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol(p, iv) + 1.6_r8 * gb_mol(p)) / (gb_mol(p) * gs_mol(p, iv))\n          ci_z(p, iv) = MAX(ci_z(p, iv), 1.E-06_r8)\n          gs = gs_mol(p, iv) / cf\n          rs_z(p, iv) = MIN(1._r8 / gs, rsmax0)\n          rs_z(p, iv) = rs_z(p, iv) / o3coefg(p)\n          psn_z(p, iv) = ag(p, iv)\n          psn_z(p, iv) = psn_z(p, iv) * o3coefv(p)\n          psn_wc_z(p, iv) = 0._r8\n          psn_wj_z(p, iv) = 0._r8\n          psn_wp_z(p, iv) = 0._r8\n          IF (ac(p, iv) \u003c= aj(p, iv) .AND. ac(p, iv) \u003c= ap(p, iv)) THEN\n            psn_wc_z(p, iv) = psn_z(p, iv)\n          ELSE IF (aj(p, iv) \u003c ac(p, iv) .AND. aj(p, iv) \u003c= ap(p, iv)) THEN\n            psn_wj_z(p, iv) = psn_z(p, iv)\n          ELSE IF (ap(p, iv) \u003c ac(p, iv) .AND. ap(p, iv) \u003c aj(p, iv)) THEN\n            psn_wp_z(p, iv) = psn_z(p, iv)\n          END IF\n          IF (gs_mol(p, iv) \u003c 0._r8) THEN\n            WRITE(iulog, *) \u0027Negative stomatal conductance:\u0027\n            WRITE(iulog, *) \u0027p,iv,gs_mol= \u0027, p, iv, gs_mol(p, iv)\n            CALL endrun(subgrid_index = p, subgrid_level = subgrid_level_patch, msg = errmsg(sourcefile, 1963))\n          END IF\n          IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n            hs = (gb_mol(p) * ceair + gs_mol(p, iv) * esat_tv(p)) / ((gb_mol(p) + gs_mol(p, iv)) * esat_tv(p))\n            rh_leaf(p) = hs\n            gs_mol_err = mbb(p) * MAX(an(p, iv), 0._r8) * hs / cs * forc_pbot(c) + bbb(p)\n            IF (ABS(gs_mol(p, iv) - gs_mol_err) \u003e 1.E-01_r8) THEN\n              WRITE(iulog, *) \u0027Ball-Berry error check - stomatal conductance error:\u0027\n              WRITE(iulog, *) gs_mol(p, iv), gs_mol_err\n            END IF\n          END IF\n        END IF\n      END DO\n    END DO\n    DO f = 1, fn\n      p = filterp(f)\n      psncan = 0._r8\n      psncan_wc = 0._r8\n      psncan_wj = 0._r8\n      psncan_wp = 0._r8\n      lmrcan = 0._r8\n      gscan = 0._r8\n      laican = 0._r8\n      DO iv = 1, nrad(p)\n        psncan = psncan + psn_z(p, iv) * lai_z(p, iv)\n        psncan_wc = psncan_wc + psn_wc_z(p, iv) * lai_z(p, iv)\n        psncan_wj = psncan_wj + psn_wj_z(p, iv) * lai_z(p, iv)\n        psncan_wp = psncan_wp + psn_wp_z(p, iv) * lai_z(p, iv)\n        lmrcan = lmrcan + lmr_z(p, iv) * lai_z(p, iv)\n        gscan = gscan + lai_z(p, iv) / (rb(p) + rs_z(p, iv))\n        laican = laican + lai_z(p, iv)\n      END DO\n      IF (laican \u003e 0._r8) THEN\n        psn(p) = psncan / laican\n        psn_wc(p) = psncan_wc / laican\n        psn_wj(p) = psncan_wj / laican\n        psn_wp(p) = psncan_wp / laican\n        lmr(p) = lmrcan / laican\n        rs(p) = laican / gscan - rb(p)\n      ELSE\n        psn(p) = 0._r8\n        psn_wc(p) = 0._r8\n        psn_wj(p) = 0._r8\n        psn_wp(p) = 0._r8\n        lmr(p) = 0._r8\n        rs(p) = 0._r8\n      END IF\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE Photosynthesis"}, {"color": "#97c2fc", "id": "brent", "label": "brent", "shape": "dot", "size": 10, "source": "SUBROUTINE brent(x, x1, x2, f1, f2, tol, ip, iv, ic, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  REAL(KIND = r8), INTENT(OUT) :: x\n  REAL(KIND = r8), INTENT(IN) :: x1, x2, f1, f2\n  REAL(KIND = r8), INTENT(IN) :: tol\n  REAL(KIND = r8), INTENT(IN) :: lmr_z\n  REAL(KIND = r8), INTENT(IN) :: par_z\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: je\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  INTEGER, INTENT(IN) :: ip, iv, ic\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  INTEGER, PARAMETER :: itmax = 20\n  REAL(KIND = r8), PARAMETER :: eps = 1.E-2_r8\n  INTEGER :: iter\n  REAL(KIND = r8) :: a, b, c, d, e, fa, fb, fc, p, q, r, s, tol1, xm\n  a = x1\n  b = x2\n  fa = f1\n  fb = f2\n  IF ((fa \u003e 0._r8 .AND. fb \u003e 0._r8) .OR. (fa \u003c 0._r8 .AND. fb \u003c 0._r8)) THEN\n    WRITE(iulog, *) \u0027root must be bracketed for brent\u0027\n    CALL endrun(subgrid_index = ip, subgrid_level = subgrid_level_patch, msg = errmsg(sourcefile, 2398))\n  END IF\n  c = b\n  fc = fb\n  iter = 0\n  DO\n    IF (iter == itmax) EXIT\n    iter = iter + 1\n    IF ((fb \u003e 0._r8 .AND. fc \u003e 0._r8) .OR. (fb \u003c 0._r8 .AND. fc \u003c 0._r8)) THEN\n      c = a\n      fc = fa\n      d = b - a\n      e = d\n    END IF\n    IF (ABS(fc) \u003c ABS(fb)) THEN\n      a = b\n      b = c\n      c = a\n      fa = fb\n      fb = fc\n      fc = fa\n    END IF\n    tol1 = 2._r8 * eps * ABS(b) + 0.5_r8 * tol\n    xm = 0.5_r8 * (c - b)\n    IF (ABS(xm) \u003c= tol1 .OR. fb == 0.) THEN\n      x = b\n      RETURN\n    END IF\n    IF (ABS(e) \u003e= tol1 .AND. ABS(fa) \u003e ABS(fb)) THEN\n      s = fb / fa\n      IF (a == c) THEN\n        p = 2._r8 * xm * s\n        q = 1._r8 - s\n      ELSE\n        q = fa / fc\n        r = fb / fc\n        p = s * (2._r8 * xm * q * (q - r) - (b - a) * (r - 1._r8))\n        q = (q - 1._r8) * (r - 1._r8) * (s - 1._r8)\n      END IF\n      IF (p \u003e 0._r8) q = - q\n      p = ABS(p)\n      IF (2._r8 * p \u003c MIN(3._r8 * xm * q - ABS(tol1 * q), ABS(e * q))) THEN\n        e = d\n        d = p / q\n      ELSE\n        d = xm\n        e = d\n      END IF\n    ELSE\n      d = xm\n      e = d\n    END IF\n    a = b\n    fa = fb\n    IF (ABS(d) \u003e tol1) THEN\n      b = b + d\n    ELSE\n      b = b + SIGN(tol1, xm)\n    END IF\n    CALL ci_func(b, fb, ip, iv, ic, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n    IF (fb == 0._r8) EXIT\n  END DO\n  IF (iter == itmax) WRITE(iulog, *) \u0027brent exceeding maximum iterations\u0027, b, fb\n  x = b\n  RETURN\nEND SUBROUTINE brent"}, {"color": "#97c2fc", "id": "plc", "label": "plc", "shape": "dot", "size": 10, "source": "FUNCTION plc(x, p, level, plc_method)\n  REAL(KIND = r8), INTENT(IN) :: x\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: level\n  INTEGER, INTENT(IN) :: plc_method\n  REAL(KIND = r8) :: plc\n  ASSOCIATE(ivt =\u003e patch % itype)\n    SELECT CASE (plc_method)\n    CASE (vegetation_weibull)\n      plc = 2._r8 ** (- (x / params_inst % psi50(ivt(p), level)) ** params_inst % ck(ivt(p), level))\n      IF (plc \u003c 0.005_r8) plc = 0._r8\n    CASE DEFAULT\n      plc = nan\n      CALL endrun(\u0027ERROR:: Photosynthesis::PLC must choose plc method\u0027)\n    END SELECT\n  END ASSOCIATE\nEND FUNCTION plc"}, {"color": "#97c2fc", "id": "d1plc", "label": "d1plc", "shape": "dot", "size": 10, "source": "FUNCTION d1plc(x, p, level, plc_method)\n  REAL(KIND = r8), INTENT(IN) :: x\n  INTEGER, INTENT(IN) :: p\n  INTEGER, INTENT(IN) :: level\n  INTEGER, INTENT(IN) :: plc_method\n  REAL(KIND = r8) :: d1plc\n  ASSOCIATE(ivt =\u003e patch % itype)\n    SELECT CASE (plc_method)\n    CASE (vegetation_weibull)\n      d1plc = - params_inst % ck(ivt(p), level) * LOG(2._r8) * (2._r8 ** (- (x / params_inst % psi50(ivt(p), level)) ** params_inst % ck(ivt(p), level))) * ((x / params_inst % psi50(ivt(p), level)) ** params_inst % ck(ivt(p), level)) / x\n    CASE DEFAULT\n      d1plc = nan\n      CALL endrun(\u0027ERROR:: Photosynthesis::D1PLC must choose plc method\u0027)\n    END SELECT\n  END ASSOCIATE\nEND FUNCTION d1plc"}, {"color": "#97c2fc", "id": "params_inst % allocParams", "label": "params_inst % allocParams", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "setParamsForTesting", "label": "setParamsForTesting", "shape": "dot", "size": 10, "source": "SUBROUTINE setParamsForTesting(this)\n  IMPLICIT NONE\n  CLASS(photosyns_type) :: this\n  CHARACTER(LEN = 32) :: subname = \u0027setParamsForTesting\u0027\n  CALL params_inst % allocParams\n  params_inst % ck = 3.95_r8\n  params_inst % psi50(1, :) = - 150000._r8\n  params_inst % psi50(2, :) = - 530000._r8\n  params_inst % psi50(3 : 12, :) = - 400000._r8\n  params_inst % psi50(13 :, :) = - 340000._r8\nEND SUBROUTINE setParamsForTesting"}, {"color": "#97c2fc", "id": "ncd_io", "label": "ncd_io", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "readNcdioScalar", "label": "readNcdioScalar", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "opnfil", "label": "opnfil", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "shr_nl_find_group_name", "label": "shr_nl_find_group_name", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "relavu", "label": "relavu", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "shr_mpi_bcast", "label": "shr_mpi_bcast", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "restartvar", "label": "restartvar", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Restart", "label": "Restart", "shape": "dot", "size": 10, "source": "SUBROUTINE Restart(this, bounds, ncid, flag)\n  USE ncdio_pio, ONLY: file_desc_t, ncd_defvar, ncd_io, ncd_double, ncd_int, ncd_inqvdlen\n  USE restUtilMod\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  TYPE(file_desc_t), INTENT(INOUT) :: ncid\n  CHARACTER(LEN = *), INTENT(IN) :: flag\n  INTEGER :: j, c\n  LOGICAL :: readvar\n  IF (use_c13) THEN\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027rc13_canair\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027\u0027, units = \u0027\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % rc13_canair_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027rc13_psnsun\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027\u0027, units = \u0027\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % rc13_psnsun_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027rc13_psnsha\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027\u0027, units = \u0027\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % rc13_psnsha_patch)\n  END IF\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSUN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027sunlit leaf stomatal conductance\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sun_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSHA\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027shaded leaf stomatal conductance\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sha_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSUNLN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027sunlit leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sun_ln_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027GSSHALN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027shaded leaf stomatal conductance averaged over 1 hour before to 1 hour after local noon\u0027, units = \u0027umol H20/m2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % gs_mol_sha_ln_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027lnca\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027leaf N concentration\u0027, units = \u0027gN leaf/m^2\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % lnca_patch)\n  IF (use_luna) THEN\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027vcmx25_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027Maximum carboxylation rate at 25 Celcius for canopy layers\u0027, units = \u0027umol CO2/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % vcmx25_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027jmx25_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027Maximum rate of electron transport at 25 Celcius for canopy layers\u0027, units = \u0027umol electrons/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % jmx25_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027vcmx25_z_last_valid_patch:vcmx_prevyr\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027avg carboxylation rate at 25 celsius for canopy layers\u0027, units = \u0027umol CO2/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % vcmx25_z_last_valid_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027jmx25_z_last_valid_patch:jmx_prevyr\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027avg rate of electron transport at 25 Celcius for canopy layers\u0027, units = \u0027umol electrons/m**2/s\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % jmx25_z_last_valid_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027pnlc_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027proportion of leaf nitrogen allocated for light capture\u0027, units = \u0027unitless\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % pnlc_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027enzs_z\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, dim2name = \u0027levcan\u0027, switchdim = .TRUE., long_name = \u0027enzyme decay status during stress: 1.0-fully active; 0.0-all decayed\u0027, units = \u0027unitless\u0027, scale_by_thickness = .FALSE., interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % enzs_z_patch)\n    CALL restartvar(ncid = ncid, flag = flag, varname = \u0027gpp24\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027accumulative gross primary production\u0027, units = \u0027umol CO2/m**2 ground/day\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % fpsn24_patch)\n  END IF\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027vcmx25t\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy profile of vcmax25\u0027, units = \u0027umol/m2/s\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % luvcmax25top_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027jmx25t\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy profile of jmax\u0027, units = \u0027umol/m2/s\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % lujmax25top_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027tpu25t\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy profile of tpu\u0027, units = \u0027umol/m2/s\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % lutpu25top_patch)\n  CALL restartvar(ncid = ncid, flag = flag, varname = \u0027VPD_CAN\u0027, xtype = ncd_double, dim1name = \u0027pft\u0027, long_name = \u0027canopy vapor pressure deficit\u0027, units = \u0027kPa\u0027, interpinic_flag = \u0027interp\u0027, readvar = readvar, data = this % vpd_can_patch)\nEND SUBROUTINE Restart"}, {"color": "#97c2fc", "id": "shr_assert_all", "label": "shr_assert_all", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "Fractionation", "label": "Fractionation", "shape": "dot", "size": 10, "source": "SUBROUTINE Fractionation(bounds, fn, filterp, downreg, atm2lnd_inst, canopystate_inst, solarabs_inst, surfalb_inst, photosyns_inst, phase)\n  USE clm_varctl, ONLY: use_hydrstress\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER, INTENT(IN) :: fn\n  INTEGER, INTENT(IN) :: filterp(fn)\n  REAL(KIND = r8), INTENT(IN) :: downreg(bounds % begp :)\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(solarabs_type), INTENT(IN) :: solarabs_inst\n  TYPE(surfalb_type), INTENT(IN) :: surfalb_inst\n  TYPE(photosyns_type), INTENT(IN) :: photosyns_inst\n  CHARACTER(LEN = *), INTENT(IN) :: phase\n  REAL(KIND = r8), POINTER :: par_z(:, :)\n  REAL(KIND = r8), POINTER :: alphapsn(:)\n  REAL(KIND = r8), POINTER :: gs_mol(:, :)\n  REAL(KIND = r8), POINTER :: an(:, :)\n  INTEGER :: f, p, c, g, iv\n  REAL(KIND = r8) :: co2(bounds % begp : bounds % endp)\n  REAL(KIND = r8) :: ci\n  CALL shr_assert_all((UBOUND(downreg) == (/bounds % endp/)), file = sourcefile, line = 2181)\n  ASSOCIATE(forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, forc_pco2 =\u003e atm2lnd_inst % forc_pco2_grc, c3psn =\u003e pftcon % c3psn, nrad =\u003e surfalb_inst % nrad_patch, gb_mol =\u003e photosyns_inst % gb_mol_patch)\n    IF (phase == \u0027sun\u0027) THEN\n      par_z =\u003e solarabs_inst % parsun_z_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsun_patch\n      IF (use_hydrstress) THEN\n        gs_mol =\u003e photosyns_inst % gs_mol_sun_patch\n        an =\u003e photosyns_inst % an_sun_patch\n      ELSE\n        gs_mol =\u003e photosyns_inst % gs_mol_patch\n        an =\u003e photosyns_inst % an_patch\n      END IF\n    ELSE IF (phase == \u0027sha\u0027) THEN\n      par_z =\u003e solarabs_inst % parsha_z_patch\n      alphapsn =\u003e photosyns_inst % alphapsnsha_patch\n      IF (use_hydrstress) THEN\n        gs_mol =\u003e photosyns_inst % gs_mol_sha_patch\n        an =\u003e photosyns_inst % an_sha_patch\n      ELSE\n        gs_mol =\u003e photosyns_inst % gs_mol_patch\n        an =\u003e photosyns_inst % an_patch\n      END IF\n    END IF\n    DO f = 1, fn\n      p = filterp(f)\n      c = patch % column(p)\n      g = patch % gridcell(p)\n      co2(p) = forc_pco2(g)\n      DO iv = 1, nrad(p)\n        IF (par_z(p, iv) \u003c= 0._r8) THEN\n          alphapsn(p) = 1._r8\n        ELSE\n          ci = co2(p) - (an(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol(p, iv) + 1.6_r8 * gb_mol(p)) / (gb_mol(p) * gs_mol(p, iv)))\n          alphapsn(p) = 1._r8 + (((c3psn(patch % itype(p)) * (4.4_r8 + (22.6_r8 * (ci / co2(p))))) + ((1._r8 - c3psn(patch % itype(p))) * 4.4_r8)) / 1000._r8)\n        END IF\n      END DO\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE Fractionation"}, {"color": "#97c2fc", "id": "quadratic", "label": "quadratic", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "ci_func", "label": "ci_func", "shape": "dot", "size": 10, "source": "SUBROUTINE ci_func(ci, fval, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  REAL(KIND = r8), INTENT(IN) :: ci\n  REAL(KIND = r8), INTENT(IN) :: lmr_z\n  REAL(KIND = r8), INTENT(IN) :: par_z\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: je\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  INTEGER, INTENT(IN) :: p, iv, c\n  REAL(KIND = r8), INTENT(OUT) :: fval\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  REAL(KIND = r8) :: ai\n  REAL(KIND = r8) :: cs\n  REAL(KIND = r8) :: term\n  REAL(KIND = r8) :: aquad, bquad, cquad\n  REAL(KIND = r8) :: r1, r2\n  ASSOCIATE(forc_pbot =\u003e atm2lnd_inst % forc_pbot_downscaled_col, c3flag =\u003e photosyns_inst % c3flag_patch, ivt =\u003e patch % itype, medlynslope =\u003e pftcon % medlynslope, medlynintercept =\u003e pftcon % medlynintercept, stomatalcond_mtd =\u003e photosyns_inst % stomatalcond_mtd, ac =\u003e photosyns_inst % ac_patch, aj =\u003e photosyns_inst % aj_patch, ap =\u003e photosyns_inst % ap_patch, ag =\u003e photosyns_inst % ag_patch, an =\u003e photosyns_inst % an_patch, vcmax_z =\u003e photosyns_inst % vcmax_z_patch, cp =\u003e photosyns_inst % cp_patch, kc =\u003e photosyns_inst % kc_patch, ko =\u003e photosyns_inst % ko_patch, qe =\u003e photosyns_inst % qe_patch, tpu_z =\u003e photosyns_inst % tpu_z_patch, kp_z =\u003e photosyns_inst % kp_z_patch, bbb =\u003e photosyns_inst % bbb_patch, mbb =\u003e photosyns_inst % mbb_patch)\n    IF (c3flag(p)) THEN\n      ac(p, iv) = vcmax_z(p, iv) * MAX(ci - cp(p), 0._r8) / (ci + kc(p) * (1._r8 + oair / ko(p)))\n      aj(p, iv) = je * MAX(ci - cp(p), 0._r8) / (4._r8 * ci + 8._r8 * cp(p))\n      ap(p, iv) = 3._r8 * tpu_z(p, iv)\n    ELSE\n      ac(p, iv) = vcmax_z(p, iv)\n      aj(p, iv) = qe(p) * par_z * 4.6_r8\n      ap(p, iv) = kp_z(p, iv) * MAX(ci, 0._r8) / forc_pbot(c)\n    END IF\n    aquad = params_inst % theta_cj(ivt(p))\n    bquad = - (ac(p, iv) + aj(p, iv))\n    cquad = ac(p, iv) * aj(p, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ai = MIN(r1, r2)\n    aquad = params_inst % theta_ip\n    bquad = - (ai + ap(p, iv))\n    cquad = ai * ap(p, iv)\n    CALL quadratic(aquad, bquad, cquad, r1, r2)\n    ag(p, iv) = MAX(0._r8, MIN(r1, r2))\n    an(p, iv) = ag(p, iv) - lmr_z\n    IF (an(p, iv) \u003c 0._r8) THEN\n      fval = 0._r8\n      RETURN\n    END IF\n    cs = cair - 1.4_r8 / gb_mol * an(p, iv) * forc_pbot(c)\n    cs = MAX(cs, max_cs)\n    IF (stomatalcond_mtd == stomatalcond_mtd_medlyn2011) THEN\n      term = 1.6_r8 * an(p, iv) / (cs / forc_pbot(c) * 1.E06_r8)\n      aquad = 1.0_r8\n      bquad = - (2.0 * (medlynintercept(patch % itype(p)) * 1.E-06_r8 + term) + (medlynslope(patch % itype(p)) * term) ** 2 / (gb_mol * 1.E-06_r8 * rh_can))\n      cquad = medlynintercept(patch % itype(p)) * medlynintercept(patch % itype(p)) * 1.E-12_r8 + (2.0 * medlynintercept(patch % itype(p)) * 1.E-06_r8 + term * (1.0 - medlynslope(patch % itype(p)) * medlynslope(patch % itype(p)) / rh_can)) * term\n      CALL quadratic(aquad, bquad, cquad, r1, r2)\n      gs_mol = MAX(r1, r2) * 1.E06_r8\n    ELSE IF (stomatalcond_mtd == stomatalcond_mtd_bb1987) THEN\n      aquad = cs\n      bquad = cs * (gb_mol - bbb(p)) - mbb(p) * an(p, iv) * forc_pbot(c)\n      cquad = - gb_mol * (cs * bbb(p) + mbb(p) * an(p, iv) * forc_pbot(c) * rh_can)\n      CALL quadratic(aquad, bquad, cquad, r1, r2)\n      gs_mol = MAX(r1, r2)\n    END IF\n    fval = ci - cair + an(p, iv) * forc_pbot(c) * (1.4_r8 * gs_mol + 1.6_r8 * gb_mol) / (gb_mol * gs_mol)\n  END ASSOCIATE\nEND SUBROUTINE ci_func"}, {"color": "#97c2fc", "id": "hybrid", "label": "hybrid", "shape": "dot", "size": 10, "source": "SUBROUTINE hybrid(x0, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, iter, atm2lnd_inst, photosyns_inst)\n  IMPLICIT NONE\n  REAL(KIND = r8), INTENT(INOUT) :: x0\n  REAL(KIND = r8), INTENT(IN) :: lmr_z\n  REAL(KIND = r8), INTENT(IN) :: par_z\n  REAL(KIND = r8), INTENT(IN) :: rh_can\n  REAL(KIND = r8), INTENT(IN) :: gb_mol\n  REAL(KIND = r8), INTENT(IN) :: je\n  REAL(KIND = r8), INTENT(IN) :: cair\n  REAL(KIND = r8), INTENT(IN) :: oair\n  INTEGER, INTENT(IN) :: p, iv, c\n  REAL(KIND = r8), INTENT(OUT) :: gs_mol\n  INTEGER, INTENT(OUT) :: iter\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  REAL(KIND = r8) :: a, b\n  REAL(KIND = r8) :: fa, fb\n  REAL(KIND = r8) :: x1, f0, f1\n  REAL(KIND = r8) :: x, dx\n  REAL(KIND = r8), PARAMETER :: eps = 1.E-2_r8\n  REAL(KIND = r8), PARAMETER :: eps1 = 1.E-4_r8\n  INTEGER, PARAMETER :: itmax = 40\n  REAL(KIND = r8) :: tol, minx, minf\n  CALL ci_func(x0, f0, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  IF (f0 == 0._r8) RETURN\n  minx = x0\n  minf = f0\n  x1 = x0 * 0.99_r8\n  CALL ci_func(x1, f1, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n  IF (f1 == 0._r8) THEN\n    x0 = x1\n    RETURN\n  END IF\n  IF (f1 \u003c minf) THEN\n    minx = x1\n    minf = f1\n  END IF\n  iter = 0\n  DO\n    iter = iter + 1\n    dx = - f1 * (x1 - x0) / (f1 - f0)\n    x = x1 + dx\n    tol = ABS(x) * eps\n    IF (ABS(dx) \u003c tol) THEN\n      x0 = x\n      EXIT\n    END IF\n    x0 = x1\n    f0 = f1\n    x1 = x\n    CALL ci_func(x1, f1, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n    IF (f1 \u003c minf) THEN\n      minx = x1\n      minf = f1\n    END IF\n    IF (ABS(f1) \u003c= eps1) THEN\n      x0 = x1\n      EXIT\n    END IF\n    IF (f1 * f0 \u003c 0._r8) THEN\n      CALL brent(x, x0, x1, f0, f1, tol, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n      x0 = x\n      EXIT\n    END IF\n    IF (iter \u003e itmax) THEN\n      CALL ci_func(minx, f1, p, iv, c, gb_mol, je, cair, oair, lmr_z, par_z, rh_can, gs_mol, atm2lnd_inst, photosyns_inst)\n      EXIT\n    END IF\n  END DO\nEND SUBROUTINE hybrid"}, {"color": "#97c2fc", "id": "C14BombSpike", "label": "C14BombSpike", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "PhotosynthesisTotal", "label": "PhotosynthesisTotal", "shape": "dot", "size": 10, "source": "SUBROUTINE PhotosynthesisTotal(fn, filterp, atm2lnd_inst, canopystate_inst, photosyns_inst)\n  INTEGER, INTENT(IN) :: fn\n  INTEGER, INTENT(IN) :: filterp(fn)\n  TYPE(atm2lnd_type), INTENT(IN) :: atm2lnd_inst\n  TYPE(canopystate_type), INTENT(IN) :: canopystate_inst\n  TYPE(photosyns_type), INTENT(INOUT) :: photosyns_inst\n  INTEGER :: f, fp, p, l, g\n  REAL(KIND = r8) :: rc14_atm(nsectors_c14), rc13_atm\n  INTEGER :: sector_c14\n  ASSOCIATE(forc_pco2 =\u003e atm2lnd_inst % forc_pco2_grc, forc_pc13o2 =\u003e atm2lnd_inst % forc_pc13o2_grc, forc_po2 =\u003e atm2lnd_inst % forc_po2_grc, laisun =\u003e canopystate_inst % laisun_patch, laisha =\u003e canopystate_inst % laisha_patch, psnsun =\u003e photosyns_inst % psnsun_patch, psnsha =\u003e photosyns_inst % psnsha_patch, rc13_canair =\u003e photosyns_inst % rc13_canair_patch, rc13_psnsun =\u003e photosyns_inst % rc13_psnsun_patch, rc13_psnsha =\u003e photosyns_inst % rc13_psnsha_patch, alphapsnsun =\u003e photosyns_inst % alphapsnsun_patch, alphapsnsha =\u003e photosyns_inst % alphapsnsha_patch, psnsun_wc =\u003e photosyns_inst % psnsun_wc_patch, psnsun_wj =\u003e photosyns_inst % psnsun_wj_patch, psnsun_wp =\u003e photosyns_inst % psnsun_wp_patch, psnsha_wc =\u003e photosyns_inst % psnsha_wc_patch, psnsha_wj =\u003e photosyns_inst % psnsha_wj_patch, psnsha_wp =\u003e photosyns_inst % psnsha_wp_patch, c13_psnsun =\u003e photosyns_inst % c13_psnsun_patch, c13_psnsha =\u003e photosyns_inst % c13_psnsha_patch, c14_psnsun =\u003e photosyns_inst % c14_psnsun_patch, c14_psnsha =\u003e photosyns_inst % c14_psnsha_patch, fpsn =\u003e photosyns_inst % fpsn_patch, fpsn_wc =\u003e photosyns_inst % fpsn_wc_patch, fpsn_wj =\u003e photosyns_inst % fpsn_wj_patch, fpsn_wp =\u003e photosyns_inst % fpsn_wp_patch)\n    IF (use_c14) THEN\n      IF (use_c14_bombspike) THEN\n        CALL C14BombSpike(rc14_atm)\n      ELSE\n        rc14_atm(:) = c14ratio\n      END IF\n    END IF\n    IF (use_c13) THEN\n      IF (use_c13_timeseries) THEN\n        CALL C13TimeSeries(rc13_atm)\n      END IF\n    END IF\n    DO f = 1, fn\n      p = filterp(f)\n      g = patch % gridcell(p)\n      IF (.NOT. use_fates) THEN\n        fpsn(p) = psnsun(p) * laisun(p) + psnsha(p) * laisha(p)\n        fpsn_wc(p) = psnsun_wc(p) * laisun(p) + psnsha_wc(p) * laisha(p)\n        fpsn_wj(p) = psnsun_wj(p) * laisun(p) + psnsha_wj(p) * laisha(p)\n        fpsn_wp(p) = psnsun_wp(p) * laisun(p) + psnsha_wp(p) * laisha(p)\n      END IF\n      IF (use_cn) THEN\n        IF (use_c13) THEN\n          IF (use_c13_timeseries) THEN\n            rc13_canair(p) = rc13_atm\n          ELSE\n            rc13_canair(p) = forc_pc13o2(g) / (forc_pco2(g) - forc_pc13o2(g))\n          END IF\n          rc13_psnsun(p) = rc13_canair(p) / alphapsnsun(p)\n          rc13_psnsha(p) = rc13_canair(p) / alphapsnsha(p)\n          c13_psnsun(p) = psnsun(p) * (rc13_psnsun(p) / (1._r8 + rc13_psnsun(p)))\n          c13_psnsha(p) = psnsha(p) * (rc13_psnsha(p) / (1._r8 + rc13_psnsha(p)))\n        END IF\n        IF (use_c14) THEN\n          IF (grc % latdeg(g) .GE. 30._r8) THEN\n            sector_c14 = 1\n          ELSE IF (grc % latdeg(g) .GE. - 30._r8) THEN\n            sector_c14 = 2\n          ELSE\n            sector_c14 = 3\n          END IF\n          c14_psnsun(p) = rc14_atm(sector_c14) * psnsun(p)\n          c14_psnsha(p) = rc14_atm(sector_c14) * psnsha(p)\n        END IF\n      END IF\n    END DO\n  END ASSOCIATE\nEND SUBROUTINE PhotosynthesisTotal"}, {"color": "#97c2fc", "id": "C13TimeSeries", "label": "C13TimeSeries", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "InitAllocate", "label": "InitAllocate", "shape": "dot", "size": 10, "source": "SUBROUTINE InitAllocate(this, bounds)\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER :: begp, endp\n  INTEGER :: begc, endc\n  begp = bounds % begp\n  endp = bounds % endp\n  begc = bounds % begc\n  endc = bounds % endc\n  ALLOCATE(this % c3flag_patch(begp : endp))\n  this % c3flag_patch(:) = .FALSE.\n  ALLOCATE(this % ac_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % ac_phs_patch(:, :, :) = nan\n  ALLOCATE(this % aj_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % aj_phs_patch(:, :, :) = nan\n  ALLOCATE(this % ap_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % ap_phs_patch(:, :, :) = nan\n  ALLOCATE(this % ag_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % ag_phs_patch(:, :, :) = nan\n  ALLOCATE(this % an_sun_patch(begp : endp, 1 : nlevcan))\n  this % an_sun_patch(:, :) = nan\n  ALLOCATE(this % an_sha_patch(begp : endp, 1 : nlevcan))\n  this % an_sha_patch(:, :) = nan\n  ALLOCATE(this % vcmax_z_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % vcmax_z_phs_patch(:, :, :) = nan\n  ALLOCATE(this % tpu_z_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % tpu_z_phs_patch(:, :, :) = nan\n  ALLOCATE(this % kp_z_phs_patch(begp : endp, 2, 1 : nlevcan))\n  this % kp_z_phs_patch(:, :, :) = nan\n  ALLOCATE(this % gs_mol_sun_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sun_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_sha_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sha_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_sun_ln_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sun_ln_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_sha_ln_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_sha_ln_patch(:, :) = nan\n  ALLOCATE(this % ac_patch(begp : endp, 1 : nlevcan))\n  this % ac_patch(:, :) = nan\n  ALLOCATE(this % aj_patch(begp : endp, 1 : nlevcan))\n  this % aj_patch(:, :) = nan\n  ALLOCATE(this % ap_patch(begp : endp, 1 : nlevcan))\n  this % ap_patch(:, :) = nan\n  ALLOCATE(this % ag_patch(begp : endp, 1 : nlevcan))\n  this % ag_patch(:, :) = nan\n  ALLOCATE(this % an_patch(begp : endp, 1 : nlevcan))\n  this % an_patch(:, :) = nan\n  ALLOCATE(this % vcmax_z_patch(begp : endp, 1 : nlevcan))\n  this % vcmax_z_patch(:, :) = nan\n  ALLOCATE(this % tpu_z_patch(begp : endp, 1 : nlevcan))\n  this % tpu_z_patch(:, :) = nan\n  ALLOCATE(this % kp_z_patch(begp : endp, 1 : nlevcan))\n  this % kp_z_patch(:, :) = nan\n  ALLOCATE(this % gs_mol_patch(begp : endp, 1 : nlevcan))\n  this % gs_mol_patch(:, :) = nan\n  ALLOCATE(this % cp_patch(begp : endp))\n  this % cp_patch(:) = nan\n  ALLOCATE(this % kc_patch(begp : endp))\n  this % kc_patch(:) = nan\n  ALLOCATE(this % ko_patch(begp : endp))\n  this % ko_patch(:) = nan\n  ALLOCATE(this % qe_patch(begp : endp))\n  this % qe_patch(:) = nan\n  ALLOCATE(this % bbb_patch(begp : endp))\n  this % bbb_patch(:) = nan\n  ALLOCATE(this % mbb_patch(begp : endp))\n  this % mbb_patch(:) = nan\n  ALLOCATE(this % gb_mol_patch(begp : endp))\n  this % gb_mol_patch(:) = nan\n  ALLOCATE(this % rh_leaf_patch(begp : endp))\n  this % rh_leaf_patch(:) = nan\n  ALLOCATE(this % vpd_can_patch(begp : endp))\n  this % vpd_can_patch(:) = nan\n  ALLOCATE(this % psnsun_patch(begp : endp))\n  this % psnsun_patch(:) = nan\n  ALLOCATE(this % psnsha_patch(begp : endp))\n  this % psnsha_patch(:) = nan\n  ALLOCATE(this % c13_psnsun_patch(begp : endp))\n  this % c13_psnsun_patch(:) = nan\n  ALLOCATE(this % c13_psnsha_patch(begp : endp))\n  this % c13_psnsha_patch(:) = nan\n  ALLOCATE(this % c14_psnsun_patch(begp : endp))\n  this % c14_psnsun_patch(:) = nan\n  ALLOCATE(this % c14_psnsha_patch(begp : endp))\n  this % c14_psnsha_patch(:) = nan\n  ALLOCATE(this % psnsun_z_patch(begp : endp, 1 : nlevcan))\n  this % psnsun_z_patch(:, :) = nan\n  ALLOCATE(this % psnsha_z_patch(begp : endp, 1 : nlevcan))\n  this % psnsha_z_patch(:, :) = nan\n  ALLOCATE(this % psnsun_wc_patch(begp : endp))\n  this % psnsun_wc_patch(:) = nan\n  ALLOCATE(this % psnsha_wc_patch(begp : endp))\n  this % psnsha_wc_patch(:) = nan\n  ALLOCATE(this % psnsun_wj_patch(begp : endp))\n  this % psnsun_wj_patch(:) = nan\n  ALLOCATE(this % psnsha_wj_patch(begp : endp))\n  this % psnsha_wj_patch(:) = nan\n  ALLOCATE(this % psnsun_wp_patch(begp : endp))\n  this % psnsun_wp_patch(:) = nan\n  ALLOCATE(this % psnsha_wp_patch(begp : endp))\n  this % psnsha_wp_patch(:) = nan\n  ALLOCATE(this % fpsn_patch(begp : endp))\n  this % fpsn_patch(:) = nan\n  ALLOCATE(this % fpsn_wc_patch(begp : endp))\n  this % fpsn_wc_patch(:) = nan\n  ALLOCATE(this % fpsn_wj_patch(begp : endp))\n  this % fpsn_wj_patch(:) = nan\n  ALLOCATE(this % fpsn_wp_patch(begp : endp))\n  this % fpsn_wp_patch(:) = nan\n  ALLOCATE(this % lnca_patch(begp : endp))\n  this % lnca_patch(:) = nan\n  ALLOCATE(this % lmrsun_z_patch(begp : endp, 1 : nlevcan))\n  this % lmrsun_z_patch(:, :) = nan\n  ALLOCATE(this % lmrsha_z_patch(begp : endp, 1 : nlevcan))\n  this % lmrsha_z_patch(:, :) = nan\n  ALLOCATE(this % lmrsun_patch(begp : endp))\n  this % lmrsun_patch(:) = nan\n  ALLOCATE(this % lmrsha_patch(begp : endp))\n  this % lmrsha_patch(:) = nan\n  ALLOCATE(this % alphapsnsun_patch(begp : endp))\n  this % alphapsnsun_patch(:) = nan\n  ALLOCATE(this % alphapsnsha_patch(begp : endp))\n  this % alphapsnsha_patch(:) = nan\n  ALLOCATE(this % rc13_canair_patch(begp : endp))\n  this % rc13_canair_patch(:) = nan\n  ALLOCATE(this % rc13_psnsun_patch(begp : endp))\n  this % rc13_psnsun_patch(:) = nan\n  ALLOCATE(this % rc13_psnsha_patch(begp : endp))\n  this % rc13_psnsha_patch(:) = nan\n  ALLOCATE(this % cisun_z_patch(begp : endp, 1 : nlevcan))\n  this % cisun_z_patch(:, :) = nan\n  ALLOCATE(this % cisha_z_patch(begp : endp, 1 : nlevcan))\n  this % cisha_z_patch(:, :) = nan\n  ALLOCATE(this % rssun_z_patch(begp : endp, 1 : nlevcan))\n  this % rssun_z_patch(:, :) = nan\n  ALLOCATE(this % rssha_z_patch(begp : endp, 1 : nlevcan))\n  this % rssha_z_patch(:, :) = nan\n  ALLOCATE(this % rssun_patch(begp : endp))\n  this % rssun_patch(:) = nan\n  ALLOCATE(this % rssha_patch(begp : endp))\n  this % rssha_patch(:) = nan\n  ALLOCATE(this % luvcmax25top_patch(begp : endp))\n  this % luvcmax25top_patch(:) = nan\n  ALLOCATE(this % lujmax25top_patch(begp : endp))\n  this % lujmax25top_patch(:) = nan\n  ALLOCATE(this % lutpu25top_patch(begp : endp))\n  this % lutpu25top_patch(:) = nan\n  IF (use_luna) THEN\n    ALLOCATE(this % vcmx25_z_patch(begp : endp, 1 : nlevcan))\n    this % vcmx25_z_patch(:, :) = 30._r8\n    ALLOCATE(this % jmx25_z_patch(begp : endp, 1 : nlevcan))\n    this % jmx25_z_patch(:, :) = 60._r8\n    ALLOCATE(this % vcmx25_z_last_valid_patch(begp : endp, 1 : nlevcan))\n    this % vcmx25_z_last_valid_patch(:, :) = 30._r8\n    ALLOCATE(this % jmx25_z_last_valid_patch(begp : endp, 1 : nlevcan))\n    this % jmx25_z_last_valid_patch(:, :) = 60._r8\n    ALLOCATE(this % pnlc_z_patch(begp : endp, 1 : nlevcan))\n    this % pnlc_z_patch(:, :) = 0.01_r8\n    ALLOCATE(this % fpsn24_patch(begp : endp))\n    this % fpsn24_patch(:) = nan\n    ALLOCATE(this % enzs_z_patch(begp : endp, 1 : nlevcan))\n    this % enzs_z_patch(:, :) = 1._r8\n  END IF\nEND SUBROUTINE InitAllocate"}, {"color": "#97c2fc", "id": "InitCold", "label": "InitCold", "shape": "dot", "size": 10, "source": "SUBROUTINE InitCold(this, bounds)\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER :: p, l\n  DO p = bounds % begp, bounds % endp\n    l = patch % landunit(p)\n    this % alphapsnsun_patch(p) = spval\n    this % alphapsnsha_patch(p) = spval\n    IF (lun % ifspecial(l)) THEN\n      this % psnsun_patch(p) = 0._r8\n      this % psnsha_patch(p) = 0._r8\n      IF (use_c13) THEN\n        this % c13_psnsun_patch(p) = 0._r8\n        this % c13_psnsha_patch(p) = 0._r8\n      END IF\n      IF (use_c14) THEN\n        this % c14_psnsun_patch(p) = 0._r8\n        this % c14_psnsha_patch(p) = 0._r8\n      END IF\n    END IF\n  END DO\nEND SUBROUTINE InitCold"}, {"color": "#97c2fc", "id": "cleanParams", "label": "cleanParams", "shape": "dot", "size": 10, "source": "SUBROUTINE cleanParams(this)\n  IMPLICIT NONE\n  CLASS(photo_params_type) :: this\n  CHARACTER(LEN = 32) :: subname = \u0027cleanParams\u0027\n  DEALLOCATE(this % krmax)\n  DEALLOCATE(this % theta_cj)\n  DEALLOCATE(this % kmax)\n  DEALLOCATE(this % psi50)\n  DEALLOCATE(this % ck)\nEND SUBROUTINE cleanParams"}, {"color": "#97c2fc", "id": "TimeStepInit", "label": "TimeStepInit", "shape": "dot", "size": 10, "source": "SUBROUTINE TimeStepInit(this, bounds)\n  USE landunit_varcon, ONLY: istsoil, istcrop, istice, istwet\n  CLASS(photosyns_type) :: this\n  TYPE(bounds_type), INTENT(IN) :: bounds\n  INTEGER :: p, l\n  DO p = bounds % begp, bounds % endp\n    l = patch % landunit(p)\n    IF (.NOT. lun % lakpoi(l)) THEN\n      this % psnsun_patch(p) = 0._r8\n      this % psnsun_wc_patch(p) = 0._r8\n      this % psnsun_wj_patch(p) = 0._r8\n      this % psnsun_wp_patch(p) = 0._r8\n      this % psnsha_patch(p) = 0._r8\n      this % psnsha_wc_patch(p) = 0._r8\n      this % psnsha_wj_patch(p) = 0._r8\n      this % psnsha_wp_patch(p) = 0._r8\n      this % fpsn_patch(p) = 0._r8\n      this % fpsn_wc_patch(p) = 0._r8\n      this % fpsn_wj_patch(p) = 0._r8\n      this % fpsn_wp_patch(p) = 0._r8\n      IF (use_c13) THEN\n        this % alphapsnsun_patch(p) = 0._r8\n        this % alphapsnsha_patch(p) = 0._r8\n        this % c13_psnsun_patch(p) = 0._r8\n        this % c13_psnsha_patch(p) = 0._r8\n      END IF\n      IF (use_c14) THEN\n        this % c14_psnsun_patch(p) = 0._r8\n        this % c14_psnsha_patch(p) = 0._r8\n      END IF\n    END IF\n    IF (lun % itype(l) == istsoil .OR. lun % itype(l) == istcrop .OR. lun % itype(l) == istice .OR. lun % itype(l) == istwet) THEN\n      IF (use_c13) THEN\n        this % rc13_canair_patch(p) = 0._r8\n        this % rc13_psnsun_patch(p) = 0._r8\n        this % rc13_psnsha_patch(p) = 0._r8\n      END IF\n    END IF\n  END DO\nEND SUBROUTINE TimeStepInit"}, {"color": "#97c2fc", "id": "NewPatchInit", "label": "NewPatchInit", "shape": "dot", "size": 10, "source": "SUBROUTINE NewPatchInit(this, p)\n  CLASS(photosyns_type) :: this\n  INTEGER, INTENT(IN) :: p\n  IF (use_c13) THEN\n    this % alphapsnsun_patch(p) = 0._r8\n    this % alphapsnsha_patch(p) = 0._r8\n    this % rc13_canair_patch(p) = 0._r8\n    this % rc13_psnsun_patch(p) = 0._r8\n    this % rc13_psnsha_patch(p) = 0._r8\n  END IF\n  this % psnsun_patch(p) = 0._r8\n  this % psnsha_patch(p) = 0._r8\n  IF (use_c13) THEN\n    this % c13_psnsun_patch(p) = 0._r8\n    this % c13_psnsha_patch(p) = 0._r8\n  END IF\n  IF (use_c14) THEN\n    this % c14_psnsun_patch(p) = 0._r8\n    this % c14_psnsha_patch(p) = 0._r8\n  END IF\nEND SUBROUTINE NewPatchInit"}, {"color": "#97c2fc", "id": "ft", "label": "ft", "shape": "dot", "size": 10, "source": "FUNCTION ft(tl, ha) RESULT(ans)\n  USE clm_varcon, ONLY: rgas, tfrz\n  REAL(KIND = r8), INTENT(IN) :: tl\n  REAL(KIND = r8), INTENT(IN) :: ha\n  REAL(KIND = r8) :: ans\n  ans = EXP(ha / (rgas * 1.E-3_r8 * (tfrz + 25._r8)) * (1._r8 - (tfrz + 25._r8) / tl))\n  RETURN\nEND FUNCTION ft"}, {"color": "#97c2fc", "id": "fth", "label": "fth", "shape": "dot", "size": 10, "source": "FUNCTION fth(tl, hd, se, scaleFactor) RESULT(ans)\n  USE clm_varcon, ONLY: rgas, tfrz\n  REAL(KIND = r8), INTENT(IN) :: tl\n  REAL(KIND = r8), INTENT(IN) :: hd\n  REAL(KIND = r8), INTENT(IN) :: se\n  REAL(KIND = r8), INTENT(IN) :: scaleFactor\n  REAL(KIND = r8) :: ans\n  ans = scaleFactor / (1._r8 + EXP((- hd + se * tl) / (rgas * 1.E-3_r8 * tl)))\n  RETURN\nEND FUNCTION fth"}, {"color": "#97c2fc", "id": "fth25", "label": "fth25", "shape": "dot", "size": 10, "source": "FUNCTION fth25(hd, se) RESULT(ans)\n  USE clm_varcon, ONLY: rgas, tfrz\n  REAL(KIND = r8), INTENT(IN) :: hd\n  REAL(KIND = r8), INTENT(IN) :: se\n  REAL(KIND = r8) :: ans\n  ans = 1._r8 + EXP((- hd + se * (tfrz + 25._r8)) / (rgas * 1.E-3_r8 * (tfrz + 25._r8)))\n  RETURN\nEND FUNCTION fth25"}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "this % InitAllocate", "to": "Init", "width": 1}, {"arrows": "to", "from": "this % InitHistory", "to": "Init", "width": 1}, {"arrows": "to", "from": "this % InitCold", "to": "Init", "width": 1}, {"arrows": "to", "from": "params_inst % cleanParams", "to": "Clean", "width": 1}, {"arrows": "to", "from": "hist_addfld1d", "to": "InitHistory", "width": 1}, {"arrows": "to", "from": "hist_addfld2d", "to": "InitHistory", "width": 1}, {"arrows": "to", "from": "endrun", "to": "allocParams", "width": 1}, {"arrows": "to", "from": "endrun", "to": "readParams", "width": 1}, {"arrows": "to", "from": "endrun", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "endrun", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "endrun", "to": "brent", "width": 1}, {"arrows": "to", "from": "endrun", "to": "plc", "width": 1}, {"arrows": "to", "from": "endrun", "to": "d1plc", "width": 1}, {"arrows": "to", "from": "params_inst % allocParams", "to": "readParams", "width": 1}, {"arrows": "to", "from": "params_inst % allocParams", "to": "setParamsForTesting", "width": 1}, {"arrows": "to", "from": "ncd_io", "to": "readParams", "width": 1}, {"arrows": "to", "from": "readNcdioScalar", "to": "readParams", "width": 1}, {"arrows": "to", "from": "opnfil", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "shr_nl_find_group_name", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "relavu", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "shr_mpi_bcast", "to": "ReadNML", "width": 1}, {"arrows": "to", "from": "restartvar", "to": "Restart", "width": 1}, {"arrows": "to", "from": "shr_assert_all", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "shr_assert_all", "to": "Fractionation", "width": 1}, {"arrows": "to", "from": "quadratic", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "quadratic", "to": "ci_func", "width": 1}, {"arrows": "to", "from": "hybrid", "to": "Photosynthesis", "width": 1}, {"arrows": "to", "from": "C14BombSpike", "to": "PhotosynthesisTotal", "width": 1}, {"arrows": "to", "from": "C13TimeSeries", "to": "PhotosynthesisTotal", "width": 1}, {"arrows": "to", "from": "ci_func", "to": "hybrid", "width": 1}, {"arrows": "to", "from": "ci_func", "to": "brent", "width": 1}, {"arrows": "to", "from": "brent", "to": "hybrid", "width": 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": true,
        "filter": [
            "physics"
        ]
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  
                  // if this network requires displaying the configure window,
                  // put it in its div
                  options.configure["container"] = document.getElementById("config");
                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>